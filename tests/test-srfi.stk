;;;;
;;;; test-srfi.stk  -- Test of various SRFIs
;;;;
;;;; Copyright Â© 2005-2020 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date:  4-Aug-2005 10:34 (eg)
;;;; Last file update:  3-Jul-2020 12:17 (jpellegrini) 
;;;;

(require "test")

(test-section "SRFIs")

;; ----------------------------------------------------------------------
;;  SRFI 37 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 37 - args-fold: a program argument processor")

(require "srfi-37")

;; tests from Guile
;; Copyright (C) 2007, 2008, 2013 Free Software Foundation, Inc.
;; Released under the LGPL.
;; Adapted to STklos by Jeronimo Pellegrini

(test "empty calls with count-modified seeds"
      '(21 42)
      (call-with-values
	  (lambda ()
	    (args-fold '("1" "3" "4") '()
		       (lambda (opt name arg seed seed2)
			 (values 1 2))
		       (lambda (op seed seed2)
			 (values (+ 1 seed) (+ 2 seed2)))
		       18 36))
	list))

;; Guile returns '(#t #t "doit" "whatev" #t #t)
;; Chicken, Gauche, SISC, Kawa return '(#t #t "doit" #f #t #t)
;; Guile seems correct.
(test "short opt params"
      '(#t #t "doit" "whatev" #t #t)
      (let ((a-set #f) (b-set #f) (c-val #f) (d-val #f) (no-fail #t) (no-operands #t))
        (args-fold '("-abcdoit" "-ad" "whatev")
		   (list (option '(#\a) #f #f
                                 (lambda (opt name arg)
				   (set! a-set #t)
				   (values)))
		         (option '(#\b) #f #f
                                 (lambda (opt name arg)
				   (set! b-set #t)
				   (values)))
		         (option '("cdoit" #\c) #f #t
			         (lambda (opt name arg)
				   (set! c-val arg)
				   (values)))
		         (option '(#\d) #f #t
			         (lambda (opt name arg)
				   (set! d-val arg)
				   (values))))
		   (lambda (opt name arg) (set! no-fail #f) (values))
		   (lambda (oper) (set! no-operands #f) (values)))
        (list a-set b-set c-val d-val no-fail no-operands)))

(test "single unrecognized long-opt"
      "::fake"
      (args-fold '("--fake" "-i2")
        	 (list (option '(#\i) #t #f
        		       (lambda (opt name arg k) k)))
        	 (lambda (opt name arg k) (string-append "::" name))
        	 (lambda (operand k) #f)
        	 #f))

(test "long req'd/optional"
      '(#f "bsquare" "apple")
      (args-fold '("--x=pple" "--y=square" "--y")
        	 (list (option '("x") #t #f
        		       (lambda (opt name arg k)
        			 (cons (string-append "a" arg) k)))
        	       (option '("y") #f #t
        		       (lambda (opt name arg k)
        			 (cons (if arg
        				   (string-append "b" arg)
        				   #f) k))))
        	 (lambda (opt name arg k) #f)
        	 (lambda (opt name arg k) #f)
        	 '()))

;; this matches behavior of getopt_long in libc 2.4
(test "short options absorb special markers in the next arg"
      '((#\y . "-z") (#\x . "--") (#\z . #f))
      (let ((arg-proc (lambda (opt name arg k)
        	        (cons (cons  name arg ) k))))
        (args-fold '("-zx" "--" "-y" "-z" "--")
        	   (list (option '(#\x) #f #t arg-proc)
        		 (option '(#\z) #f #f arg-proc)
        		 (option '(#\y) #t #f arg-proc))
        	   (lambda (opt name arg k) #f)
        	   (lambda (opt name arg k) #f)
        	   '())))

(test "short options without arguments"
      ;; In Guile 1.8.4 and earlier, using short names of argument-less options
      ;; would lead to a stack overflow.
      '((#\x . #f))  
      (let ((arg-proc (lambda (opt name arg k)
        	        (cons (cons name arg) k))))
        (args-fold '("-x")
        	   (list (option '(#\x) #f #f arg-proc))
        	   (lambda (opt name arg k) #f)
        	   (lambda (opt name arg k) #f)
        	   '())))

(test "short option with optional argument omitted"
      'good
      ;; This would trigger an infinite loop in Guile up to 2.0.7.
      ;; See <http://bugs.gnu.org/13176>.
      (args-fold '("-I")
                 (list (option '(#\I) #f #t
                               (lambda (opt name arg value)
                                 (and (eqv? name #\I) (not arg)
                                      'good))))
                 (lambda _ (error "unrecognized"))
                 (lambda args #f)
                 #f))

;; Gosh, Chicken, SISC, Kawa return #f,
;; but the Guile tests expect "the-argument", whicih, according to the
;; SRFI, should be the correct value.
(test "short option with optional argument provided"
      "the-argument"
      (args-fold '("-I" "the-argument")
                 (list (option '(#\I) #f #t
                               (lambda (opt name arg result)
                                 (and (eqv? name #\I) arg))))
                 (lambda args (error "unrecognized"))
                 (lambda args #f)
                 #f))


;; ----------------------------------------------------------------------
;;  SRFI 51 ...https://github.com/egallesio/STklos/pulls
;; ----------------------------------------------------------------------
(test-subsection "SRFI 51 - Handling rest list")

(require "srfi-51")


(define rest-list '(x 1))
(define caller values)

(test "rest-values" '(1 2 3)   (let-values (((a b c) ((lambda (. a-b) (rest-values a-b 5)) 1 2 3)))
                                 (list a b c)))

(test "rest-list"            '(x 1)       (receive (a b)  (rest-values rest-list) (list a b)))
(test "rest-list 2"          '(x 1)       (receive (a b)  (rest-values rest-list 2) (list a b)))
(test "caller rest-list"     '(x 1)       (receive (a b)  (rest-values caller rest-list) (list a b)))
(test "caller rest-list -3"  '(x 1)       (receive (a b)  (rest-values caller rest-list -3) (list a b)))
(test "rest-list -"          '(x 1 "str") (receive (a b c) (rest-values rest-list - 'y 100 "str") (list a b c)))
(test "rest-list +"          '(x 1 "str") (receive (a b c) (rest-values rest-list + `(x y z) `(100 . ,number?) `("str" . ,string?)) (list a b c)))
(test "rest-list #t"         '(x 1 "str") (receive (a b c) (rest-values rest-list #t `(x y z) `(100 . ,number?) `("str" . ,string?)) (list a b c)))
(test "rest-list #t"         '(1 "str" x) (receive (a b c) (rest-values rest-list #t `(100 . ,number?) `("str" . ,string?) `(x y z)) (list a b c)))
(test "rest-list #f"         '(1 "str" y x) (receive (a b c d) (rest-values rest-list #f `(100 . ,number?) `("str" . ,string?) `(y z)) (list a b c d)))

;; ----------------------------------------------------------------------
;;  SRFI 54 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 54 - Formatting")

(require "srfi-9")  ;; some tests use records
(require "srfi-13") ;; one test uses string-reverse
(require "srfi-14") ;; two tests use charsets
(require "srfi-26") ;; two tests use cut...

(require "srfi-54")

(define-macro (mute-cat expr)
  `(let ((res #f))
     (with-output-to-string (lambda () (set! res ,expr)))
     res))


(test "align left" "130.00    " (cat 129.995 -10 2.))
(test "align right, I" "    130.00" (cat 129.995 10 2.))
(test "align right, II" "    129.98" (cat 129.985 10 2.))
(test "align right, III" "    129.99" (cat 129.985001 10 2.))
(test "exact" "#e130.00"   (cat 129.995 2. 'exact))
(test "decimal places" "129.00"     (cat 129 -2.))
(test "exact, II"  "#e129.00"  (cat 129 2.))
(test "exact w/sign, I" "#e+0129.00" (cat 129 10 2. #\0 'sign))
(test "exact w/sign, II" "*#e+129.00" (cat 129 10 2. #\* 'sign))
(test "rational" "1/3" (cat 1/3))
(test "exact, III" "    #e0.33" (cat 1/3 10 2.))
(test "rational floating point" "      0.33" (cat 1/3 10 -2.))
(test "commas" " 1,29.99,5" (cat 129.995 10 '(#\, 2)))
(test "commas w/sign" "  +129,995" (cat 129995 10 '(#\,) 'sign))
(test "round" "130" (cat (cat 129.995 0.) '(0 -1)))
(test "octal" "#i#o+307/2" (cat 99.5 10 'sign 'octal))
(test "exact octal" "  #o+307/2" (cat 99.5 10 'sign 'octal 'exact))
(test "octal w/sign" "#o+443" (cat #x123 'octal 'sign))
(test "exact w/sign, III" "#e+291.00*" (cat #x123 -10 2. 'sign #\*))

;; changed "e15" to "e+15" in the following test, since this is how STklos
;; writes
(test "complex" "-1.234e+15+1.236e-15i" (cat -1.2345e+15+1.2355e-15i 3.))
;; Same for this, but also fixed it so the length includes the leading space
;; (was 10, changed to 11)
(test "exact w/sign, IV" " +1.234e+15" (cat 1.2345e+15 11 3. 'sign))

(test "string -10" "string    " (cat "string" -10))
(test "string upcase" "    STRING" (cat "string" 10 (list string-upcase)))
(test "string upcase -2" "      RING" (cat "string" 10 (list string-upcase) '(-2)))
(test "string titlecase" "     Sting" (cat "string" 10 `(,string-titlecase) '(2 3)))
(test "string reverse upcase" "GNIRTS" (cat "string" `(,string-reverse ,string-upcase)))
(test "char" "         a" (cat #\a 10))
(test "symbol" "    symbol" (cat 'symbol 10))
(test "vector" "#(#\\a \"str\" s)" (cat '#(#\a "str" s)))
(test "list" "(#\\a \"str\" s)" (cat '(#\a "str" s)))


;; Tests with output changed to ignore the string printed below.
;; They're not to useful as this, but will at least detect crashes.

;; (test "" (#\a "str" s)"(#\\a \"str\" s)" (cat '(#\a "str" s) #t))
(test "output I" "(#\\a \"str\" s)" (mute-cat (cat '(#\a "str" s) #t)))

;;(test "" (#\a "str" s)"(#\\a \"str\" s)" (cat '(#\a "str" s) (current-output-port)))
(test "output II" "(#\\a \"str\" s)" (mute-cat (cat '(#\a "str" s) (current-output-port))))

;; original ok:
(test "output III" "3s \"str\"" (mute-cat (cat 3 (cat 's) " " (cat "str" write))))

;;(test "" 3s "str""3s \"str\"" (cat 3 #t (cat 's) " " (cat "str" write)))
(test "output IV" "3s \"str\"" (mute-cat (cat 3 #t (cat 's) " " (cat "str" write))))

;;(test "" s3s "str""3s \"str\"" (cat 3 #t (cat 's #t) " " (cat "str" write)))
(test "output V" "3s \"str\"" (mute-cat (cat 3 #t (cat 's #t) " " (cat "str" write))))


;; records!
(define-record-type :example
    (make-example num str)
    example?
    (num get-num set-num!)
    (str get-str set-str!))

(define ex (make-example 123 "string"))

(define (record->string object)
  (cat (get-num object) "-" (get-str object)))

(define (record-writer object string-port)
    (if (example? object)
    (begin (display (get-num object) string-port)
           (display "-" string-port)
           (display (get-str object) string-port))
    ((or (and (or (string? object)
              (char? object)
              (boolean? object))
          display)
         write) object string-port)))

;; STklos includes a unique identifier in the object description,
;;
;; stklos> ex
;; #[struct example 140336922587072]
;;
;; so we neex to adapt these tests
;;(test "ex" '#{:example} ex)
;;(test "#{:example}" (cat ex))

(test "ex"     #t (example? ex))
(test "cat ex" "#[struct example " (substring (cat ex) 0 17))

(test "record-writer" "          123-string" (cat ex 20 record-writer))

;; I don't know why this test doesn't work. It fails with the
;; following:
;; string-filter: bad string #[<char-set> 7fba1cc7b0f0]
;;
;; * Larceny seems to not include this (they have a different
;; test set for this SRFI);
;; * Racket passes this, but fails the other test that uses cut
;;
;; Maybe we should leave this commented out for now.
;;
;; (test ""
;;       "--------------GNIRTS"
;;       (cat ex 20 record-writer
;;            `(,(cut string-delete char-set:digit <>)
;;              ,string-upcase ,string-reverse)
;;            '(0 -1) #\-))

(test "record-writer/string-upcase"
      "---------------STING"
      (cat "string" 20 record-writer (list string-upcase) '(2 3) #\-))
(test "record-writer/fpoint"
      "            #e12.000"
      (cat 12 20 record-writer 3.))
(test "record->string"
      "          123-string"
      (cat ex 20 (cons example? record->string)))

(test ""
      "----------123-string"
      (cat ex 20 (cons example? record->string)
           `(,(cut string-delete char-set:digit <>)
             ,string-upcase ,string-reverse)
           '(0 -1) #\-))

(test "record->string/string-upcase"
      "---------------STING"
      (cat "string" 20 (cons example? record->string)  (list string-upcase) '(2 3) #\-))
(test "record->string/fpoint"
       "              12.000"
       (cat 12 20 (cons example? record->string) -3.))

;; ----------------------------------------------------------------------
;;  SRFI 60 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 60 - Integers as Bits")

(require "srfi-60")
(test "logand" "1000" (number->string (logand #b1100 #b1010) 2))
(test "logior" "1110" (number->string (logior #b1100 #b1010) 2))
(test "logxor" "110"  (number->string (logxor #b1100 #b1010) 2))
(test "lognot.1" "-10000001" (number->string (lognot #b10000000) 2))
(test "lognot.2" "-1" (number->string (lognot #b0) 2))
(test "logtest.1" #f (logtest #b0100 #b1011))
(test "logtest.1" #t (logtest #b0100 #b0111))
(test "logcount.1" 4 (logcount #b10101010))
(test "logcount.2" 0 (logcount 0))
(test "logcount.3" 1 (logcount -2))
(test "integer-length.1" 8 (integer-length #b10101010))
(test "integer-length.2" 0 (integer-length 0))
(test "integer-length.2" 4 (integer-length #b1111))
(test "log2-binary-factors"
      '((-1 . -1) (0 . 0) (1 . 1) (0 . 0) (2 . 2) (0 . 0)
        (1 . 1) (0 . 0) (3 . 3) (0 . 0) (1 . 1) (0 . 0)
        (2 . 2) (0 . 0) (1 . 1) (0 . 0) (4 . 4))
      (let ((res '()))
        (do ((idx 0 (+ 1 idx)))
            ((> idx 16))
          (set! res (cons (cons (log2-binary-factors (- idx))
                                (log2-binary-factors (+ idx)))
                          res)))
        (reverse res)))
(test "logbit?.1" #t (logbit? 0 #b1101))
(test "logbit?.2" #f (logbit? 1 #b1101))
(test "logbit?.3" #t (logbit? 2 #b1101))
(test "logbit?.4" #t (logbit? 3 #b1101))
(test "logbit?.5" #f (logbit? 4 #b1101))
(test "copybit.1" "1"   (number->string (copy-bit 0 0 #t) 2))
(test "copybit.2" "100" (number->string (copy-bit 2 0 #t) 2))
(test "copybit.3" "1011" (number->string (copy-bit 2 #b1111 #f) 2))
(test "bit-field.1" "1010" (number->string (bit-field #b1101101010 0 4) 2))
(test "bit-field.2" "10110" (number->string (bit-field #b1101101010 4 9) 2))
(test "copy-bit-field.1" "1101100000"
      (number->string (copy-bit-field #b1101101010 0 0 4) 2))
(test "copy-bit-field.2" "1101101111"
      (number->string (copy-bit-field #b1101101010 -1 0 4) 2))
(test "copy-bit-field.3" "110100111110000"
      (number->string (copy-bit-field #b110100100010000 -1 5 9) 2))
(test "ash.1" "1000" (number->string (ash #b1 3) 2))
(test "ash.2" "101" (number->string (ash #b1010 -1) 2))
(test "rotate-bit-field.1"  "10"
      (number->string (rotate-bit-field #b0100 3 0 4) 2))
(test "rotate-bit-field.2" "110100010010000"
      (number->string (rotate-bit-field #b110100100010000 -1 5 9) 2))
(test "rotate-bit-field.3" "110100000110000"
      (number->string (rotate-bit-field #b110100100010000 1 5 9) 2))
(test  "reverse-bit-field" "e5"
       (number->string (reverse-bit-field #xa7 0 8) 16))
(test "integer->list.1" '(#t #t #t #f #t) (integer->list #b11101))
(test "integer->list.2" '(#f #f #f #f #f #t #t #t #f #t) (integer->list #b11101 10))
(test "list->integer"   #b11101 (list->integer '(#f #f #f #f #f #t #t #t #f #t)))
(test "booleans->integer"  #b11101
      (booleans->integer #f #f #f #f #f #t #t #t #f #t))

;; ----------------------------------------------------------------------
;;  SRFI 62 ...
;; ----------------------------------------------------------------------

;; Tests have been moved to the end since test 62.5 breaks emacs
;; fonctifiation unil EOF

;; ----------------------------------------------------------------------
;;  SRFI 71 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 70 - Numbers")

(test "complex?" #t (complex? +inf.0))
(test "real?" #t (real? -inf.0))
(test "rational?" #f (rational? +inf.0))
(test "integer?" #f (integer? -inf.0))

(test "inexact?" #t (inexact? +inf.0))

(test "=.1" #t (= +inf.0 +inf.0))
(test "=.2" #f (= -inf.0 +inf.0))
(test "=.3" #t (= -inf.0 -inf.0))

(test "positive?" #t (positive? +inf.0))
(test "negative?" #t (negative? -inf.0))
(test "finite?" #f (finite? -inf.0))
(test "infinite?" #t (infinite? +inf.0))

(test "max.1" +inf.0 (max 12 +inf.0))
(test "max.2" +inf.0 (max 12.0 +inf.0))
(test "max.3" +inf.0 (max -inf.0 +inf.0))
(test "min.1" -inf.0 (min 12 -inf.0))
(test "min.2" -inf.0 (min 12.0 -inf.0))
(test "min.3" -inf.0 (min -inf.0 +inf.0))

(test "+.1" +inf.0 (+ +inf.0 +inf.0))
(test "+.2" +nan.0 (+ +inf.0 -inf.0))

(test "*.1" +inf.0 (* 5 +inf.0))
(test "*.2" -inf.0 (* -5 +inf.0))
(test "*.3" +inf.0 (* +inf.0 +inf.0))
(test "*.4" -inf.0 (* +inf.0 -inf.0))
(test "*.5" +nan.0 (* 0 +inf.0))

(test "-" +nan.0 (- +inf.0 +inf.0))


(test "/.1" +inf.0 (/ 0.0))
(test "/.2" +inf.0 (/ 1.0 0))
(test "/.3" -inf.0 (/ -1 0.0))
(test "/.4" +nan.0 (/ 0 0.0))
(test "/.5" +nan.0 (/ 0.0 0))
(test "/.6" +nan.0 (/ 0.0 0.0))

(test "angle.1" #t (< (- (* 4 (atan 1))
             (angle -inf.0))
              0.00001))
(test "angle.2" 0.0 (angle +inf.0))

(test "string->number.1" +inf.0 (string->number "+inf.0"))
(test "string->number.2" -inf.0 (string->number "-inf.0"))
(test "number->string.1" "+inf.0" (number->string +inf.0))
(test "number->string.2" "-inf.0" (number->string -inf.0))

;; ----------------------------------------------------------------------
;;  SRFI 74 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 74 - BLOBs")

(require "srfi-74")

(define b1 (make-blob 16))

(test "blob-length" 16 (blob-length b1))

(blob-u8-set! b1 0 223)
(blob-s8-set! b1 1 123)
(blob-s8-set! b1 2 -123)
(blob-u8-set! b1 3 15)

(test "blob repr"
      '(223 123 123 -123 133 15)
      (list (blob-u8-ref b1 0)
        (blob-s8-ref b1 1)
        (blob-u8-ref b1 1)
        (blob-s8-ref b1 2)
        (blob-u8-ref b1 2)
        (blob-u8-ref b1 3)))

(blob-uint-set! 16 (endianness little) b1 0 (- (expt 2 128) 3))
(test "blob-uint-ref.1"
      (- (expt 2 128) 3)
      (blob-uint-ref 16 (endianness little) b1 0))
(test "blob-uint-ref.2"
      -3
      (blob-sint-ref 16 (endianness little) b1 0))

(test "blob->u8-list"
      '(253 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255)
      (blob->u8-list b1))

(blob-uint-set! 16 (endianness big) b1 0 (- (expt 2 128) 3))

(test "blob-uint-ref.3"
      (- (expt 2 128) 3)
      (blob-uint-ref 16 (endianness big) b1 0))

(test "blob-sint-ref"
      -3
      (blob-sint-ref 16 (endianness big) b1 0))

(test "blob->u8-list"
      '(255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 253)
      (blob->u8-list b1))

(test "blob-u16-ref"
      65023
      (blob-u16-ref (endianness little) b1 14))

(test "blob-s16-ref"
      -513
      (blob-s16-ref (endianness little) b1 14))

(test "blob-u16-ref"
      65533
      (blob-u16-ref (endianness big) b1 14))

(test "blob-s16-ref"
      -3
      (blob-s16-ref (endianness big) b1 14))


(blob-u16-set! (endianness little) b1 0 12345)
(blob-u16-native-set! b1 0 12345)

(test "blob-u16-native-ref"
      12345
      (blob-u16-native-ref b1 0))

(test "blob-u32-ref"
      4261412863
      (blob-u32-ref (endianness little) b1 12))
(test "blob-s32-ref"
      -33554433
      (blob-s32-ref (endianness little) b1 12))

(test "blob-u32-ref"
      4294967293
      (blob-u32-ref (endianness big) b1 12))
(test "blob-s32-ref"
      -3
      (blob-s32-ref(endianness big) b1 12))

(blob-u32-set! (endianness little) b1 0 12345)
(blob-u32-native-set! b1 0 12345)

(test "blob-u32-native-ref"
      12345
      (blob-u32-native-ref b1 0))
(test "blob-u64-ref"
      18302628885633695743
       (blob-u64-ref (endianness little) b1 8))
(test "(blob-s64-ref (endianness little) b1 8)"
      -144115188075855873
      (blob-s64-ref (endianness little) b1 8))
(test "(blob-u64-ref (endianness big) b1 8)"
      18446744073709551613
      (blob-u64-ref (endianness big) b1 8))
(test "(blob-s64-ref (endianness big) b1 8)"
      -3
      (blob-s64-ref (endianness big) b1 8))

(blob-u64-set! (endianness little) b1 0 12345)
(blob-u64-native-set! b1 0 12345)

(test "(blob-u64-native-ref b1 0)"
      12345
      (blob-u64-native-ref b1 0))

(define b2 (u8-list->blob '(1 2 3 4 5 6 7 8)))
(define b3 (blob-copy b2))

(test "(blob=? b2 b3)"
      #t
      (blob=? b2 b3))
(test "(blob=? b1 b2)"
      #f
      (blob=? b1 b2))

(blob-copy! b3 0 b3 4 4)
(test "(blob->u8-list b3)"
      '(1 2 3 4 1 2 3 4)
      (blob->u8-list b3))

(blob-copy! b3 0 b3 2 6)
(test "(blob->u8-list b3)"
      '(1 2 1 2 3 4 1 2)
      (blob->u8-list b3))

(blob-copy! b3 2 b3 0 6)
(test "(blob->u8-list b3)"
      '(1 2 3 4 1 2 1 2)
      (blob->u8-list b3))
(test "(blob->uint-list 1 (endianness little) b3)"
      '(1 2 3 4 1 2 1 2)
      (blob->uint-list 1 (endianness little) b3))
(test "(blob->uint-list 2 (endianness little) b3)"
      '(513 1027 513 513)
      (blob->uint-list 2 (endianness little) b3))

(define b4 (u8-list->blob '(0 0 0 0 0 0 48 57 255 255 255 255 255 255 255 253)))

(test "(blob->sint-list 2 (endianness little) b4)"
      '(0 0 0 14640 -1 -1 -1 -513)
      (blob->sint-list 2 (endianness little) b4))


;; ----------------------------------------------------------------------
;;  SRFI 87 and R7RS ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 87 - => in case clauses")

(test "=> else symbol" 'none (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else => (lambda (x) 'none))))
(test "=> choose non-procedure" *test-failed* (case 10 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else 'none)))
(test "=> don't choose non-procedure" 'none (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else 'none)))
(test "=> don't choose non-procedure, II"  -20 (case 20 ((5) 'five) ((10) => 'ten) ((15) 'fifteen) (else => (lambda (x) (- x)))))
(test "=> else number" 60 (case 20 ((5) 'five) ((10) 'ten) ((15) 'fifteen) (else =>  (lambda (x) (* x 3)))))
(test "=> else -" -20 (case 20 ((5) 'five) ((10) 'ten) ((15) 'fifteen) (else =>  -)))
(test "=> only"  #\z (case #\Z ((#\a) => char-upcase)
                               ((#\c) => (lambda (x) (string x #\d)))
                               ((#\z) => char->integer)
                               ((#\Z) => char-downcase)
                               (else => #f)))

;; ----------------------------------------------------------------------
;;  SRFI 117 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 117 - Queues based on lists")

(require "srfi-117")

;; list-queues/simple
(test "make-list-queue"  '(1 1 1) (list-queue-list (make-list-queue '(1 1 1))))
(define x (list-queue 1 2 3))
(test "list-queue-list" '(1 2 3) (list-queue-list x))
(define x1 (list 1 2 3))
(define x2 (make-list-queue x1 (cddr x1)))
(test "list-queue-back" 3 (list-queue-back x2))
(define y (list-queue 4 5))
(test "list-queue?" #t (list-queue? y))
(define z (list-queue-append x y))
(test "list-queue-append" '(1 2 3 4 5) (list-queue-list z))
(define z2 (list-queue-append! x (list-queue-copy y)))
(test "list-queue-append-copy" '(1 2 3 4 5) (list-queue-list z2))
(test "list-queue-append-copy-front" 1 (list-queue-front z))
(test "list-queue-append-copy-back" 5 (list-queue-back z))
(list-queue-remove-front! y)
(test "list-queue-remove-front!" '(5) (list-queue-list y))
(list-queue-remove-back! y)
(test "list-queue-empty?" #t (list-queue-empty? y))
(test "list-queue don't remove-front from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-front! y)))
(test "list-queue don't remove-back from empty"
      'error-occurred
      (with-handler (lambda (e)
                      'error-occurred)
                    (list-queue-remove-back! y)))
(test "list-queue-list II" '(1 2 3 4 5) (list-queue-list z))
(test "list-queue-remove-all!" '(1 2 3 4 5) (list-queue-remove-all! z2))
(test "list-queue-remove-all! -> empty" #t (list-queue-empty? z2))
(list-queue-remove-all! z)
(list-queue-add-front! z 1)
(list-queue-add-front! z 0)
(list-queue-add-back! z 2)
(list-queue-add-back! z 3)
(test "list-queue-remove-all-add-4" '(0 1 2 3) (list-queue-list z))

;; list-queues/whole
(define a (list-queue 1 2 3))
(define b (list-queue-copy a))
(test "list-queue-copy" '(1 2 3) (list-queue-list b))
(list-queue-add-front! b 0)
(test "list-queue-copy is not shared" '(1 2 3) (list-queue-list a))
(test "list-queue-copy size" 4 (length (list-queue-list b)))
(define c (list-queue-concatenate (list a b)))
(test "list-queue-concatenate" '(1 2 3 0 1 2 3) (list-queue-list c))

;; list-queues/map
(define r (list-queue 1 2 3))
(define s (list-queue-map (lambda (x) (* x 10)) r))
(test "list-queue-map" '(10 20 30) (list-queue-list s))
(list-queue-map! (lambda (x) (+ x 1)) r)
(test "list-queue-map!" '(2 3 4) (list-queue-list r))
(define sum 0)
(list-queue-for-each (lambda (x) (set! sum (+ sum x))) s)
(test "list-queue-for-each" 60 sum)

;; list-queues/conversion
(define n (list-queue 5 6))
(list-queue-set-list! n (list 1 2))
(test "list-queue-set-list!" '(1 2) (list-queue-list n))
(define d (list 1 2 3))
(define e (cddr d))
(define f (make-list-queue d e))
(define dx #f) ; redefined below
(define ex #f) ; redefined below
(let-values (((dxv exv) (list-queue-first-last f)))
  (set! dx dxv)
  (set! ex exv))
(test "list-queue-first-last" #t (eq? d dx))
(test "list-queue-first-last II" #t (eq? e ex))
(test "list-queue-first-last III" '(1 2 3) (list-queue-list f))
(list-queue-add-front! f 0)
(list-queue-add-back! f 4)
(test "list-queue-add-{front,back}!" '(0 1 2 3 4) (list-queue-list f))
(define g (make-list-queue d e))
(test "make-list-queue II" '(1 2 3 4) (list-queue-list g))
(define h (list-queue 5 6))
(list-queue-set-list! h d e)
(test "list-queue-set-list! II" '(1 2 3 4) (list-queue-list h))

;; list-queues/unfold
(define (double x) (* x 2))
(define (done? x) (> x 3))
(define (add1 x) (+ x 1))
(define x (list-queue-unfold done? double add1 0))
(test "list-queue-unfold" '(0 2 4 6) (list-queue-list x))
(define y (list-queue-unfold-right done? double add1 0))
(test "list-queue-unfold-right" '(6 4 2 0) (list-queue-list y))
(define x0 (list-queue 8))
(define x1 (list-queue-unfold done? double add1 0 x0))
(test "list-queue-unfold II" '(0 2 4 6 8) (list-queue-list x1))
(define y0 (list-queue 8))
(define y1 (list-queue-unfold-right done? double add1 0 y0))
(test "list-queue-unfold-right II" '(8 6 4 2 0) (list-queue-list y1))


;; ----------------------------------------------------------------------
;;  SRFI 129 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 129 - Titlecase procedures")

(require "srfi-129")

(test "" #t (char-title-case? #\x01C5))
(test "" #t (char-title-case? #\x1FFC))
(test "" #f (char-title-case? #\Z))
(test "" #f (char-title-case? #\z))

(test "char 1" #\x01C5 (char-titlecase #\x01C4))
(test "char 2" #\x01C5 (char-titlecase #\x01C6))
(test "char 3" #\Z (char-titlecase #\Z))
(test "char 4" #\Z (char-titlecase #\z))

(test "string 1" "\x01C5;" (string-titlecase "\x01C5;"))
(test "string 2" "\x01C5;" (string-titlecase "\x01C4;"))    ;
(test "string 3" "Ss" (string-titlecase "\x00DF;"))         ;
(test "string 4" "Xi\x0307;" (string-titlecase "x\x0130;")) ;
(test "string 5" "\x1F88;" (string-titlecase "\x1F80;"))
(test "string 6" "\x1F88;" (string-titlecase "\x1F88;"))


(define Floo "\xFB02;oo")
(define Floo-bar "\xFB02;oo bar")
(define Baffle "Ba\xFB04;e")
(define LJUBLJANA "\x01C7;ub\x01C7;ana")
(define Ljubljana "\x01C8;ub\x01C9;ana")
(define ljubljana "\x01C9;ub\x01C9;ana")

(test "string 7" "Bar Baz" (string-titlecase "bAr baZ"))
(test "string 8" "Floo" (string-titlecase "floo"))
(test "string 9" "Floo" (string-titlecase "FLOO"))
(test "string 10" "Floo" (string-titlecase Floo))          ;
(test "string 11" "Floo Bar" (string-titlecase "floo bar"))
(test "string 12" "Floo Bar" (string-titlecase "FLOO BAR"))
(test "string 13" "Floo Bar" (string-titlecase Floo-bar))  ;
(test "string 14" Baffle (string-titlecase Baffle))
(test "string 15" Ljubljana (string-titlecase LJUBLJANA))  ;
(test "string 16" Ljubljana (string-titlecase Ljubljana))
(test "string 17" Ljubljana (string-titlecase ljubljana))  ;

;; ----------------------------------------------------------------------
;;  SRFI 141 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 141 - Integer division")

(require "srfi-141")

;; SRFI 141 comes with no tests, so I have ceated a few.

(define nums-dens '( (25 3)
                     (-25 3)
                     (17 3)
                     (-17 3)
                     (29 5)
                     (-29 5)
                     (30 3)
                     (-30 3)
                     (101 80)
                     (-101 80)
                     (101 -80)
                     (100 60)
                     (-100 60) ))

(for-each (lambda (num-den)
            (let ((n (car num-den))
                  (d (cadr num-den)))
              (let ((flq (floor-quotient n d))
                    (flr (floor-remainder n d))
                    (clq (ceiling-quotient n d))
                    (clr (ceiling-remainder n d))
                    (tcq (truncate-quotient n d))
                    (tcr (truncate-remainder n d))
                    (rdq (round-quotient n d))
                    (rdr (round-remainder n d))
                    (euq (euclidean-quotient n d))
                    (eur (euclidean-remainder n d))
                    (blq (balanced-quotient n d))
                    (blr (balanced-remainder n d)))

                (test (format "flq:~d:~d" n d)
                      (floor (/ n d))
                      flq)
                (test (format "flr:~d:~d" n d)
                     (- n (* flq d))
                     flr)
                
                (test (format "clq:~d:~d" n d)
                      (ceiling (/ n d))
                      clq)
                (test (format "clr:~d:~d" n d)
                      (- n (* clq d))
                      clr)
                
                (test (format "trlq:~d:~d" n d)
                      (truncate (/ n d))
                      tcq)
                (test (format "trr:~d:~d" n d)
                      (- n (* tcq d))
                      tcr)

                (test (format "rdq:~d:~d" n d)
                      (round (/ n d))
                      rdq)
                (test (format "rdr:~d:~d" n d)
                      (- n (* rdq d))
                      rdr)
          
                (test (format "euq:~d:~d" n d)
                      (if (positive? d)
                          (floor (/ n d))
                          (ceiling (/ n d)))
                      euq)
                (test (format "eur3:~d:~d" n d)
                      #t
                      (< eur (abs d)))
                (test (format "eur2:~d:~d" n d)
                      #t
                      (>= eur 0))
                (test (format "eur:~d:~d" n d)
                      (- n (* euq d))
                      eur)

                (test (format "blr1:~d:~d" n d)
                      #t
                      (< blr (abs (/ d 2))))
                (test (format "blr2:~d:~d" n d)
                      #t
                      (>= blr (- (abs (/ d 2)))))
                (test (format "blr:~d:~d" n d)
                      (- n (* blq d))
                      blr))))
          nums-dens)

;; ----------------------------------------------------------------------
;;  SRFI 156 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 156 - Syntactic combiners for binary predicates")

(require "srfi-156")


;; the tests were translated from the original SRFI reference implementation

(test "" #t
 (is 1 odd?))

(test "" #t
 (isnt 2 odd?))

(test "" #t
 (is '() null?))

(test "" #t
 (is procedure? procedure?))

(test "" #t
 (isnt 5 procedure?))

;; two arguments:

(test "" #t
 (is 1 < 2))

(test "" #t
 (isnt 1 < 1))

(test "" #t
 (is (+ 2 2) = 4))

(test "" #t
 (is 'x eq? 'x))

(test "" #t
 (is procedure? eq? procedure?))

(test "" #t
 (eq? (is eq? eq? eq?)
      (eq? eq? eq?)))

(test "" #t
 (is (is eq? eq? eq?) eq? (eq? eq? eq?)))

(test "" '(y z)
 (is 'y memq '(x y z)))

(test "" '((1) (2) (1 2))
 (is '(1) member '(() (1) (2) (1 2))))

(test "" #t
 (isnt 'x eq? 'y))

(test "" #t
 (is '(a b c) equal? '(a b c)))

(test "" #t
 (isnt '(a b c) equal? '(c b a)))

(test "" #t
 (is 0 = 0.0))

(test "" #t
 (is 1.0 = 1))

(test "" #t
 (isnt 1 = 0))

(define (divisible-by? x y)
  (is (modulo x y) = 0))

(test "" #t
 (is 9 divisible-by? 3))

(test "" #t
 (isnt 3 divisible-by? 9))

;; ending with unary predicate:

(test "" #t
 (is 1 < 2 even?))

(test "" #t
 (isnt 1 < 2 odd?))

(test "" #t
 (isnt 2 < 1 even?))

(test "" #t
 (is 0 = 0.0 zero?))

(test "" #t
 (isnt 1.0 = 1 zero?))

;; three arguments:

(test "" #t
 (is 1 < 2 <= 3))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i))

(test "" #t
 (isnt 1 <= 2 < 2))

;; predicates don't need to be transitive
;; (although that's not particularly elegant):

(test "" #t
 (is 1 < 2 > 1.5))

(test "" #t
 (isnt 1 < 2 > 3))

(test "" #t
 (isnt 3 < 2 < 1))

(test "" '((x y) (y x))
 (is 'x member '(x y) member '((x y) (y x))))

;; more arguments:

(test "" #t
 (is -0.4 < -0.1 <= 0 = 0.0 < 0.1 < 0.4))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 = 0.0 < 0.1 < -0.1))

(test "" #t
 (is 0 = 0.0 = 0+0i = 0.0+0.0i = (+) < (*) = 1 = 1.0 = 1+0i = 1.0+0.0i))

;; ending with unary predicate:

(test "" #t
 (is -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 even?))

(test "" #t
 (isnt -0.4 < -0.1 <= 0 <= 0.0 < 0.1 < 0.4 <= 2 odd?))

;; as procedures (with underscore):

(test "" #t
 (equal? (filter (isnt _ even?) '(2 4 5 6 7 8))
	 '(5 7)))

(test "" #t
 (equal? (filter (is _ < 2) '(1 3 2 0))
	 '(1 0)))

(test "" #t
 (equal? (filter (is 1 < _) '(1 3 2 0))
	 '(3 2)))

(test "" #t
 (equal? (filter (is 3 < _ <= 5) '(2 3 4 5 6 7))
	 '(4 5)))

(test "" #t
 (equal? (filter (is 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
	 '((x) (x y) (z x))))

(test "" #t
 (equal? (filter (isnt 'x memq _) '((a b) (x) (p q) (x y) (c d) (z x)))
	 '((a b) (p q) (c d))))

(test "" #t
 (equal? (filter (isnt 3 < _ <= 5) '(2 3 4 5 6 7))
	 '(2 3 6 7)))

(test "" #t
 (equal? (filter (is _ eq? 'a) '(m a m a))
	 '(a a)))

(test "" #t
 (equal? (filter (isnt 'a eq? _) '(m a m a))
	 '(m m)))

;; multiple underscores:

(test "" #t
 ((is _ < 2 < _) 1 3))

(test "" #t
 ((isnt 1 < _ <= _ < 3) 2 4))

(test "" #t
 ((is _ < _ even?) 1 2))

(test "" #t
 ((isnt _ < _ odd?) 1 2))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _) 3 3 6))

(test "" #t
 ((is 1 < _ <= 3 < _ <= 5 < _ even?) 3 5 6))

(test "" #t
 ((isnt 1 < _ <= 3 < _ <= 5 < _ odd?) 3 5 6))

;; ----------------------------------------------------------------------
;;  SRFI 158 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 158 - generators")

(require "srfi-158")


(test "iota-simple" (generator->list (make-iota-generator 3 8)) '(8 9 10))
(test "iota-step" (generator->list (make-iota-generator 3 8 2)) '(8 10 12))
(test "range-simple" (generator->list (make-range-generator 3) 4) '(3 4 5 6))
(test "range-upper-limit" (generator->list (make-range-generator 3 8)) '(3 4 5 6 7))
(test "range-upper-limit-step" (generator->list (make-range-generator 3 8 2)) '(3 5 7))

(define g
  (make-coroutine-generator
   (lambda (yield) (let loop ((i 0))
                (when (< i 3) (yield i) (loop (+ i 1)))))))
(test "coroutine-generator" (generator->list g) '(0 1 2))

(test "list->generator" (generator->list (list->generator '(1 2 3 4 5))) '(1 2 3 4 5))
(test "vector->generator" (generator->list (vector->generator '#(1 2 3 4 5))) '(1 2 3 4 5))
(test "reverse-vector->generator" (generator->list (reverse-vector->generator '#(1 2 3 4 5))) '(5 4 3 2 1))
(test "string->generator" (generator->list (string->generator "abcde")) '(#\a #\b #\c #\d #\e))
(test "vector->generator-start" (generator->list (vector->generator '#(a b c d e) 2)) '(c d e))
(test "vector->generator-start-end" (generator->list (vector->generator '#(a b c d e) 2 4)) '(c d))
(test "reverse-vector->generator-start" (generator->list (reverse-vector->generator '#(a b c d e) 2)) '(e d c))
(test "reverse-vector->generator-start-end" (generator->list (reverse-vector->generator '#(a b c d e) 2 4)) '(d c))
(test "reverse-vector->generator-start-end-2" (generator->list (reverse-vector->generator '#(a b c d e) 0 2)) '(b a))

(test "make-unfold-generator" (generator->list (make-unfold-generator
                                                (lambda (s) (> s 5))
                                                (lambda (s) (* s 2))
                                                (lambda (s) (+ s 1))
                                                0))
      '(0 2 4 6 8 10))

(test "gcons*" (generator->list (gcons* 'a 'b (make-range-generator 0 2))) '(a b 0 1))
(test "gappend" (generator->list (gappend (make-range-generator 0 3) (make-range-generator 0 2))) '(0 1 2 0 1))
(test "gappend-2" (generator->list (gappend)) '())
(test "gmap"    (generator->list (gmap - (make-range-generator 0 3))) '(0 -1 -2))
(test "gmap-2"  (generator->list (gmap cons (generator 1 2 3) (generator 4 5))) '((1 . 4) (2 . 5)))
(test "gdelete" (generator->list (gdelete 3 (generator 1 2 3 4 5 3 6 7))) '(1 2 4 5 6 7))
(test "gdelete-neighbor-dups" (generator->list (gdelete-neighbor-dups (list->generator '(a a b c a a a d c)))) '(a b c a d c))
(test "gindex" (generator->list (gindex (list->generator '(a b c d e f))
                                        (list->generator '(0 2 4))))
      '(a c e))
(test "gselect" (generator->list (gselect (list->generator '(a b c d e f))
                                          (list->generator '(#t #f #f #t #t #f))))
      '(a d e))

;; ----------------------------------------------------------------------
;;  SRFI 169 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 169 - Underscores in numbers")

;; bin
(test "binary" 201 (read-from-string "#b11001001"))
(test "binary" 201 (read-from-string "#b1_1_0_0_1_0_0_1"))
(test "binary" 201 (read-from-string "#b1_1001001"))
(test "binary" 201 (read-from-string "#b110_01001"))
(test "binary" 201 (read-from-string "#b1100100_1"))

(test/error "binary, leading _"  (read-from-string "#b_11001001"))
(test/error "binary, trailing _" (read-from-string "#b11001001_"))
(test/error "binary, #_b"        (read-from-string "#_b11001001"))
(test/error "binary, double _"   (read-from-string "#b1100__1001"))

;; if it begins with _, it's a symbol!
(test "binary, _#b"  #t (symbol? (read-from-string "_#b11001001")))

;; hex
(test "hex" 4194308277 (read-from-string "#xfa0010b5"))
(test "hex, several _" 4194308277 (read-from-string "#xf_a_0_0_1_0_b_5"))
(test "hex, left _" 4194308277 (read-from-string "#xf_a0010b5"))
(test "hex, right _" 4194308277 (read-from-string "#xfa0010b_5"))
(test "hex, middle _" 4194308277 (read-from-string "#xfa0_010b5"))

(test/error "hex, leading _"  (read-from-string "#x_fa0010b5"))
(test/error "hex, trailing _" (read-from-string "#xfa0010b5_"))
(test/error "hex, #_x"        (read-from-string "#_xfa0010b5"))
(test/error "hex, double _"   (read-from-string "#xfa0__010b5"))

;; if it begins with _, it's a symbol!
(test "hex, _#x" #t (symbol? (read-from-string "_#xfa0010b5")))

;; from the SRFI
;; integers
(test "int" 123 (read-from-string "0123"))
(test "int, three underscores" 123 (read-from-string "0_1_2_3"))
(test "int, one underscore I" 123 (read-from-string "0_123"))
(test "int, one underscore II" 123 (read-from-string "01_23"))
(test "int, one underscore III" 123 (read-from-string "012_3"))
(test "int, signed+, no underscore" 123 (read-from-string "+0123"))
(test "int, signed+, one underscore" 123 (read-from-string "+0_123"))
(test "int, signed-, no underscore" -123 (read-from-string "-0123"))
(test "int, signed-, one underscore" -123 (read-from-string "-0_123"))


(test "int, leading _" #f (number? (read-from-string "_0123")))
(test "int, trailing _" #f (number? (read-from-string "0123_")))
(test "int, trailing double _" #f (number? (read-from-string "0123__")))
(test "int, double _" #f (number? (read-from-string "01__23")))
(test "int, several _" #f (number? (read-from-string "0_1__2___3")))
(test "int, _ after sign+" #f (number? (read-from-string "+_0123")))
(test "int, signed+, trailing _" #f (number? (read-from-string "+0123_")))
(test "int, after sign-" #f (number? (read-from-string "-_0123")))
(test "int, signed-, trailing _" #f (number? (read-from-string "-0123_")))

;; reals
(test "real" 123.456 (read-from-string "123.456"))
(test "real, 4 underscores" 123.456 (read-from-string "0_1_23.4_5_6"))
(test "real, exp-notation" 123.5e6 (read-from-string "1_2_3.5e6"))
(test "real, exp-notation" 12e12 (read-from-string "1_2e1_2"))

(test "real, leading _" #f (number? (read-from-string "_0123.456")))
(test "real, _." #f (number? (read-from-string "0123_.456")))
(test "real, ._" #f (number? (read-from-string "0123._456")))
(test "real, trailing _" #f (number? (read-from-string "0123.456_")))
(test "real, _., exp-notation" #f (number? (read-from-string "123_.5e6" )))
(test "real, ._, exp-notation" #f (number? (read-from-string "123._5e6" )))
(test "real, _e" #f (number? (read-from-string "123.5_e6" )))
(test "real, e_" #f (number? (read-from-string "123.5e_6" )))
(test "real, trailing _, exp-notation" #f (number? (read-from-string "123.5e6_" )))
(test "real, _e, no dot" #f (number? (read-from-string "12_e12"   )))
(test "real e_, no dot" #f (number? (read-from-string "12e_12"   )))
(test "real, trailing _, no dot" #f (number? (read-from-string "12e12_"   )))

(test "octal, two _"  80247 (read-from-string "#o23_45_67"))
(test "int, #d, two _" 456789 (read-from-string "#d45_67_89"))
(test "hex, negative" -32 (read-from-string "#x-2_0"))
(test "octal, signed, two _" 10030 (read-from-string "#o+2_345_6"))

(test/error "hex, #x-_"  (read-from-string "#x-_2"))
(test "_#x-_"  #t (symbol? (read-from-string "_#x-_2")))
(test/error "#d_"   (read-from-string "#d_45_67_89"))
(test/error "#e_"  (read-from-string "#e_45/67_89"))
(test/error "#i#o_"  (read-from-string "#i#o_1234"))
(test/error "#i_#o_" (read-from-string "#i_#o_1234"))
(test/error "trailing _" (read-from-string "#e#x1234_"))

;; ---------------------------------------------------------------------
;;  SRFI 171 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 171 - Transducers")

(require "srfi-1")
(require "srfi-66")
(require "srfi-69")
(require "srfi-171")

(define (add1 x) (+ x 1))

(define numeric-list (iota 5))
(define numeric-vec (list->vector numeric-list))
(define bv (list->u8vector numeric-list))
(define test-string "0123456789abcdef")
(define list-of-chars (string->list test-string))

;; for testing all treplace variations
(define replace-alist '((1 . s) (2 . c) (3 . h) (4 . e) (5 . m)))
(define stklos-hashtable (%old-alist->hash-table replace-alist eq? md5sum))
(define srfi69-hashtable (alist->hash-table replace-alist))
;;(define rnrs-hashtable (rnrs:make-eq-hashtable))

;; No rnrs hashtables
;; (rnrs:hashtable-set! rnrs-hashtable 1 's)
;; (rnrs:hashtable-set! rnrs-hashtable 2 'c)
;; (rnrs:hashtable-set! rnrs-hashtable 3 'h)
;; (rnrs:hashtable-set! rnrs-hashtable 4 'e)
;; (rnrs:hashtable-set! rnrs-hashtable 5 'm)

(define (replace-function val)
  (case val
    ((1) 's)
    ((2) 'c)
    ((3) 'h)
    ((4) 'e)
    ((5) 'm)
    (else val)))

;; Test procedures for port-transduce
;; broken out to properly close port
(define (port-transduce-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
        (res (equal? 15 (port-transduce (tmap add1) + read
                                        (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))
(define (port-transduce-with-identity-test)
  (let* ((port (open-input-string "0 1 2 3 4"))
         (res (equal? 15 (port-transduce (tmap add1)
                                         +
                                         0
                                         read
                                         (open-input-string "0 1 2 3 4")))))
    (close-port port)
    res))


;;; helpers:


  (define (compose . functions)
    (define (make-chain thunk chain)
      (lambda args
        (call-with-values (lambda () (apply thunk args)) chain)))
    (if (null? functions)
        values
        (fold make-chain (car functions) (cdr functions))))


;; "transducers"


(test "tmap"
      '(1 2 3 4 5)
      (list-transduce (tmap add1)
                      rcons
                      numeric-list))

(test "tfilter"
      '(0 2 4)
      (list-transduce (tfilter even?)
                      rcons
                      numeric-list))

(test "tfilter+tmap"
      '(1 3 5)
      (list-transduce (compose (tfilter even?) (tmap add1))
                      rcons
                      numeric-list))

(test "tfilter-map"
      '(1 3 5)
      (list-transduce (tfilter-map
                       (lambda (x)
                         (if (even? x)
                             (+ x 1)
                             #f)))
                      rcons numeric-list))

(test "tremove"
      (list-transduce (tremove char-alphabetic?)
                      rcount
                      list-of-chars)
      (string-transduce (tremove char-alphabetic?)
                        rcount
                        test-string))

(test "treplace with alist"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-alist)
                      rcons
                      '(1 2 3 4 5 4 r o c k s) ))

(test "treplace with replace-function"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace replace-function)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with STklos hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace stklos-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

(test "treplace with srfi-69 hash-table"
      '(s c h e m e  r o c k s)
      (list-transduce (treplace srfi69-hashtable)
                      rcons
                      '(1 2 3 4 5 4 r o c k s)))

;; STklos has no RNRS hashtables, so we comment this out.
;;
;; (test "treplace with rnrs hash-table"
;;       '(s c h e m e  r o c k s)
;;       (list-transduce (treplace rnrs-hashtable)
;;                       rcons
;;                       '(1 2 3 4 5 4 r o c k s)))

(test "ttake"
      6 (list-transduce (ttake 4) + numeric-list))

(test "tdrop"
      7 (list-transduce (tdrop 3) + numeric-list))

(test "tdrop-while"
      '(3 4)
      (list-transduce (tdrop-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "ttake-while"
      '(0 1 2)
      (list-transduce (ttake-while (lambda (x) (< x 3)))
                      rcons
                      numeric-list))

(test "tconcatenate"
      '(0 1 2 3 4) (list-transduce tconcatenate
                                   rcons
                                   '((0 1) (2 3) (4))))

(test "tappend-map"
      '(1 2 2 4 3 6)
      (list-transduce (tappend-map (lambda (x) (list x (* x 2))))
                      rcons
                      '(1 2 3)))

(test "tdelete-neighbor-duplicates"
      '(1 2 1 2 3)
      (list-transduce (tdelete-neighbor-duplicates)
                      rcons
                      '(1 1 1 2 2 1 2 3 3)))

(test "tdelete-neighbor-duplicates with equality predicate"
      '(a b c "hej" "hej")
      (list-transduce (tdelete-neighbor-duplicates eq?)
                      rcons
                      (list 'a 'a 'b 'c 'c "hej" (string #\h #\e #\j))))

(test "tdelete-duplicates"
      '(1 2 3 4)
      (list-transduce (tdelete-duplicates)
                      rcons
                      '(1 1 2 1 2 3 3 1 2 3 4)))

(test "tdelete-duplicates with predicate"
      '("hej" "hopp")
      (list-transduce (tdelete-duplicates string-ci=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "heJ")))

;; added by jpellegrini:
(test "tdelete-duplicates with string=?"
      '("hej" "HEJ" "hopp" "HOPP")
      (list-transduce (tdelete-duplicates string=?)
                      rcons
                      (list "hej" "HEJ" "hopp" "HOPP" "hej")))

(test "tflatten"
      '(1 2 3 4 5 6 7 8 9)
      (list-transduce tflatten rcons '((1 2) 3 (4 (5 6) 7) 8 (9))))

(test "tpartition"
      '((1 1 1 1) (2 2 2 2) (3 3 3) (4 4 4 4))
      (list-transduce (tpartition even?)
                      rcons
                      '(1 1 1 1 2 2 2 2 3 3 3 4 4 4 4)))

(test "tsegment"
      '((0 1) (2 3) (4))
      (vector-transduce (tsegment 2) rcons numeric-vec))

(test "tadd-between"
      '(0 and 1 and 2 and 3 and 4)
      (list-transduce (tadd-between 'and) rcons numeric-list))

(test "tenumerate"
      '((-1 . 0) (0 . 1) (1 . 2) (2 . 3) (3 . 4))
      (list-transduce (tenumerate (- 1)) rcons numeric-list))


;; "x-transduce"

(test "list-transduce"
      15 (list-transduce (tmap add1) + numeric-list))

(test "list-transduce with identity"
      15 (list-transduce (tmap add1) + 0 numeric-list))

(test "vector-transduce"
      15 (vector-transduce (tmap add1) + numeric-vec))

(test "vector-transduce with identity"
      15
      (vector-transduce (tmap add1) + 0 numeric-vec))

(test "port-transduce" #t (port-transduce-test))
(test "port-transduce with identity" #t (port-transduce-with-identity-test))

;; Converts each numeric char to it's corresponding integer  and sums them.
(test "string-transduce"
      15
      (string-transduce (tmap (lambda (x) (- (char->integer x) 47))) + "01234"))

(test "string-transduce with identity"
      15
      (string-transduce  (tmap (lambda (x) (- (char->integer x) 47)))
                         +
                         0
                         "01234"))

(test "generator-transduce"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons read))))

(test "generator-transduce with identity"
      '(1 2 3)
      (with-input-from-string "1 2 3"
        (lambda () (generator-transduce (tmap (lambda (x) x)) rcons '() read))))

(test "bytevector-u8-transduce"
      15 (bytevector-u8-transduce (tmap add1) + bv))

(test "bytevector-u8-transduce with identity"
      15 (bytevector-u8-transduce (tmap add1) + 0 bv))

;; ----------------------------------------------------------------------
;;  SRFI 173 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 173 - Hooks")

(require "srfi-173")

(test "make-hook type" (hook? (make-hook 2)) #t)

(define hook (make-hook 2))
(define hook-sum-var 0)
(define hook-prod-var 1)
(define (hook-prod x y)
  (set! hook-prod-var (* x y)))

(hook-add! hook (lambda (x y) (set! hook-sum-var (+ x y))))
(hook-add! hook hook-prod)

(test "add-hook!+run-hook" '(8 15)
      (begin
        (hook-run hook 3 5)
        (list hook-sum-var hook-prod-var)))

(define list-from-hook (hook->list hook))

(test "hook->list" #t (list? list-from-hook))
(test "hook->list length" 2 (length list-from-hook))
(test "hook->list element types" #f (member #f (map procedure? list-from-hook)))

(hook-delete! hook hook-prod)
(set! list-from-hook (hook->list hook))
(test "hook-delete!" #f (member hook-prod (hook->list hook)))
(test "hook->list length after delete 1 proc" 1 (length list-from-hook))

(hook-reset! hook)
(set! list-from-hook (hook->list hook))
(test "hook-reset!" 0 (length list-from-hook))

;; these three will be changed by the hook:
(define hook-arith-var 0)
(define hook-geom-var 0)
(define hook-harmo-var 0)
;; define the following two as zero. the procs that changed their values
;; were removed, so they should NOT be altered.
(set! hook-sum-var 0)
(set! hook-prod-var 1)

;; three procedures:
(define (arith-mean x y) (set! hook-arith-var (/ (+ x y) 2)))
(define (geom-mean x y)  (set! hook-geom-var  (sqrt (* x y))))
(define (harmo-mean x y) (set! hook-harmo-var (/ 1 (+ x y))))

(list->hook! hook (list arith-mean geom-mean harmo-mean))
(test "list->hook! - length of list" 3 (length (hook->list hook)))
(test "add-hook!+run-hook after list->hook"  (list 4 (sqrt 15) 1/8 0 1)
      (begin
        (hook-run hook 3 5)
        (list hook-arith-var
              hook-geom-var
              hook-harmo-var
              hook-sum-var
              hook-prod-var)))

;; ----------------------------------------------------------------------
;;  SRFI 174 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 174 - POSIX Timespecs")

(require "srfi-174")

(define ts1 (timespec 1 2))
(define ts2 (timespec 1 2))
(define ts3 (timespec 1 3))
(define ts4 (timespec 2 2))
(define ts-neg1 (timespec -1 2))
(define ts-neg2 (timespec -1 5))
(define ts-neg3 (timespec -2 0))


(test "timespec?" #t (timespec? ts1))
(test "not timespec?" #t (not (timespec? #f)))
(test "seconds" 1 (timespec-seconds ts1))
(test "nanos" 2 (timespec-nanoseconds ts1))
(test "equal" #t (timespec=? ts1 ts2))
(test "less nanos" #t (timespec<? ts1 ts3))
(test "less seconds" #t (timespec<? ts1 ts4))
(test "less -nanos" #t (timespec<? ts-neg2 ts-neg1))
(test "less -seconds" #t (timespec<? ts-neg3 ts-neg2))
(test "positive hash" #t (positive? (timespec-hash ts-neg1)))
(test "to inexact" #i1.1 (timespec->inexact (timespec 1 #e1e8)))
(let ((t (timespec 1 1))
      (u (inexact->timespec #i1.000000001)))
  (test "from inexact" t u))

;; ----------------------------------------------------------------------
;;  SRFI 180 ...
;;
;; The tests here are a small part of the tests from the sample
;; implementation.
;;
;; Other tests (only for json-read and json-write) are also available
;; in the file "./test-json.stk".
;; ----------------------------------------------------------------------
(test-subsection "SRFI 180 - JSON")

(require "srfi-180")

(test "json-generator.1"
      '(42)
      (call-with-input-string "42 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-generator.2"
      '(array-start 42 array-end)
      (call-with-input-string "[42] 101 1337"
                              (lambda (port) (generator->list (json-generator port)))))
(test "json-error"
      #t
      (with-handler (lambda (e) (json-error? e))
                    (call-with-input-string "{" json-read)))



;; ----------------------------------------------------------------------
;;  SRFI 190 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 190 - Coroutine Generators")

(require "srfi-190")

(let ()
  (define g1 (coroutine-generator
           (do ((i 0 (+ i 1)))
               ((<= 5 i))
             (yield i))))

  (define g2 (let ((yield-square (lambda (yield i) (yield (* i i)))))
               (coroutine-generator
                (do ((i 0 (+ i 1)))
                    ((<= 5 i))
                  (yield-square yield i)))))

  (define-coroutine-generator (g3 n)
    (do ((i 0 (+ i 1)))
        ((<= n i))
      (yield i)))

  (test "Coroutine generator.1" '(0 1 2 3 4)
        (generator->list g1))
  (test "Coroutine generator.2" '(0 1 4 9 16)
        (generator->list g2))
  (test "Coroutine generator.3" '(0 1 2 3 4 5 6)
        (generator->list (g3 7))))

;; ----------------------------------------------------------------------
;;  SRFI 62 ...
;; ----------------------------------------------------------------------
;; Tests have been moved here because test 62.5 breaks Emacs fontification

(test-subsection "SRFI 62 - S-expression comments")

(test "srfi-62.1" 5 (+ 1 #;(* 2 3) 4))
(test "srfi-62.2" '(x z) (list 'x #;'y 'z))
(test "srfi-62.3" 12 (* 3 4 #;(+ 1 2)))
(test "srfi-62.4" 16 (#;sqrt abs -16))

(test "srfi-62.5" '(a e) (list 'a #;(list 'b #;c 'd) 'e))
(test "srfi-62.6" '(a . c) '(a . #;b c))
(test "srfi-62.7" '(a . b) '(a . b #;c))


;; ----------------------------------------------------------------------
(test-section-end)
