;;;;                                                    -*- coding: utf-8 -*-
;;;;
;;;; test-r7rs.stk      -- Testing R7RS constructs/primitives
;;;;
;;;; Copyright Â© 2011 Erick Gallesio - Polytech'Nice-Sophia <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 17-Apr-2011 20:58 (eg)
;;;; Last file update:  1-Aug-2018 18:29 (eg)
;;;;

(require "test")

(test-section "R7RS")


;;------------------------------------------------------------------
(test-subsection "Control features")

(test "string-map 1"  "abdegh"  (string-map char-downcase "AbdEgH"))
(test "string-map 2"  "IBM"     (string-map (lambda (c)
                                              (integer->char (+ 1 (char->integer c))))
                                            "HAL"))
(test "string-map 3"  "StUdLyCaPs"  (string-map (lambda (c k)
                                                  (if (eqv? k #\u)
                                                      (char-upcase c)
                                                      (char-downcase c)))
                                                "studlycaps"
                                                "ululululul"))

;; **********
(test "vector-map 1"
      #(b e h)
      (vector-map cadr '#((a b) (d e) (g h))))

(test "vector-map 2" #(1 4 27 256 3125)
      (vector-map (lambda (n) (expt n n))
                  '#(1 2 3 4 5)))

(test "vector-map 3" #(5 7 9)
      (vector-map + '#(1 2 3) '#(4 5 6)))

(test "vector-map 4"  #(1 2)
      (let ((count 0))
        (vector-map (lambda (ignored)
                      (set! count (+ count 1))
                      count)
                    '#(a b))))

;; **********
(test "string-for-each"
      '(101 100 99 98 97)
      (let ((v (list)))
        (string-for-each (lambda (c) (set! v (cons (char->integer c) v)))
                         "abcde")
         v))

;; **********
(test "vector-for-each"
      '#(0 1 4 9 16)
      (let ((v (make-vector 5)))
        (vector-for-each (lambda (i) (vector-set! v i (* i i)))
                         '#(0 1 2 3 4))
        v))

;;------------------------------------------------------------------
(test-subsection "Symbols")

(test "symbol=?.1" #t (symbol=? 'a 'a (string->symbol "a")))
(test "symbol=?.2" #t (symbol=? '|A| (string->symbol "A")))
(test "symbol=?.3" #f (symbol=? '|A| (string->symbol "a")))
(test "symbol=?.4" #f (symbol=? 'a 'a "a"))


;;------------------------------------------------------------------
(test-subsection "Strings")

(test "Extended string=?.1" #t (string=? "a"))
(test "Extended string=?.2" #t (string=? "a" "a" "a" "a"))
(test "Extended string=?.3" #f (string=? "a" "a" "A" "a"))

(test "Extended string-ci=?.1" #t (string-ci=? "a"))
(test "Extended string-ci=?.2" #t (string-ci=? "a" "a" "a" "a"))
(test "Extended string-ci=?.3" #t (string-ci=? "a" "a" "A" "a"))
(test "Extended string-ci=?.4" #f (string-ci=? "a" "a" "A" "b"))

(test "Extended string<?.1" #t (string<? "a"))
(test "Extended string<?.2" #t (string<? "a" "b" "c" "d"))
(test "Extended string<?.3" #f (string<? "a" "B" "c" "D"))
(test "Extended string<?.4" #f (string<? "a" "a" "A" "b"))

(test "Extended string-ci<?.1" #t (string-ci<? "a"))
(test "Extended string-ci<?.2" #t (string-ci<? "a" "b" "c" "d"))
(test "Extended string-ci<?.3" #t (string-ci<? "a" "B" "c" "D"))
(test "Extended string-ci<?.4" #f (string-ci<? "a" "a" "A" "b"))

(let ((str "abcdef"))
  (test "Extended string->list.1" '(#\a #\b #\c #\d #\e #\f) (string->list str))
  (test "Extended string->list.2" '(#\c #\d #\e #\f) (string->list str 2))
  (test "Extended string->list.3" '(#\c #\d #\e) (string->list str 2 5))
  (test "Extended string->list.4" *test-failed* (string->list str 2 100))

  (test "Extended string-copy.1" "abcdef" (string-copy str))
  (test "Extended string-copy.2" "cdef" (string-copy str 2))
  (test "Extended string-copy.3" "cde" (string-copy str 2 5))
  (test "Extended string-copy.4" *test-failed* (string-copy str 2 100)))


(test "string-copy!.1"
      "abc12f"
      (let ((s (string-copy "abcdef"))) (string-copy! s 3 "12") s))
(test "string-copy!.2"
      *test-failed*
      (let ((s (string-copy "abcdef"))) (string-copy! s 5 "12") s))
(test "string-copy!.3"
      "a23def"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 1) s))
(test "string-copy!.4"
      "a23def"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 1) s))
(test "string-copy!.5"
      "a3cdef"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 2) s))
(test "string-copy!.6"
      "abcdef"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 3) s))
(test "string-copy!.7"
      "a12def"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 2) s))
(test "string-copy!.8"
      "a123ef"
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 3) s))
(test "string-copy!.9"
      *test-failed*
      (let ((s (string-copy "abcdef"))) (string-copy! s 1 "123" 0 4) s))

(test "string-copy! overlap.1"
      "ababcfg"
      (let ((s (string-copy "abcdefg")))   (string-copy! s 2 s 0 3) s))
(test "string-copy! overlap.2"
      "efcdefg"
      (let ((s (string-copy "abcdefg")))   (string-copy! s 0 s 4 6) s))

(test "string-fill!.1"
      "abcde"
      (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 2) x))
(test "string-fill!.2"
      "ab11e"
      (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 4) x))
(test "string-fill!.2"
      "ab111"
      (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 5) x))
(test "string-fill!.3"
      *test-failed*
      (let ((x (string-copy "abcde"))) (string-fill! x #\1 2 6) x))

;;------------------------------------------------------------------
(test-subsection "vector")

(test "Extended vector->list.1" '(1 2 3)        (vector->list '#(1 2 3)))
(test "Extended vector->list.2" '(2 3)          (vector->list '#(1 2 3) 1))
(test "Extended vector->list.3" '(1 2)          (vector->list '#(1 2 3) 0 2))
(test "Extended vector->list.4" *test-failed*   (vector->list '#(1 2 3) 0 7))

(let ((v #(a b c d e f)))
  (test "Extended vector-copy.1" #(a b c d e f) (vector-copy v))
  (test "Extended vector-copy.2" #(c d e f)     (vector-copy v 2))
  (test "Extended vector-copy.3" #(c d e)       (vector-copy v 2 5))
  (test "Extended vector-copy.4" *test-failed*  (vector-copy v 2 100)))

(let ((vect #(a b c d e f)))
  (test "vector-copy!.1"
        #(a b c 1 2 f)
        (let ((v (vector-copy vect))) (vector-copy! v 3 #(1 2)) v))
  (test "vector-copy!.2"
        *test-failed*
        (let ((v (vector-copy vect))) (vector-copy! v 5 #(1 2)) v))
  (test "vector-copy!.3"
        #(a 2 3 d e f)
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3)  1) v))
  (test "vector-copy!.4"
        #(a 2 3 d e f)
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3) 1) v))
  (test "vector-copy!.5"
        #(a 3 c d e f)
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3) 2) v))
  (test "vector-copy!.6"
        #(a b c d e f)
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3) 3) v))
  (test "vector-copy!.7"
        #(a 1 2 d e f)
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3) 0 2) v))
  (test "vector-copy!.8"
        #(a 1 2 3 e f)
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3) 0 3) v))
  (test "vector-copy!.9"
        *test-failed*
        (let ((v (vector-copy vect))) (vector-copy! v 1 #(1 2 3) 0 4) v))

  (test "vector-copy!overlap.1"
        #(a b a b c f g)
        (let ((v (vector 'a 'b 'c 'd 'e 'f 'g)))
          (vector-copy! v 2 v 0 3) v))
  (test "vector-copy!overlap.2"
        #(e f c d e f g)
        (let ((v (vector 'a 'b 'c 'd 'e 'f 'g)))
          (vector-copy! v 0 v 4 6) v)))


(test "vector->string.1" "" (vector->string #()))
(test "vector->string.2" "123" (vector->string #(#\1 #\2 #\3)))
(test "vector->string.3" "23" (vector->string #(#\1 #\2 #\3) 1))
(test "vector->string.4" "2" (vector->string #(#\1 #\2 #\3) 1 2))
(test "string->vector.1" #() (string->vector ""))
(test "string->vector.2" #(#\A #\B #\C) (string->vector "ABC"))
(test "string->vector.3" #(#\B #\C) (string->vector "ABC" 1))
(test "string->vector.4" #(#\B) (string->vector "ABC" 1 2))

(test "chibi vector-append.1" #() (vector-append #()))
(test "chibi vector-append.2" #() (vector-append #() #()))
(test "chibi vector-append.3" #(a b c) (vector-append #() #(a b c)))
(test "chibi vector-append.4" #(a b c) (vector-append #(a b c) #()))
(test "chibi vector-append.5" #(a b c d e) (vector-append #(a b c) #(d e)))
(test "chibi vector-append.6" #(a b c d e f) (vector-append #(a b c) #(d e) #(f)))


(test "chibi vector-fill!.1" #(1 2 smash smash 5)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'smash 2 4) vec))
(test "chibi vector-fill!.2" #(x x x x x)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x) vec))
(test "chibi vector-fill!.3" #(1 2 x x x)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2) vec))
(test "chibi vector-fill!.4" #(1 2 x 4 5)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 3) vec))
(test "vector-fill!.5" #(1 2 x x x)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 5) vec))
(test "vector-fill!.6" *test-failed*
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 6) vec))
(test "vector-fill!.7" #(1 2 3 4 5)
    (let ((vec (vector 1 2 3 4 5))) (vector-fill! vec 'x 2 2) vec))

;;------------------------------------------------------------------
(test-subsection "Bytevectors")

(test "bytevector?.1" #t (bytevector? #u8()))
(test "bytevector?.2" #t (bytevector? #u8(0 1 2)))
(test "bytevector?.3" #f (bytevector? #()))
(test "bytevector?.4" #f (bytevector? #(0 1 2)))
(test "bytevector?.5" #f (bytevector? '()))
(test "bytevector?.6" #t (bytevector? (make-bytevector 0)))

(test "make-bytevector.1" #u8(0 0 0) (make-bytevector 3))
(test "make-bytevector.2" #u8(1 1 1) (make-bytevector 3 1))
(test "make-bytevector.3" *test-failed* (make-bytevector 3 2000))
(test "make-bytevector.3" *test-failed* (make-bytevector 3 #f))

(test "bytevector.1" #u8(1 2 3) (bytevector 1 2 3))
(test "bytevector.2" #u8() (bytevector))
(test "bytevector.3" *test-failed* (bytevector 1 2 300))
(test "bytevector.4" *test-failed* (bytevector 1 2 -1))
(test "bytevector.5" *test-failed* (bytevector 1 2 'a))

(test "bytevector-length.1" 5   (bytevector-length (bytevector 1 2 3 4 5)))
(test "bytevector-length.2" 0   (bytevector-length (make-bytevector 0)))
(test "bytevector-length.3" 100 (bytevector-length (make-bytevector 100)))
(test "bytevector-length.4" 100 (bytevector-length (make-bytevector 100 42)))

(test "bytevector-u8-ref.1" 0 (bytevector-u8-ref (bytevector 0 1 2) 0))
(test "bytevector-u8-ref.2" 1 (bytevector-u8-ref (bytevector 0 1 2) 1))
(test "bytevector-u8-ref.3" 2 (bytevector-u8-ref (bytevector 0 1 2) 2))
(test "bytevector-u8-ref.4" *test-failed* (bytevector-u8-ref (bytevector 0 1 2) 3))
(test "bytevector-u8-ref.5" *test-failed* (bytevector-u8-ref (vector 0 1 2) 0))

(test "bytevector-u8-set!.1" #u8(1 3 3 4)
      (let ((bv (bytevector 1 2 3 4)))  (bytevector-u8-set! bv 1 3) bv))
(test "bytevector-u8-set!.2" #u8(100 2 3 4)
      (let ((bv (bytevector 1 2 3 4)))  (bytevector-u8-set! bv 0 100) bv))
(test "bytevector-u8-set!.3" *test-failed*
      (let ((bv (bytevector)))  (bytevector-u8-set! bv 0 100) bv))
(test "bytevector-u8-set!.4" *test-failed*
      (let ((bv #u8(1 2 3)))  (bytevector-u8-set! bv 0 100) bv))

(test "bytevector-copy.1" #u8() (bytevector-copy #u8()))
(test "bytevector-copy.2" #u8(0 1 2 3 4 5) (bytevector-copy #u8(0 1 2 3 4 5)))
(test "bytevector-copy.3" #u8(2 3 4 5) (bytevector-copy #u8(0 1 2 3 4 5) 2))
(test "bytevector-copy.4" #u8(2 3) (bytevector-copy #u8(0 1 2 3 4 5) 2 4))

(let ((vect #u8(10 20 30 40 50 60)))
  (test "byvector-copy!.1"
        #u8(10 20 30 1 2 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 3 #u8(1 2)) v))
  (test "bytevector-copy!.2"
        *test-failed*
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 5 #u8(1 2)) v))
  (test "bytevector-copy!.3"
        #u8(10 2 3 40 50 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3)  1) v))
  (test "bytevector-copy!.4"
        #u8(10 2 3 40 50 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3) 1) v))
  (test "bytevector-copy!.5"
        #u8(10 3 30 40 50 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3) 2) v))
  (test "bytevector-copy!.6"
        #u8(10 20 30 40 50 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3) 3) v))
  (test "bytevector-copy!.7"
        #u8(10 1 2 40 50 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3) 0 2) v))
  (test "bytevector-copy!.8"
        #u8(10 1 2 3 50 60)
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3) 0 3) v))
  (test "bytevector-copy!.9"
        *test-failed*
        (let ((v (bytevector-copy vect))) (bytevector-copy! v 1 #u8(1 2 3) 0 4) v))

  (test "bytevector-copy!overlap.1"
        #u8(1 2 1 2 3 6 7 8 9)
        (let ((v (bytevector 01 2 3 4 5 6 7 8 9)))
          (bytevector-copy! v 2 v 0 3) v))
  (test "bytevector-copy!overlap.2"
        #u8(4 5 2 3 4 5 6 7 8 9)
        (let ((v (bytevector 0 1 2 3 4 5 6 7 8 9)))
          (bytevector-copy! v 0 v 4 6) v)))


(test "byte-vector-append.1" #u8() (bytevector-append))
(test "byte-vector-append.2" #u8() (bytevector-append #u8()))
(test "byte-vector-append.3" #u8() (bytevector-append #u8() #u8()))
(test "byte-vector-append.4" #u8(0 1 2 3) (bytevector-append #u8() #u8(0 1 2 3)))
(test "byte-vector-append.5" #u8(0 1 2 3) (bytevector-append #u8(0 1 2 3) #u8()))
(test "byte-vector-append.6" #u8(0 1 2 3) (bytevector-append #u8(0 1) #u8(2 3)))
(test "byte-vector-append.7" #u8(0 1 2 3) (bytevector-append #u8(0) #u8(1)
                                                             #u8() #u8(2) #u8(3)))

(test "chibi utf8->string.1" "ABC" (utf8->string #u8(#x41 #x42 #x43)))
(test "chibi utf8->string.2" "ABC" (utf8->string #u8(0 #x41 #x42 #x43) 1))
(test "chibi utf8->string.3""ABC" (utf8->string #u8(0 #x41  #x42 #x43 0) 1 4))
(test "chibi utf8->string.4" "λ" (utf8->string #u8(0 #xCE #xBB 0) 1 3))
(test "utf8->string.5" *test-failed*  (utf8->string #u8(0 #xCE)))

(test "chibi string->utf8.1" #u8(#x41 #x42 #x43) (string->utf8 "ABC"))
(test "chibi string->utf8.2" #u8(#x42 #x43) (string->utf8 "ABC" 1))
(test "chibi string->utf8.3" #u8(#x42) (string->utf8 "ABC" 1 2))
(test "chibi string->utf8.4" #u8(#xCE #xBB) (string->utf8 "λ"))

;;------------------------------------------------------------------
(test-subsection "Lists and Pairs")

(test "member with 3d parameter.1"
      '("b" "c")
      (member "B" '("a" "b" "c") string-ci=?))

(test "member with 3d parameter.2"
      '(2.0 3.0)
      (member 1.99 '(1.0 2.0 3.0) (lambda (x y) (< (abs (- x y)) 0.1))))

(test "assoc with 3d parameter.1"
      '(2 4)
      (assoc 2.0 '((1 1) (2 4) (3 9)) =))

(test "assoc with 3d parameter.2"
      '("b" 4)
      (assoc "B" '(("a" 1) ("b" 4) ("c" 9)) string-ci=?))

(test "list-set!.1"
      '("foo" 2 3)
      (let ((l (list 1 2 3)))
        (list-set! l 0 "foo")
        l))

(test "make-list.1"
      '(#void #void #void)
      (make-list 3))

(test "make-list.2"
      '(42 42 42 42)
      (make-list 4 42))


;;------------------------------------------------------------------
(test-subsection "Input and Output")

(test "call-with-port"
      '(123 . #t)
      (let* ((p (open-input-string "123 456"))
             (v (call-with-port p read)))
        (cons v (port-closed? p))))

(let ((p (open-input-string "ABCDE")))
  (test "read-string.1" "ABCD" (read-string 4 p))
  (test "read-string.2" "E"    (read-string 4 p))
  (test "read-string.3" #eof   (read-string 4 p)))


(test-section-end)
