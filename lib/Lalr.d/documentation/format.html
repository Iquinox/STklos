<HTML><HEAD><LINK REL="StyleSheet" HREF="doc.css" TYPE="text/css"/><TITLE>A portable and efficient LALR(1) parser generator for Scheme / Parser syntax</TITLE></HEAD><BODY><DIV ID="header"><H1>A portable and efficient LALR(1) parser generator for Scheme</H1></DIV><DIV ID="menu"><h3>Content</h3><p><div><a href="index.html">Description</a></div><div><a href="distrib.html">Distribution</a></div><div><a href="port.html">Portability</a></div><div><a href="def.html">Defining a parser</a></div><div>&gt; Syntax &lt;</div></p></DIV><DIV ID="body"><h2>The grammar format</h2><p>
The grammar is specified by first giving the list of terminals and the
list of non-terminal definitions. Each non-terminal definition
is a list where the first element is the non-terminal and the other
elements are the right-hand sides (lists of grammar symbols). In
addition to this, each rhs can be followed by a semantic action.
</p><p>
For example, consider the following (yacc) grammar for a very simple
expression language:
<pre class="fragment">
  e : e '+' t
    | e '-' t
    | t
    ;
  t : t '*' f
    : t '/' f
    | f
    ;
  f : ID
    ;
</pre></p><p>
The same grammar, written for the scheme parser generator, would look
like this (with semantic actions)
<pre class="fragment">
(define expr-parser
  (lalr-parser
   ; Terminal symbols
   (ID + - * /)
   ; Productions
   (e (e + t)    : (+ $1 $3)
      (e - t)    : (- $1 $3)
      (t)        : $1)
   (t (t * f)    : (* $1 $3)
      (t / f)    : (/ $1 $3)
      (f)        : $1)
   (f (ID)       : $1)))</pre></p><p>In semantic actions, the symbol <code>$n</code> refers to the synthesized
attribute value of the nth symbol in the production. The value
associated with the non-terminal on the left is the result of
evaluating the semantic action (it defaults to <code>#f</code>).
</p><h3>Operator precedence and associativity</h3><p>
The above grammar implicitly handles operator precedences. It is also
possible to explicitly assign precedences and associativity to
terminal symbols and productions <i>à la</i> Yacc. Here is a modified
(and augmented) version of the grammar:
<pre class="fragment">
(define expr-parser
 (lalr-parser
  ; Terminal symbols
  (ID
   (left: + -)
   (left: * /)
   (nonassoc: uminus))
  (e (e + e)              : (+ $1 $3)
     (e - e)              : (- $1 $3)
     (e * e)              : (* $1 $3)
     (e / e)              : (/ $1 $3)
     (- e (prec: uminus)) : (- $2)
     (ID)                 : $1)))
</pre></p><p>
The <code>left:</code> directive is used to specify a set of
left-associative operators of the same precedence level, the
<code>right:</code> directive for right-associative operators, and
<code>nonassoc:</code> for operators that are not associative. Note
the use of the (apparently) useless terminal <code>uminus.</code> It
is only defined in order to assign to the penultimate rule a
precedence level higher than that of <code>*</code> and
<code>/.</code> The <code>prec:</code> directive can only appear as
the last element of a rule. Finally, note that precedence levels are
incremented from left to right, i.e. the precedence level of
<code>+</code> and <code>-</code> is less than the precedence level of
<code>*</code> and <code>/</code> since the formers appear first in
the list of terminal symbols (token definitions).
</p><h3>Options</h3><p>
The following options are available.
</p><ul><li> (<code>output:</code><i>name</i><i>filename</i>) - copies the parser to the given
    file. The parser is given the name <i>name</i>. </li><li> (<code>out-tables:</code><i>filename</i>) - outputs the parsing tables in
    <i>filename</i> in a more readable format </li><li> (<code>expect:</code><i>n</i>) - don't warn about conflicts if there are
     <i>n</i> or less conflicts.</li></ul><h3>Error recovery</h3><p><code>lalr-scm</code> implements a very simple error recovery
strategy. A production can be of the form
</p><pre class="fragment">
   (rulename
      ...
      (error TERMINAL) : action-code
</pre><p>
(There can be several such productions for a single rulename.) This
will cause the parser to skip all the tokens produced by the lexer
that are different than the given TERMINAL. For a C-like language, one
can synchronize on semicolons and closing curly brackets by writing error
rules like these:
</p><pre class="fragment">
   (stmt
      (expression SEMICOLON) : ...
      (LBRACKET stmt RBRACKET) : ...
      (error SEMICOLON)
      (error RBRACKET))
</pre><h3>A final note on conflict resolution</h3><p>
Conflicts in the grammar are handled in a conventional way.
In the absence of precedence directives,
Shift/Reduce conflicts are resolved by shifting, and Reduce/Reduce
conflicts are resolved by choosing the rule listed first in the
grammar definition.
</p></DIV><DIV ID="footer"><I>Dominique Boucher </I>(dominique DOT boucher AT nuecho DOT com)<BR/>Dernière modification: Mon Oct 25 11:22:29 EDT 2004</DIV></BODY></HTML>