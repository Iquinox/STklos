;;;;
;;;; event.stk					-- GTK Events Management
;;;; 
;;;; Copyright © 2001-2002 Erick Gallesio - I3S-CNRS/ESSI <eg@unice.fr>
;;;; 
;;;; 
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;; 
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
;;;; USA.
;;;; 
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 31-May-2001 18:36 (eg)
;;;; Last file update:  8-Apr-2002 13:06 (eg)
;;;;


;;; ======================================================================
;;;
;;; 		< g t k - e v e n t - h a n d l e r >   c l a s s 
;;;
;;; ======================================================================

(define-class <gtk-event-handler> ()
  ((widgets	:init-form '())	;; list of widgets using this event handler 
   (destroy 	:init-form #f)
   (map 	:init-form #f)
   (unmap 	:init-form #f)
   (press 	:init-form #f)
   (release 	:init-form #f)
;//(click 	:init-form #f)
   (enter 	:init-form #f)
   (leave 	:init-form #f)
   (motion 	:init-form #f)
   (key 	:init-form #f)
   (focus-in 	:init-form #f)
   (focus-out 	:init-form #f)
   (configure 	:init-form #f)
   (expand	:init-form #f)
   (collapse	:init-form #f)))


;;
;; INSTALL-CALLBACK!
;;

;; for each GTklos event:
;;     (<slot-name> <c-name> <boolean #t if a GDK event and #f if a GTK signal>)

(define %event-names
  `((destroy		"destroy"		#t)
    (map		"map-event"		#t)
    (unmap		"unmap-event"		#t)
    (press		"button-press-event"	#t |GDK_BUTTON_PRESS_MASK|)
    (release		"button-release-event"	#t |GDK_BUTTON_RELEASE_MASK|)
    (enter		"enter-notify-event"	#t |GDK_ENTER_NOTIFY_MASK|)
    (leave		"leave-notify-event"	#t |GDK_LEAVE_NOTIFY_MASK|)
    (motion		"motion-notify-event"	#t |GDK_POINTER_MOTION_MASK|
						   |GDK_POINTER_MOTION_HINT_MASK|)
    (key		"key-press-event"	#t |GDK_KEY_PRESS_MASK|)
    (focus-in		"focus-in-event"	#t |GDK_FOCUS_CHANGE_MASK|)
    (focus-out		"focus-out-event"	#t |GDK_FOCUS_CHANGE_MASK|)
    (configure		"configure-event"	#t |GDK_PROPERTY_CHANGE_MASK|)

    (expand		"expand"		#f)
    (collapse		"collapse"		#f)

    ;; Virtual event names 
    (stklos:changed-sel	  "selection_changed"	#f)
    (stklos:command	  "clicked"		#f)
    (stklos:activate-menu "activate"		#f)
    (stklos:value-changed "value-changed"	#f)))



(define (install-callback! widget event-name proc)
  (define (do-install w proc C-name has_event? . masks)
    (let ((M (if (null? masks)
		 0
		 (apply bit-or (map (lambda (x)
				      (symbol-value x (find-module 'gtk)))
				    masks)))))
      (%gtk-set-callback! w proc C-name has_event? M)))
  ;;
  ;; Code of install-event-handler! starts here
  ;;
  (let ((info (assoc event-name %event-names)))
    (unless info
      (panic "cannot install event handler for ~S event name on ~S"
	     event-name (%widget->object widget)))

    (apply do-install widget proc (cdr info))))

;;
;; DELETE-CALLBACK!
;;
(define (delete-callback! widget event-name old-proc)
  (let ((info (assoc event-name %event-names)))
    (unless info
      (panic "cannot delete event handler for ~S event name on ~S"
	     event-name (%widget->object widget)))
    (%gtk-reset-callback! widget
			  old-proc
			  (cadr info)
			  (caddr info))))


;;; ======================================================================
;;;
;;;  	          < e v e n t - h a n d l e r >   c l a s s
;;;
;;;
;;; This is the class that user application should use. It provides a high
;;; level access to the event a widget can react to.
;;;
;;; ======================================================================


;;
;; Utilities
;;
(define (%make-event-reader slot-name)
  (lambda (o) (slot-ref (slot-ref o '%gtk-event) slot-name)))

(define (%make-event-writer slot-name)
  (lambda (o new-handler)
    (let* ((gtk-event   (slot-ref o '%gtk-event))
	   (old-handler (slot-ref gtk-event slot-name)))
      
      ;; Store new value in the associated gtk-event
      (slot-set! gtk-event slot-name new-handler)
      
      ;; Propagate the changes to all the connected widgets
      (for-each (lambda (w)
		  (let ((wid (slot-ref w 'wid)))
		    ;; Delete old callback handler from widget
		    (when old-handler
		      (delete-callback! wid slot-name old-handler))
		    
		    ;; Add this callback handler to widget
		    (when new-handler
		      (install-callback! wid slot-name new-handler))))
		(slot-ref gtk-event 'widgets)))))
		  
;;
;; Class declaration
;;
(define-class <event-handler> ()
  ((%gtk-event  :init-form 	(make <gtk-event-handler>))
   (destroy 	:init-keyword	:destroy
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'destroy)
		:slot-set!	(%make-event-writer 'destroy))
   (map 	:init-keyword 	:map
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'map)
		:slot-set!	(%make-event-writer 'map))
   (unmap 	:init-keyword 	:unmap
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'unmap)
		:slot-set!	(%make-event-writer 'unmap))
   (press 	:init-keyword 	:press
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'press)
		:slot-set!	(%make-event-writer 'press))
   (release 	:init-keyword 	:release
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'release)
		:slot-set!	(%make-event-writer 'release))
;//   (click 	:init-keyword 	:click
;//		:allocation	:virtual
;//		:slot-ref	(%make-event-reader 'click)
;//		:slot-set!	(%make-event-writer 'click))
   (enter 	:init-keyword 	:enter
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'enter)
		:slot-set!	(%make-event-writer 'enter))
   (leave 	:init-keyword 	:leave
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'leave)
		:slot-set!	(%make-event-writer 'leave))
   (motion 	:init-keyword 	:motion
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'motion)
		:slot-set!	(%make-event-writer 'motion))
   (key 	:init-keyword 	:key
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'key)
		:slot-set!	(%make-event-writer 'key))
   (focus-in 	:init-keyword 	:focus-in
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'focus-in)
		:slot-set!	(%make-event-writer 'focus-in))
   (focus-out 	:init-keyword 	:focus-out
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'focus-out)
		:slot-set!	(%make-event-writer 'focus-out))
   (configure 	:init-keyword 	:configure
		:allocation	:virtual
		:slot-ref	(%make-event-reader 'configure)
		:slot-set!	(%make-event-writer 'configure))))


;;; ======================================================================
;;;
;;; 			    connect-event-handler!
;;;
;;; ======================================================================
(define (connect-event-handler! event w)
  (let ((all-events (delete '%gtk-event (map slot-definition-name
					     (class-slots <event-handler>))))
	(gtk-event  (slot-ref event '%gtk-event))
	(wid	    (slot-ref w 'wid)))
    (for-each (lambda (name)
		;; Connect event with given name to w
		(let ((handler  (slot-ref gtk-event name)))
		  (when handler
		    ;;// (DEBUG "CONNECT ~S" name)
		    (install-callback! wid name handler))))
		  all-events)
    ;; Add this widget to the list of the event managed widgets
    (slot-set! gtk-event 'widgets
	       (cons w (delete w (slot-ref gtk-event 'widgets))))))


;;; ======================================================================
;;;
;;; 			    disconnect-event-handler!
;;;
;;; ======================================================================

(define (disconnect-event-handler! event w)
  (let ((all-events (delete '%gtk-event (map slot-definition-name
					     (class-slots <event-handler>))))
	(gtk-event  (slot-ref event '%gtk-event)))
    (for-each (lambda (name)
		;; Connect event with given name to w
		(let ((handler  (slot-ref gtk-event name)))
		  (when handler 
		    ;;// (DEBUG "DISCONNECT ~S" name)
		    (delete-callback! (slot-ref w 'wid) name handler))))
		  all-events)
    ;; Add this widget to the list of the event managed widgets
    (slot-set! gtk-event 'widgets
	       (delete w (slot-ref gtk-event 'widgets)))))


;;; ======================================================================
;;;
;;; 			    	after
;;;
;;; ======================================================================

(define (after arg1 :optional arg2)
  (letrec ((bad-proc (lambda (o) (error 'after "bad procedure ~S" arg2))))
    (cond
     ((integer? arg1) 
          (if arg2 
	      (if (procedure? arg2)
		  (%after 0 arg1 (lambda () (arg2) #f))
		  (bad-proc arg2))
	      (%after 1 arg1 (void))))
     ((eq? arg1 'idle)
     	  (if arg2
	      (if (procedure? arg2)
		  (%after 2 arg2)
		  (bad-proc arg2))
	      (error 'after "idle option needs a procedure")))
     ((eq? arg1 'cancel)
     	  (if arg2
	      (if (integer? arg2)
		  (%after 3 arg2)
		  (error 'after "bad cancel option parameter ~S" arg2))
	      (error 'after "cancel option needs an integer")))
     (else (error 'after "bad parameter ~S" arg1)))))


;;; ======================================================================
;;;
;;; 			    	timeout
;;;
;;; Loop forever until PROC returns #f. Waits INTERVAL before each iteration.
;;;
;;; ======================================================================

(define (timeout interval proc)
  (letrec ((new-proc (lambda () (when (proc) (after interval new-proc)))))
    (after interval new-proc)))

;LocalWords:  callback
