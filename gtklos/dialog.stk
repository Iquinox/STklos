;;;;
;;;; dialog.stk					-- GTKlos Dialogs
;;;; 
;;;; Copyright © 2002-2005 Erick Gallesio - I3S-CNRS/ESSI <eg@unice.fr>
;;;; 
;;;; 
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;; 
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
;;;; USA.
;;;; 
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 15-Feb-2002 16:39 (eg)
;;;; Last file update: 16-Aug-2005 00:09 (eg)
;;;;

;======================================================================
;
;			 < g t k - d i a l o g >
;
;====================================================================== 
(define-class <gtk-dialog> (<window>)
  ((%lock  :initform #f)))

(define-method wait-dialog ((self <gtk-dialog>))
  (slot-set! self '%lock #f)
  (let Loop ()
    (unless (slot-ref self '%lock)
      ;; wait 0.1 sec
      (after 100)
      ;; and retest
      (Loop)))
  (slot-ref self '%lock))

;======================================================================
;
;		     m a k e - s i m p l e - d i a l o g
;
;====================================================================== 

(define (make-simple-dialog :key (title "GTklos") (text #f)
			         (image #f) (texts '()) (modal #t))
  (let* ((win  (make <gtk-dialog> :modal modal :title title))
	 (lay  (layout win))
	 (sep  (make <separator>))
	 (hbox (make <box> :orientation 'horizontal :padding 10
		     :expand #t :fill #t)))
    
    (container-add! lay hbox :padding 3  :end #t)
    (container-add! lay sep  :padding 10 :end #t)

    ;; If there is a text or an image, create a box and place them in it
    (when (or text image)
      (let* ((box (make <box> :orientation 'horizontal :padding 15
			:expand #t :fill #t :parent win))
	     (img (and image (make <image> :file image :parent box)))
	     (txt (and text  (make <label> :text text :parent box :justify 'left))))
	txt))
    
    ;; Create the buttons
    (for-each (lambda (x)
		(receive (txt val)
			 (if (pair? x)
			     (values (car x) (cadr x))
			     (values x x))
		   (make <button> :text txt :parent hbox
			 :command (lambda (_) (slot-set! win '%lock val)))))
	      texts)

    ;; Wait until there is a button chosen
    (when modal
      (let ((val (wait-dialog win)))
	(destroy win)
	val))))


;======================================================================
;
;			 < o k - c a n c e l - d i a l o g >
;
;====================================================================== 
(define-class <ok-cancel-dialog> (<gtk-dialog>)
  ())

(define-method initialize ((self <ok-cancel-dialog>) initargs)
  (next-method)
  (let ((lay  (layout self))
	(sep  (make <separator>))
	(hbox (make <box> :orientation 'horizontal :padding 10
		    :expand #t :fill #t)))
    (container-add! lay hbox :padding 3  :end #t)
    (container-add! lay sep  :padding 10 :end #t)

    ;; Create the "OK" and "Cancel" buttons
    (make <button> :text "OK"     :parent hbox
	  :command (lambda (_) (slot-set! self '%lock 'ok)))
    (make <button> :text "Cancel" :parent hbox
	  :command (lambda (_) (slot-set! self '%lock 'cancel)))))


