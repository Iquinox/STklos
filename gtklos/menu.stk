;;;;
;;;; menu.stk			-- GTK+ Menu Management
;;;; 
;;;; Copyright © 2000-2002 Erick Gallesio - I3S-CNRS/ESSI <eg@unice.fr>
;;;; 
;;;; 
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;; 
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
;;;; USA.
;;;; 
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 27-Oct-2000 22:09 (eg)
;;;; Last file update:  8-Apr-2002 15:19 (eg)
;;;;


(define %fill-menu #f) 		;; forward declaration

;######################################################################
;
; 			Menu Items stuff 
;
;######################################################################
;;; Menu Items Hierarchy
;;;	<gtk-item>
;;;	   <gtk-menu-item>
;;;		<menu-item>
;;;		    <menu-check-item>
;;			<menu-radio-item>
;;;		<menu-separator-item>
;;;	        <menu-tear-off-item>

(define-class <gtk-item> (<gtk-container>)
  ())
		
(define-class <gtk-menu-item> (<gtk-item>)
  ((command	:accessor	command
		:init-keyword   :command
		:init-form	#f
		:allocation	:gtk-signal
		:signal-name	"stklos:activate-menu")))
   

;======================================================================
;
;			< m e n u - i t e m >
;
;====================================================================== 
(define-class <menu-item> (<gtk-menu-item>)
  ((%label)	;; Don't touch: the associated label 
   (text	:accessor	text
		:init-keyword	:text
		:allocation	:virtual
		:slot-ref	(lambda (o)
				  (%gtk-arg-get (slot-ref o '%label) :label))
		:slot-set!	(lambda (o v) 
				  (%gtk-arg-set! (slot-ref o '%label) :label v)))
   (justify	:accessor	justify
		:init-keyword	:justify
		:allocation	:virtual
		:slot-ref	(lambda (o)
				  (%widget-plist (slot-ref o 'wid) :justify))
		:slot-set!	(lambda (o v)
				  (let* ((w (slot-ref o 'wid))
					 (v (cond 
					     ((equal? v "left") v)
					     ((equal? v "right") 
					          (%menu-item-ctrl w 2)
						  v)
					     (else (error "bad justify value ~S"
							  v)))))
				    (%widget-plist w :justify v))))))

(define-method realize-widget ((self <menu-item>) initargs)
  (let ((id (%menu-item self 0)))
    (slot-set! self 'wid id)
    (%widget-plist id :justify "left")
    (slot-set! self '%label (%widget-plist id :label))))

;======================================================================
;
;			< m e n u - c h e c k - i t e m >
;
;====================================================================== 
(define-class <menu-check-item> (<menu-item>)
  ((value	:accessor	value
		:init-keyword	:value
		:allocation	:virtual
		:slot-ref	(lambda (o)
				  (%menu-item-ctrl (slot-ref o 'wid) 0))
		:slot-set!	(lambda (o v)
				  (%menu-item-ctrl (slot-ref o 'wid) 1 v)))))

(define-method realize-widget ((self <menu-check-item>) initargs)
  (let ((id (%menu-item self 1)))
    (slot-set! self 'wid id)
    (slot-set! self '%label (%widget-plist id :label))))

;======================================================================
;
;			< m e n u - r a d i o - i t e m >
;
;====================================================================== 
(define-class <menu-radio-item> (<menu-check-item>)
  ((sibling	:getter		sibling
		:allocation	:virtual
		:slot-ref	(lambda (o)
				  (%widget-plist (slot-ref o 'wid) :sibling))
		:slot-set!	(%gtk-slot-ro 'sibling))))


(define-method realize-widget ((self <menu-radio-item>) initargs)
  (let* ((sibling (key-get initargs :sibling #f))
	 (id (%menu-item self 2 (and sibling (wid sibling)))))
    (slot-set! self 'wid id)
    (slot-set! self '%label (%widget-plist id :label))
    ;; Save sibling in widget plist
    (%widget-plist id :sibling sibling)))


;======================================================================
;
;		    < m e n u - s e p a r a t o r - i t e m >
; 
;======================================================================
(define-class <menu-separator-item> (<gtk-menu-item>)
  ())

(define-method realize-widget ((self <menu-separator-item>) initargs)
  (slot-set! self 'wid (%menu-separator self)))


;======================================================================
;
;		    < m e n u - t e a r - o f f - i t e m >
; 
;======================================================================
(define-class <menu-tear-off-item> (<gtk-menu-item>)
  ())

(define-method realize-widget ((self <menu-tear-off-item>) initargs)
  (slot-set! self 'wid (%menu-tear-off self)))


;######################################################################
;
; 			Menu containers stuff 
;
;######################################################################

(define-class <gtk-menu-shell> (<gtk-container>) 
  ())


;======================================================================
;
;			< m e n u - b a r >
;
;====================================================================== 
(define-class <menu-bar> (<gtk-menu-shell>)
  ((items	:getter		items
		:allocation	:virtual
		:init-form	'()
		:init-keyword	:items
		:slot-ref	(lambda (o)
				  (%widget-plist (slot-ref o 'wid) :items))
		:slot-set!	(%gtk-slot-init-only 'items))
   (shadow	:accessor	shadow
		:init-keyword	:shadow	
		:allocation	:gtk-arg)))

(define-method realize-widget ((self <menu-bar>) initargs)
  (slot-set! self 'wid (%menubar self)))

;;;
;;; Methods for menu-bars 
;;;
(define-method add-menu-item! ((bar <menu-bar>) (x <menu-item>))
  (%menubar-add (slot-ref bar 'wid) (slot-ref x 'wid)))



(define-method initialize ((self <menu-bar>) initargs)
  ;; Do the normal initialization
  (next-method)
  ;; If items are given, build the
  (when (slot-ref self 'items)
    (let ((justify "left"))
      (for-each
         (lambda (x)
	   (if (null? x)
	       ;; Special case to tell that next item is right justified 
	       (set! justify "right")
	       ;; Normal case
	       (let* ((title (car x))
		      (rest  (cdr x))
		      (mb    (make <menu-item> :text title :justify justify)))
		 (slot-set! mb 'justify justify)
		 (add-menu-item! self mb)
		 (%fill-menu mb title rest))))
	 (slot-ref self 'items)))))

;======================================================================
;
;			< m e n u >
;
;====================================================================== 
(define-class <menu> (<gtk-menu-shell>)
  ((title	:accessor	title
		:init-keyword	:title
		:allocation	:virtual
		:slot-ref	(lambda (o)
				  (%menu-control (slot-ref o 'wid) 1))
		:slot-set!	(lambda (o v)
				  (%menu-control (slot-ref o 'wid) 2 v)))))


(define-method realize-widget ((self <menu>) initargs)
  (slot-set! self 'wid (%menu self)))

;;;
;;; Methods for menus
;;;
(define-method add-menu-item! ((menu <menu>) (x <gtk-menu-item>))
  (%menu-control (slot-ref menu 'wid)  0 (slot-ref x 'wid)))


;======================================================================
;
; %fill-toolbar: This function is called when a menu-bar is created.
; It creates all the internal components of the menu-bar 
;
;======================================================================
(define (%fill-menu parent title items)
  (let ((menu    (make <menu> :title title))
	(sibling #f))
    (for-each (lambda (item)
		(let ((title  (car item))
		      (action (key-get (cdr item) :action void))
		      (type   (key-get (cdr item) :type   :item)))
		  (case type
		     ((:tear-off)
		         (add-menu-item! menu (make <menu-tear-off-item>)))
		     ((:separator)
		         (add-menu-item! menu (make <menu-separator-item>)))
		     ((:item)
		    	 (add-menu-item! menu (make <menu-item> :text title
						    :command action)))
		     ((:check)
		         (let ((val (key-get (cdr item) :value #f)))
			   (add-menu-item! menu (make <menu-check-item> :text title
						      :value val
						      :command action))))
		     ((:radio)
		         (let* ((first (key-get (cdr item) :first #f))
				(group (if first #f sibling))
				(val   (key-get (cdr item) :value #f))
				(w     (make <menu-radio-item> :text title
					     :sibling group :value val 
					     :command action)))
			   (set! sibling w)
			   (add-menu-item! menu w)))
		     ((:cascade)
		         (let ((new     (make <menu-item> :text title))
			       (submenu (key-get (cdr item) :menu '())))
			   (add-menu-item! menu new)
			   (%connect-menu (wid new) 
					  (wid (%fill-menu new 
							   title
							   submenu))))))))
	      items)
    (%connect-menu (wid parent) (wid menu))
    menu))
