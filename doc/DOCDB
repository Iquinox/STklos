;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Mon Dec 12 22:05:10 CET 2005


;; Source file "boolean.c"

(not :type procedure :synopsis "(not obj)" :description "Not returns |#t| if |obj| is false, and returns |#f| otherwise.\n\n@lisp\n  (not #t)         =>  #f\n  (not 3)          =>  #f\n  (not (list 3))   =>  #f\n  (not #f)         =>  #t\n  (not '())        =>  #f\n  (not (list))     =>  #f\n  (not 'nil)       =>  #f\n@end lisp" :similar ())

(boolean? :type procedure :synopsis "(boolean? obj)" :description "|Boolean?| returns |#t| if |obj| is either |#t| or |#f| and returns\n|#f| otherwise.\n@lisp\n  (boolean? #f)         =>  #t\n  (boolean? 0)          =>  #f\n  (boolean? '())        =>  #f\n@end lisp" :similar ())

(eqv? :type procedure :synopsis "(eqv? obj1 obj2)" :description "The |eqv?| procedure defines a useful equivalence relation on objects. \nBriefly, it returns |#t| if |obj1| and |obj2| should normally be regarded \nas the same object. This relation is left slightly open to interpretation, \nbut the following partial specification of |eqv?| holds for all \nimplementations of Scheme.\n\nThe |eqv?| procedure returns |#t| if:\n,(itemize\n(item [\n|obj1| and |obj2| are both |#t| or both |#f|.\n])\n\n(item [\n|obj1| and |obj2| are both symbols and \n@lisp\n(string=? (symbol->string obj1)\n          (symbol->string obj2))\n                     =>  #t\n@end lisp\n\n,(bold \"Note:\") This assumes that neither |obj1| nor |obj2| is an\n\"uninterned symbol\".\n])\n\n(item [\n|obj1| and |obj2| are both keywords and \n@lisp\n(string=? (keyword->string obj1)\n          (keyword->string obj2))\n                     =>  #t\n@end lisp\n])\n\n(item [\n|obj1| and |obj2| are both numbers, are numerically equal \n(see ,(ref :mark \"=\")), and are either both exact or both inexact. \n])\n\n(item [\n|obj1| and |obj2| are both characters and are the same character\naccording to the |char=?| procedure (see ,(ref :mark \"char=?\")). \n])\n\n(item [\nboth |obj1| and |obj2| are the empty list.\n])\n\n(item [\n|obj1| and |obj2| are pairs, vectors, or strings that denote\nthe same locations in the store.\n])\n\n(item [\n|obj1| and |obj2| are procedures whose location tags are equal.\n])\n)\n\n,(bold \"Note:\") STklos extends R5RS |eqv?| to take into account \nthe keyword type.\n£\nHere are some examples: \n@lisp\n(eqv? 'a 'a)                     =>  #t\n(eqv? 'a 'b)                     =>  #f\n(eqv? 2 2)                       =>  #t\n(eqv? :foo :foo)                 =>  #t\n(eqv? :foo :bar)                 =>  #f\n(eqv? '() '())                   =>  #t\n(eqv? 100000000 100000000)       =>  #t\n(eqv? (cons 1 2) (cons 1 2))     =>  #f\n(eqv? (lambda () 1)\n      (lambda () 2))             =>  #f\n(eqv? #f 'nil)                   =>  #f\n(let ((p (lambda (x) x)))\n  (eqv? p p))                    =>  #t\n@end lisp\n\nThe following examples illustrate cases in which the above rules do\nnot fully specify the behavior of |eqv?|. All that can be said about \nsuch cases is that the value returned by eqv? must be a boolean.\n@lisp\n(eqv? \"\" \"\")             =>  unspecified\n(eqv? '#() '#())         =>  unspecified\n(eqv? (lambda (x) x)\n      (lambda (x) x))    =>  unspecified\n(eqv? (lambda (x) x)\n      (lambda (y) y))    =>  unspecified\n@end lisp\n\n,(bold \"Note:\") In fact, the value returned by STklos depends of \nthe way code is entered and can yield |#t| in some cases and |#f| \nin others.\n£\nSee R5RS for more details on |eqv?|." :similar ())

(eq? :type procedure :synopsis "(eq? obj1 obj2)" :description "|Eq?| is similar to |eqv?| except that in some cases it is capable of\ndiscerning distinctions finer than those detectable by |eqv?|.\n£\n|Eq?| and |eqv?| are guaranteed to have the same behavior on symbols, \nkeywords, booleans, the empty list, pairs, procedures, and non-empty strings \nand vectors. |Eq?|'s behavior on numbers and characters is \nimplementation-dependent, but it will always return either true or false,\nand will return true only when |eqv?| would also return true.\n|Eq?| may also behave differently from |eqv?| on empty vectors\nand empty strings.\n£\n,(bold \"Note:\") STklos extends R5RS |eq?| to take into account\nthe keyword type.\n£\n,(bold \"Note:\") In STklos, comparison of character returns |#t| for identical\ncharacters and |#f| otherwise.\n\n@lisp \n(eq? 'a 'a)                     =>  #t\n(eq? '(a) '(a))                 =>  unspecified\n(eq? (list 'a) (list 'a))       =>  #f\n(eq? \"a\" \"a\")                   =>  unspecified\n(eq? \"\" \"\")                     =>  unspecified\n(eq? :foo :foo)                 =>  #t\n(eq? :foo :bar)                 =>  #f\n(eq? '() '())                   =>  #t\n(eq? 2 2)                       =>  unspecified\n(eq? #\\\\A #\\\\A)                   =>  #t (unspecified in R5RS)\n(eq? car car)                   =>  #t\n(let ((n (+ 2 3)))\n  (eq? n n))                    =>  #t (unspecified in R5RS)\n(let ((x '(a)))\n  (eq? x x))                    =>  #t\n(let ((x '#()))\n  (eq? x x))                    =>  #t\n(let ((p (lambda (x) x)))\n  (eq? p p))                    =>  #t\n(eq? :foo :foo)                 =>  #t\n(eq? :bar bar:)                 =>  #t\n(eq? :bar :foo)                 =>  #f\n@end lisp \n" :similar ())

(equal? :type procedure :synopsis "(equal? obj1 obj2)" :description "|Equal?| recursively compares the contents of pairs, vectors, and \nstrings, applying |eqv?| on other objects such as numbers and symbols. \nA rule of thumb is that objects are generally |equal?| if they print the\nsame. |Equal?| may fail to terminate if its arguments are circular\ndata structures.\n@lisp\n(equal? 'a 'a)                  =>  #t\n(equal? '(a) '(a))              =>  #t\n(equal? '(a (b) c)\n        '(a (b) c))             =>  #t\n(equal? \"abc\" \"abc\")            =>  #t\n(equal? 2 2)                    =>  #t\n(equal? (make-vector 5 'a)\n        (make-vector 5 'a))     =>  #t\n@end lisp" :similar ())


;; Source file "boot.c"


;; Source file "char.c"

(char? :type procedure :synopsis "(char? obj)" :description "Returns |#t| if |obj| is a character, otherwise returns |#f|." :similar ())

(char>=? :type procedure :synopsis "(char=? char1 char2)\n(char<? char1 char2)\n(char>? char1 char2)\n(char<=? char1 char2)\n(char>=? char1 char2)" :description "These procedures impose a total ordering on the set of characters. \nIt is guaranteed that under this ordering:\n,(itemize\n(item [The upper case characters are in order.])\n(item [The lower case characters are in order.])\n(item [The digits are in order.])\n(item [Either all the digits precede all the upper case letters, or vice versa.])\n(item [Either all the digits precede all the lower case letters, or vice versa.])\n)" :similar (char<=? char>? char<? char=?))

(char<=? :see char>=?)
(char>? :see char>=?)
(char<? :see char>=?)
(char=? :see char>=?)
(char-ci>=? :type procedure :synopsis "(char-ci=? char1 char2)\n(char-ci<? char1 char2)\n(char-ci>? char1 char2)\n(char-ci<=? char1 char2)\n(char-ci>=? char1 char2)" :description "These procedures are similar to |char=?| et cetera, but they treat\nupper case and lower case letters as the same. For example, \n|(char-ci=? #\\A #\\a)| returns |#t|." :similar (char-ci<=? char-ci>? char-ci<? char-ci=?))

(char-ci<=? :see char-ci>=?)
(char-ci>? :see char-ci>=?)
(char-ci<? :see char-ci>=?)
(char-ci=? :see char-ci>=?)
(char-lower-case? :type procedure :synopsis "(char-alphabetic? char)\n(char-numeric? char)\n(char-whitespace? char)\n(char-upper-case? letter)\n(char-lower-case? letter)" :description "These procedures return |#t| if their arguments are alphabetic, numeric,\nwhitespace, upper case, or lower case characters, respectively, otherwise they\nreturn |#f|. The following remarks, which are specific to the ASCII character \nset, are intended only as a guide: The alphabetic characters are the 52\nupper and lower case letters. The numeric characters are the ten decimal\ndigits. The whitespace characters are space, tab, line feed, form feed,\nand carriage return." :similar (char-upper-case? char-whitespace? char-numeric? char-alphabetic?))

(char-upper-case? :see char-lower-case?)
(char-whitespace? :see char-lower-case?)
(char-numeric? :see char-lower-case?)
(char-alphabetic? :see char-lower-case?)
(integer->char :type procedure :synopsis "(char->integer char)\n(integer->char n)" :description "Given a character, |char->integer| returns an exact integer\nrepresentation of the character. Given an exact integer that is the\nimage of a character under |char->integer|, |integer->char| returns\nthat character. These procedures implement order-preserving\nisomorphisms between the set of characters under the |char<=?|\nordering and some subset of the integers under the |<=|\nordering. That is, if\n@lisp\n   (char<=? a b) => #t  ,(bold \"and\")  (<= x y) => #t\n@end lisp\nand x and y are in the domain of |integer->char|, then\n@lisp\n   (<= (char->integer a)\n       (char->integer b))         =>  #t\n\n  (char<=? (integer->char x)\n           (integer->char y))     =>  #t\n@end lisp" :similar (char->integer))

(char->integer :see integer->char)
(char-downcase :type procedure :synopsis "(char-upcase char)\n(char-downcase char)" :description "These procedures return a character |char2| such that \n|(char-ci=? char char2)|. In addition, if char is alphabetic, then the \nresult of |char-upcase| is upper case and the result of |char-downcase| is\nlower case. " :similar (char-upcase))

(char-upcase :see char-downcase)

;; Source file "cond.c"

(make-condition-type :type extended :synopsis "(make-condition-type id  parent  slot-names)" :description "|Make-condition-type| returns a new condition type. |Id| must be a symbol \nthat serves as a symbolic name for the condition type. |Parent| must itself \nbe a condition type. |Slot-names| must be a list of symbols. It identifies\nthe slots of the conditions associated with the condition type.\n" :similar ())

(make-compound-condition-type :type extended :synopsis "(make-compound-condition-type id ct1 ...)" :description "|Make-compound-condition-type| returns a new condition type, built \nfrom the condition types |ct1|, ...\n|Id| must be a symbol  that serves as a symbolic name for the \ncondition type. The slots names of the new condition type is the \nunion of the slots of conditions |ct1| ...\n£\n,(bold \"Note:\") This function is not defined in ,(srfi 34)." :similar ())

(condition-type? :type extended :synopsis "(condition-type? obj)" :description "Returns |#t| if |obj| is a condition type, and |#f| otherwise" :similar ())

(make-condition :type extended :synopsis "(make-condition type slot-name value  ...)" :description "|Make-condition| creates a condition value belonging condition type \n|type|. The following arguments must be, in turn, a slot name and an\narbitrary value. There must be such a pair for each slot of |type| and\nits direct and indirect supertypes. |Make-condition| returns the\ncondition value, with the argument values associated with their \nrespective slots.\n@lisp\n(let* ((ct (make-condition-type 'ct1 &condition '(a b)))\n       (c  (make-condition ct 'b 2 'a 1)))\n  (struct->list c))\n     => ((a . 1) (b . 2))\n@end lisp" :similar ())

(condition? :type extended :synopsis "(condition? obj)" :description "Returns |#t| if |obj| is a condition, and |#f| otherwise" :similar ())

(make-compound-condition :type extended :synopsis "(make-compound-condition condition0 condition1 ...)" :description "|Make-compound-condition| returns a compound condition belonging to\nall condition types that the |conditioni| belong to.\n\n|Condition-ref|, when applied to a compound condition will return\n the value from the first of the |conditioni| that has such a slot." :similar ())

(condition-ref :type extended :synopsis "(condition-ref condition slot-name)" :description "|Condition| must be a condition, and |slot-name| a symbol. Moreover, \n|condition| must belong to a condition type which has a slot name called \n|slot-name|, or one of its (direct or indirect) supertypes must have the\n slot. |Condition-ref| returns the value associated with |slot-name|.\n@lisp\n(let* ((ct (make-condition-type 'ct1 &condition '(a b)))\n       (c  (make-condition ct 'b 2 'a 1)))\n  (condition-ref c 'b))\n     => 2\n@end lisp" :similar ())

(condition-has-type? :type extended :synopsis "(condition-has-type? condition condition-type)" :description "|Condition-has-type?| tests if |condition| belongs to |condition-type|.\nIt returns |#t| if any of condition 's types includes |condition-type|\neither directly or as an ancestor and |#f| otherwise.\n@lisp\n (let* ((ct1 (make-condition-type 'ct1 &condition '(a b)))\n        (ct2 (make-condition-type 'ct2 ct1 '(c)))\n        (ct3 (make-condition-type 'ct3 &condition '(x y z)))\n        (c   (make-condition ct2 'a 1 'b 2 'c 3)))\n  (list (condition-has-type? c ct1)\n\t(condition-has-type? c ct2)\n\t(condition-has-type? c ct3)))\n    => (#t #t #f)\n@end lisp" :similar ())

(extract-condition :type extended :synopsis "(extract-condition condition  condition-type)" :description "|Condition| must be a condition belonging to |condition-type|. \n|Extract-condition| returns a condition of |condition-type|\nwith the slot values specified by |condition|. The new condition \nis always allocated.\n@lisp\n(let* ((ct1 (make-condition-type 'ct1 &condition '(a b)))\n       (ct2 (make-condition-type 'ct2 ct1 '(c)))\n       (c2  (make-condition ct2 'a 1 ' b 2 'c 3))\n       (c1  (extract-condition c2 ct1)))\n  (list (condition-has-type? c1 ct2)\n\t(condition-has-type? c1 ct1)))\n      => (#f #t)\n@end lisp" :similar ())

(raise :type extended :synopsis "(raise obj)" :description "Invokes the current exception handler on |obj|. The handler is called in \nthe dynamic environment of the call to |raise|, except that the current \nexception handler is that in place for the call to |with-handler|\nthat installed the handler being called. \n\n@lisp\n(with-handler (lambda (c)\n\t\t(format \"value ~A was raised\" c))\n   (raise 'foo)\n   (format #t \"never printed\\\\n\"))\n          => \"value foo was raised\"\n@end lisp" :similar ())


;; Source file "dynload.c"


;; Source file "env.c"

(module? :type extended :synopsis "(module? object)" :description "Returns |¤t| if |object| is a module and |¤f| otherwise.\n@lisp\n(module? (find-module 'ST\\klos))  => #t\n(module? 'ST\\klos)                => #f\n(module? 123 'no)                => no\n@end lisp" :similar ())

(find-module :type extended :synopsis "(find-module name)\n(find-module name default)" :description "STklos modules are first class objects and |find-module| returns the\nmodule associated to |name| if it exists. If there is no module\nassociated to |name|, an error is signaled if no |default| is\nprovided, otherwise |find-module| returns |default|. " :similar ())

(current-module :type extended :synopsis "(current-module)" :description "Returns the current module.\n@lisp\n(define-module M\n  (display \n      (cons (eq? (current-module) (find-module 'M))\n            (eq? (current-module) (find-module 'STklos)))))\n   @print{} (#t . #f)\n@end lisp" :similar ())

(module-name :type extended :synopsis "(module-name module)" :description "Returns the name (a symbol) associated to a |module|." :similar ())

(module-imports :type extended :synopsis "(module-imports module)" :description "Returns the list of modules that |module| imports." :similar ())

(module-exports :type extended :synopsis "(module-exports module)" :description "Returns the list of symbols exported by |module|. Note that this function\nreturns the list of symbols given in the module |export| clause and that \nsome of these symbols can be not yet defined." :similar ())

(module-symbols :type extended :synopsis "(module-symbols module)" :description "Returns the list of symbols already defined in |module|." :similar ())

(all-modules :type extended :synopsis "(all-modules)" :description "Returns the list of all the living modules." :similar ())

(symbol-value :type extended :synopsis "(symbol-value symbol module)\n(symbol-value symbol module default)" :description "Returns the value bound to |symbol| in |module|. If |symbol| is not bound,\nan error is signaled if no |default| is provided, otherwise |symbol-value| \nreturns |default|." :similar ())


;; Source file "error.c"


;; Source file "extend.c"


;; Source file "fport.c"

(open-input-file :type procedure :synopsis "(open-input-file filename)" :description "Takes a string naming an existing file and returns an input port capable\nof delivering characters from the file. If the file cannot be opened, \nan error is signalled.\n£\n,(bold \"Note:\") if |filename| starts with the string ,(code  (q \"| \")), \nthis procedure returns a pipe port. Consequently, it is not possible to\nopen a file whose name starts with those two characters." :similar ())

(open-output-file :type procedure :synopsis "(open-output-file filename)" :description "Takes a string naming an output file to be created and returns an output\nport capable of writing characters to a new file by that name. If the file \ncannot be opened, an error is signalled. If a file with the given name \nalready exists, it is rewritten.\n£\n,(bold \"Note:\") if |filename| starts with the string ,(code  (q \"| \")), \nthis procedure returns a pipe port. Consequently, it is not possible to\nopen a file whose name starts with those two characters." :similar ())

(output-file-port? :type extended :synopsis "(input-file-port? obj)\n(output-file-port? obj)" :description "Returns |#t| if |obj| is a file input port or a file output port respectively, \notherwise returns #f." :similar (input-file-port?))

(input-file-port? :see output-file-port?)
(open-file :type extended :synopsis "(open-file filename mode)" :description "Opens the file whose name is |filename| with the specified string\n|mode| which can be: \n,(itemize\n(item [|\"r\"| to open file for reading. The stream is positioned at\nthe beginning of the file.])\n\n(item [|\"r+\"| to open file for reading and writing.  The stream is\npositioned at the beginning of the file.])\n\n(item [|\"w\"| to truncate file to zero length or create file for writing.\nThe stream is positioned at the beginning of the file.])\n\n(item [|\"w+\"| to open  file for reading and writing. The file is created\nif it does not exist, otherwise it is truncated. The stream is positioned\nat the beginning of the file.])\n\n(item [|\"a\"| to open for writing.  The file is created if  it  does\nnot exist. The stream is positioned at the end of the file.])\n\n(item [|\"a+\"| to open file for reading and writing. The file is created\nif it does not exist. The stream is positioned at the end of the file.])\n)\nIf the file can be opened, |open-file| returns the port associated with\nthe given file, otherwise it returns |#f|. Here again, the ``magic'' \nstring \"@pipe \" permits to open a pipe port (in this case mode can only be \n|\"r\"| or |\"w\"|)." :similar ())

(port-file-name :type extended :synopsis "(port-file-name port)" :description "Returns the file name used to open |port|; |port| must be a file port. " :similar ())

(load :type procedure :synopsis "(load filename)" :description "|Filename| should be a string naming an existing file containing Scheme \nexpressions. |Load| has been extended in STklos to allow loading of\nfile containing Scheme compiled code as well as object files \n(,(emph \"aka\") shared objects). The loading of object files is not available on \nall architectures. The value returned by |load| is ,(emph \"void\").\n£ \nIf the file whose name is |filename| cannot be located, |load| will try \nto find it in one of the directories given by ,(code (ref :mark \"load-path\"))\nwith the suffixes given by ,(code (ref :mark \"load-suffixes\"))." :similar ())

(try-load :type extended :synopsis "(try-load filename)" :description "|try-load| tries to load the file named |filename|. As |load|, \n|try-load| tries to find the file given the current load path \nand a set of suffixes if |filename| cannot be loaded. If |try-load|\nis able to find a readable file, it is loaded, and |try-load| returns \n|#t|. Otherwise,  |try-load| retuns |#f|." :similar ())


;; Source file "gnu-getopt.c"


;; Source file "gnu-glob.c"


;; Source file "hash.c"

(hash-table? :type extended :synopsis "(hash-table? obj)" :description "Returns |#t| if |obj| is a hash table, returns |#f| otherwise." :similar ())

(hash-table-size :type extended :synopsis "(hash-table-size hash)" :description "Returns the number of entries in the |hash|." :similar ())

(hash-table-equivalence-function :type extended :synopsis "(hash-table-equivalence-function hash)" :description "Returns the equivalence predicate used for keys in |hash|." :similar ())

(hash-table-hash-function :type extended :synopsis "(hash-table-hash-function hash)" :description "Returns the hash function used for keys in |hash|." :similar ())

(hash-table-set! :type extended :synopsis "(hash-table-set! hash key value)" :description "Enters an association between |key| and |value| in the|hash| table. \nThe value returned by |hash-table-set!| is ,(emph \"void\")." :similar ())

(hash-table-ref :type extended :synopsis "(hash-table-ref hash key)\n(hash-table-ref hash key thunk)" :description "Returns the value associated with |key| in the given |hash| table. If no \nvalue has been associated with |key| in |hash|, the specified |thunk| is \ncalled and its value is returned; otherwise an error is raised.\n@lisp \n(define h1 (make-hash-table))\n(hash-table-set! h1 'foo (list 1 2 3))\n(hash-table-ref  h1 'foo)                 =>  (1 2 3)\n(hash-table-ref  h1 'bar \n                    (lambda () 'absent))  =>  absent\n(hash-table-ref  h1 'bar)                 =>  error\n(hash-table-set! h1 '(a b c) 'present)\n(hash-table-ref  h1 '(a b c) \n                     (lambda () 'absent)) => absent\n\n(define h2 (make-hash-table equal?))\n(hash-table-set! h2 '(a b c) 'present)\n(hash-table-ref  h2 '(a b c))             => present\n@end lisp" :similar ())

(hash-table-ref/default :type extended :synopsis "(hash-table-ref/default hash key)" :description "This function is equivalent to \n@lisp\n(hash-table-ref hash key (lambda () default))\n@end lisp" :similar ())

(hash-table-exists? :type extended :synopsis "(hash-table-exists? hash key)" :description "Returns |¤t| if there is any association of |key| in\n|hash|. Returns |¤f| otherwise." :similar ())

(hash-table-delete! :type extended :synopsis "(hash-table-delete! hash key)" :description "Deletes the entry for |key| in |hash|, if it exists. Result of \n|hash-table-delete!| is ,(emph \"void\").\n\n@lisp\n(define h (make-hash-table))\n(hash-table-set! h 'foo (list 1 2 3))\n(hash-table-ref h 'foo)                => (1 2 3)\n(hash-table-delete! h 'foo) \n(hash-table-ref h 'foo \n                  (lambda () 'absent)  => absent\n@end lisp" :similar ())

(hash-table-for-each :type extended :synopsis "(hash-table-for-each hash proc)\n(hash-table-walk hash proc)" :description "|Proc| must be a procedure taking two arguments. |Hash-table-for-each|\ncalls |proc| on each key/value association in |hash|, with the key as \nthe first argument and the value as the second.  The value returned by \n|hash-table-for-each| is ,(emph \"void\"). \n £\n,(bold \"Note:\") The order of application of |proc| is unspecified.\n £\n,(bold \"Note:\") |hash-table-walk| is another name for |hash-table-for-each|\n(this is the name used in ,(link-srfi 69)).\n\n@lisp\n(let ((h   (make-hash-table))\n      (sum 0))\n  (hash-table-set! h 'foo 2)\n  (hash-table-set! h 'bar 3)\n  (hash-table-for-each h (lambda (key value)\n                           (set! sum (+ sum value))))\n  sum)           =>  5 \n@end lisp" :similar (hash-table-walk))

(hash-table-walk :see hash-table-for-each)
(hash-table-map :type extended :synopsis "(hash-table-map hash proc)" :description "|Proc| must be a procedure taking two arguments. |Hash-table-map|\ncalls |proc| on each key/value association in |hash|, with the key as \nthe first argument and the value as the second.  The result of \n|hash-table-map| is a list of the values returned by |proc|, in an \nunspecified order.\n£\n,(bold \"Note:\") The order of application of |proc| is unspecified.\n@lisp\n(let ((h (make-hash-table)))\n  (dotimes (i 5) \n    (hash-table-set! h i (number->string i)))\n  (hash-table-map h (lambda (key value)\n                       (cons key value))))    \n             => ((3 . \"3\") (4 . \"4\") (0 . \"0\") (1 . \"1\") (2 . \"2\"))\n@end lisp" :similar ())

(hash-table-hash :type extended :synopsis "(hash-table-hash obj)" :description "Computes a hash code for an object and returns this hash code as a\nnon negative integer. A property of |hash-table-hash| is that \n@lisp\n(equal? x y) => (equal? (hash-table-hash x) (hash-table-hash y)\n@end lisp\n\nas the the Common Lisp |sxhash| function from which this procedure is\nmodeled." :similar ())

(hash-table-stats :type extended :synopsis "(hash-table-stats hash)\n(hash-table-stats hash port)" :description "Prints  overall information about |hash|, such as the number of entries\nit contains, the number of buckets in its hash array, and the utilization\nof the buckets. Informations are printed on |port|. If no |port| is given\nto |hash-table-stats|, information are printed on the current output port \n(see ,(ref :mark \"current-output-port\"))." :similar ())


;; Source file "keyword.c"

(make-keyword :type extended :synopsis "(make-keyword s)" :description "Builds a keyword from the given |s|. The parameter |s| must be a symbol\nor a string. \n@lisp\n(make-keyword \"test\")    => :test\n(make-keyword 'test)     => :test\n(make-keyword \":hello\")  => ::hello\n@end lisp" :similar ())

(keyword? :type extended :synopsis "(keyword obj)" :description "Returns |#t| if |obj| is a keyword, otherwise returns |#f|.\n@lisp\n(keyword? 'foo)     => #f\n(keyword? ':foo)    => #t\n(keyword? 'foo:)    => #t\n(keyword? :foo)     => #t\n(keyword? foo:)     => #t\n@end lisp" :similar ())

(keyword->string :type extended :synopsis "(keyword->string key)" :description "Returns the name of |key| as a string. The result does not contain a colon." :similar ())

(key-get :type extended :synopsis "(key-get list key)\n(key-get list key default)" :description "|List| must be a list of keywords and their respective values.\n|key-get| scans the |list| and returns the value\nassociated with the given |key|. If  |key| does\nnot appear in an odd position in |list|, the specified\n|default| is returned, or an error is raised if no |default| was\nspecified.\n@lisp\n(key-get '(:one 1 :two 2) :one)     => 1\n(key-get '(:one 1 :two 2) :four #f) => #f\n(key-get '(:one 1 :two 2) :four)    => error\n@end lisp" :similar ())

(key-set! :type extended :synopsis "(key-set! list key value)" :description "|List| must be a list of keywords and their respective values.\n|key-set!| sets the value associated to |key| in the keyword list. \nIf the key is already present in |list|, the keyword list is \n,(emph \"physically\") changed. \n@lisp\n(let ((l (list :one 1 :two 2)))\n  (set! l (key-set! l :three 3))\n  (cons (key-get l :one) \n        (key-get l :three)))            => (1 . 3)\n@end lisp" :similar ())

(key-delete! :type extended :synopsis "(key-delete  list key)\n(key-delete! list key)" :description "|List| must be a list of keywords and their respective values.\n|key-delete| remove the |key| and its associated value of the keyword \nlist. The key can be absent of the list. \n£\n|key-delete!| does the\nsame job than |key-delete| by physically modifying its |list| argument.\n@lisp\n(key-delete '(:one 1 :two 2) :two)    => (:one 1)\n(key-delete '(:one 1 :two 2) :three)  => (:one 1 :two 2)\n@end lisp" :similar (key-delete))

(key-delete :see key-delete!)

;; Source file "lib.c"


;; Source file "list.c"

(pair? :type procedure :synopsis "(pair? obj)" :description "|Pair?| returns |#t| if |obj| is a pair, and otherwise returns |#f|." :similar ())

(cons :type procedure :synopsis "(cons obj1 obj2)" :description "Returns a newly allocated pair whose car is obj1 and whose cdr is obj2.\nThe pair is guaranteed to be different (in the sense of eqv?) from every\nexisting object.\n@lisp\n    (cons 'a '())           =>  (a)\n    (cons '(a) '(b c d))    =>  ((a) b c d)\n    (cons \"a\" '(b c))       =>  (\"a\" b c)\n    (cons 'a 3)             =>  (a . 3)\n    (cons '(a b) 'c)        =>  ((a b) . c)\n@end lisp" :similar ())

(car :type procedure :synopsis "(car pair)" :description "Returns the contents of the car field of pair.\nNote that it is an error to take the |car| of the empty list.\n@lisp\n    (car '(a b c))          =>  a\n    (car '((a) b c d))      =>  (a)\n    (car '(1 . 2))          =>  1\n    (car '())               =>  error\n@end lisp" :similar ())

(cdr :type procedure :synopsis "(cdr pair)" :description "Returns the contents of the cdr field of pair.\nNote that it is an error to take the |cdr| of the empty list.\n@lisp\n    (cdr '((a) b c d))      =>  (b c d)\n    (cdr '(1 . 2))          =>  2\n    (cdr '())               =>  error\n@end lisp" :similar ())

(set-car! :type procedure :synopsis "(set-car! pair obj)" :description "Stores |obj| in the car field of |pair|.\nThe value returned by |set-car!| is ,(emph \"void\").\n@lisp\n   (define (f) (list 'not-a-constant-list))\n   (define (g) '(constant-list))\n   (set-car! (f) 3)\n   (set-car! (g) 3)             =>  error\n@end lisp" :similar ())

(set-cdr! :type procedure :synopsis "(set-cdr! pair obj)" :description "Stores |obj| in the cdr field of |pair|.\nThe value returned by |set-cdr!| is ,(emph \"void\").\n" :similar ())

(null? :type procedure :synopsis "(null? obj)" :description "Returns |#t| if |obj| is the empty list, otherwise returns |#f|." :similar ())

(list? :type procedure :synopsis "(list? obj)" :description "Returns |#t| if |obj| is a list, otherwise returns |#f|. By definition,\nall lists have finite length and are terminated by the empty list.\n@lisp\n   (list? '(a b c))     =>  #t\n   (list? '())          =>  #t\n   (list? '(a . b))     =>  #f\n   (let ((x (list 'a)))\n     (set-cdr! x x)\n     (list? x))         =>  #f\n@end lisp" :similar ())

(list :type procedure :synopsis "(list obj ...)" :description "Returns a newly allocated list of its arguments.\n@lisp\n   (list 'a (+ 3 4) 'c)            =>  (a 7 c)\n   (list)                          =>  ()\n@end lisp" :similar ())

(length :type procedure :synopsis "(length list)" :description "Returns the length of |list|.\n\n@lisp\n   (length '(a b c))               =>  3\n   (length '(a (b) (c d e)))       =>  3\n   (length '())                    =>  0\n@end lisp" :similar ())

(append :type procedure :synopsis "(append list ...)" :description "Returns a list consisting of the elements of the first list\nfollowed by the elements of the other lists.\n\n@lisp\n   (append '(x) '(y))              =>  (x y)\n   (append '(a) '(b c d))          =>  (a b c d)\n   (append '(a (b)) '((c)))        =>  (a (b) (c))\n@end lisp\n\nThe resulting list is always newly allocated, except that it shares\nstructure with the last list argument. The last argument may actually\nbe any object; an improper list results if the last argument is not a\nproper list.\n\n@lisp\n   (append '(a b) '(c . d))        =>  (a b c . d)\n   (append '() 'a)                 =>  a\n@end lisp" :similar ())

(reverse :type procedure :synopsis "(reverse list)" :description "Returns a newly allocated list consisting of the elements of |list| in\nreverse order.\n\n@lisp\n   (reverse '(a b c))              =>  (c b a)\n   (reverse '(a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)\n@end lisp" :similar ())

(list-tail :type procedure :synopsis "(list-tail list k)" :description "Returns the sublist of |list| obtained by omitting the first |k| elements.\nIt is an error if list has fewer than |k| elements. List-tail could\nbe defined by\n@lisp\n   (define list-tail\n      (lambda (x k)\n         (if (zero? k)\n            x\n            (list-tail (cdr x) (- k 1)))))\n@end lisp" :similar ())

(list-ref :type procedure :synopsis "(list-ref list k)" :description "Returns the |k|th element of |list|. (This is the same as the car\nof |(list-tail list k)|.) It is an error if list has fewer than |k|\nelements.\n\n@lisp\n   (list-ref '(a b c d) 2)                 =>  c\n   (list-ref '(a b c d)\n             (inexact->exact (round 1.8))) =>  c\n@end lisp" :similar ())

(member :type procedure :synopsis "(memq obj list)\n(memv obj list)\n(member obj list)" :description "These procedures return the first sublist of list whose car is |obj|,\nwhere the sublists of list are the non-empty lists returned by\n|(list-tail list k)| for |k| less than the length of list.\nIf |obj| does not occur in |list|, then |#f| (not the empty list) is\nreturned. |Memq| uses |eq?| to compare obj with the elements of list,\nwhile |memv| uses |eqv?| and |member| uses |equal?|.\n\n@lisp\n   (memq 'a '(a b c))              =>  (a b c)\n   (memq 'b '(a b c))              =>  (b c)\n   (memq 'a '(b c d))              =>  #f\n   (memq (list 'a) '(b (a) c))     =>  #f\n   (member (list 'a)\n           '(b (a) c))             =>  ((a) c)\n   (memv 101 '(100 101 102))       =>  (101 102)\n@end lisp" :similar (memv memq))

(memv :see member)
(memq :see member)
(assoc :type procedure :synopsis "(assq obj alist)\n(assv obj alist)\n(assoc obj alist)" :description "|Alist| (for \"association list\") must be a list of pairs. These procedures\nfind the first pair in |alist| whose car field is |obj|, and returns that\npair. If no pair in |alist| has |obj| as its car, then |#f| (not the empty\nlist) is returned. |Assq| uses |eq?| to compare |obj| with the car fields\nof the pairs in |alist|, while |assv| uses |eqv?| and |assoc| uses |equal?|.\n\n@lisp\n   (define e '((a 1) (b 2) (c 3)))\n   (assq 'a e)                =>  (a 1)\n   (assq 'b e)                =>  (b 2)\n   (assq 'd e)                =>  #f\n   (assq (list 'a) '(((a)) ((b)) ((c))))\n                              =>  #f\n   (assoc (list 'a) '(((a)) ((b)) ((c))))\n                              =>  ((a))\n   (assv 5 '((2 3) (5 7) (11 13)))\n                              =>  (5 7)\n@end lisp\n\n,(bold \"Rationale:\") Although they are ordinarily used as predicates,\n|memq|, |memv|, |member|, |assq|, |assv|, and |assoc| do not have question\nmarks in their names because they return useful values rather than just\n|#t| or #|f|." :similar (assv assq))

(assv :see assoc)
(assq :see assoc)
(pair-mutable? :type extended :synopsis "(pair-mutable? obj)" :description "Returns |#t| if |obj| is a mutable pair, otherwise returns |#f|. \n@lisp\n(pair-mutable? '(1 . 2))    => #f\n(pair-mutable? (cons 1 2))  => #t\n(pair-mutable? 12)          => #f\n@end lisp" :similar ())

(list* :type extended :synopsis "(list* obj ...)" :description "|list*| is like |list| except that the last argument to |list*| is\nused as the ,(emph \"cdr\") of the last pair constructed.\n@lisp\n   (list* 1 2 3)        => (1 2 . 3)\n   (list* 1 2 3 '(4 5)) => (1 2 3 4 5)\n   (list*)              => ()\n@end lisp" :similar ())

(copy-tree :type extended :synopsis "(copy-tree obj)" :description "|Copy-tree| recursively copies trees of pairs. If |obj| is\nnot a pair, it is returned; otherwise the result is a new pair whose\n|car| and |cdr| are obtained by calling |copy-tree| on\nthe |car| and |cdr| of |obj|, respectively." :similar ())

(last-pair :type extended :synopsis "(last-pair list)" :description "Returns the last pair of |list|.\n@lisp\n(last-pair '(1 2 3))   => (3)\n(last-pair '(1 2 . 3)) => (2 . 3)\n@end lisp" :similar ())

(filter! :type extended :synopsis "(filter  pred list)\n(filter! pred list)" :description "|Filter| returns all the elements of |list| that satisfy predicate\n|pred|. The |list| is not disordered: elements that appear in the\nresult list occur in the same order as they occur in the argument\nlist. |Filter!| does the same job than |filter| by physically \nmodifying its |list| argument \n@lisp\n(filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)\n(let* ((l1 (list 0 7 8 8 43 -4))\n       (l2 (filter! even? l1)))\n   (list l1 l2))                => ((0 8 8 -4) (0 8 8 -4))\n@end lisp\nAn error is signaled if |list| is a constant list." :similar (filter))

(filter :see filter!)
(append! :type extended :synopsis "(append! list ...)" :description "Returns a list consisting of the elements of the first list\nfollowed by the elements of the other lists.\nContrarily to |append|, the parameter lists (except the last one) are \nphysically modified: their last pair is changed to the value of the next \nlist in the |append!| formal parameter list.\n@lisp\n(let* ((l1 (list 1 2))\n       (l2 (list 3))\n       (l3 (list 4 5))\n       (l4 (append! l1 l2 l3)))\n  (list l1 l2 l3))  => ((1 2 3 4 5) (3 4 5) (4 5))\n@end lisp\nAn error is signaled if one of the given lists is a constant list." :similar ())

(reverse! :type extended :synopsis "(reverse! list)" :description "Returns a list consisting of the elements of |list| in reverse order.\nContrarily to |reverse|, the returned value is not newly allocated but\ncomputed \"in place\".\n\n@lisp\n(let ((l '(a b c)))\n  (list (reverse! l) l))        =>  ((c b a) (a))\n(reverse! '(a constant list))   =>  error\n@end lisp" :similar ())


;; Source file "misc.c"

(version :type extended :synopsis "(version)" :description "Returns a string identifying the current version of the system. A version is \nconstituted of three numbers separated by a point: the version, the release\nand sub-release numbers." :similar ())

(void :type extended :synopsis "(void)\n(void arg1 ...)" :description "Returns the special ,(emph \"void\") object. If arguments are passed to |void|,\nthey are evalued and simply ignored." :similar ())

(address-of :type procedure :synopsis "(address-of obj)" :description "Returns the address of the object |obj| as an integer." :similar ())

(gc :type procedure :synopsis "(gc)" :description "Returns the address of the object |obj| as an integer." :similar ())

(uri-parse :type extended :synopsis "(uri-parse str)" :description "Parses the string |str| as a RFC-2396 URI and return a keyed list with the \nfollowing components\n,(itemize\n(item [|scheme| : the scheme used as a string (defaults to |\"file\"|)])\n(item [|host| : the host as a string (defaults to \"\")])\n(item [|port| : the port as an integer (0 if no port specified)])\n(item [|path| : the path ])\n(item [|query| : the qury part of the URI as a string (defaults to the \nempty string)])\n(item [|fragment| : the fragment of the URI as a string (defaults to the \nempty string)])\n)\n@lisp\n(uri-parse \"http://google.com\")\n    => (:scheme \"http\" :host \"google.com\" :port 80 :path \"/\" \n        :query \"\" :fragment \"\")\n(uri-parse \"http://stklos.net:8080/a/file?x=1;y=2#end\")\n    => (:scheme \"http\" :host \"stklos.net\" :port 8080 \n        :path \"/a/file\" :query \"x=1;y=2\" :fragment \"end\")\n(uri-parse \"/a/file\")           \n   => (:scheme \"file\" :host \"\" :port 0 :path \"/a/file\" \n       :query \"\" :fragment \"\")\n(uri-parse \"\")\n   => (:scheme \"file\" :host \"\" :port 0 :path \"\" \n       :query \"\" :fragment \"\")\n@end lisp" :similar ())

(string->html :type extended :synopsis "(string->html str)" :description "This primitive is a convenience function; it returns a string where \nthe HTML special chars are properly translated. It can easily written \nin Scheme, but this version is fast.\n@lisp\n(string->html \"Just a <test>\")\n   => \"Just a &lt;test&gt;\"\n@end lisp" :similar ())

(get-password :type extended :synopsis "(get-password)" :description "This primitive permits to enter a password (character echoing \nbeing turned off). The value returned by |get-password| is the entered\npassword as a string." :similar ())


;; Source file "number.c"

(real-precision :type extended :synopsis "(real-precision)\n(real-precision value)" :description "This parameter object permits to change the default precision used \nto print real numbers. \n@lisp\n(real-precision)        => 15\n(define f 0.123456789)\n(display f)             @print{} 0.123456789\n(real-precision 3)\n(display f)             @print{} 0.123\n@end lisp" :similar ())

(integer? :type procedure :synopsis "(number? obj)\n(complex? obj)\n(real? obj)\n(rational? obj)\n(integer? obj)" :description "These numerical type predicates can be applied to any kind of\nargument, including non-numbers. They return |#t| if the object is of\nthe named type, and otherwise they return |#f|. In general, if a type\npredicate is true of a number then all higher type predicates are\nalso true of that number. Consequently, if a type predicate is\nfalse of a number, then all lower type predicates are also false of\nthat number.\n\nIf |z| is an inexact complex number, then |(real? z)| is true if and\nonly if |(zero? (imag-part z))| is true. If |x| is an inexact real\nnumber, then |(integer? x)| is true if and only if \n|(and (finite? x) (= x (round x)))|\n\n\n@lisp\n  (complex? 3+4i)         =>  #t\n  (complex? 3)            =>  #t\n  (real? 3)               =>  #t\n  (real? -2.5+0.0i)       =>  #t\n  (real? #e1e10)          =>  #t\n  (rational? 6/10)        =>  #t\n  (rational? 6/3)         =>  #t\n  (integer? 3+0i)         =>  #t\n  (integer? 3.0)          =>  #t\n  (integer? 3.2)          =>  #f\n  (integer? 8/4)          =>  #t\n  (integer? \"no\")         =>  #f\n  (complex? +inf.0)       =>  #t\n  (real? -inf.0)          =>  #t\n  (rational? +inf.0)      =>  #f\n  (integer? -inf.0)       =>  #f\n@end lisp\n" :similar (rational? real? complex? number?))

(rational? :see integer?)
(real? :see integer?)
(complex? :see integer?)
(number? :see integer?)
(bignum? :type extended :synopsis "(bignum? x)" :description "This predicates returns |#t| if |x| is an integer number too large to be \nrepresented with a native integer. \n@lisp\n(bignum? (expt 2 300))     => |#t|   (very likely)\n(bignum? 12)               => |#f|\n(bignum? \"no\")             => |#f|\n@end lisp" :similar ())

(inexact? :type procedure :synopsis "(exact? z)\n(inexact? z)" :description "These numerical predicates provide tests for the exactness of a\nquantity. For any Scheme number, precisely one of these predicates\nis true. " :similar (exact?))

(exact? :see inexact?)
(>= :type procedure :synopsis "(= z1 z2 z3 ...)\n(< x1 x2 x3 ...)\n(> x1 x2 x3 ...)\n(<= x1 x2 x3 ...)\n(>= x1 x2 x3 ...)" :description "These procedures return |#t| if their arguments are (respectively):\nequal, monotonically increasing, monotonically decreasing,\nmonotonically nondecreasing, or monotonically nonincreasing.\n@lisp\n(= +inf.0 +inf.0)           =>  #t\n(= -inf.0 +inf.0)           =>  #f\n(= -inf.0 -inf.0)           =>  #t\n£\nFor any finite real number x:\n£\n(< -inf.0 x +inf.0)         =>  #t\n(> +inf.0 x -inf.0)         =>  #t\n@end lisp" :similar (<= > < =))

(<= :see >=)
(> :see >=)
(< :see >=)
(= :see >=)
(even? :type procedure :synopsis "(finite? z)\n(infinite? z)\n(zero? z)\n(positive? x)\n(negative? x)\n(odd? n)\n(even? n)" :description "These numerical predicates test a number for a particular property,\nreturning |#t| or |#f|.\n@lisp\n(positive? +inf.0)          ==>  #t\n(negative? -inf.0)          ==>  #t\n(finite? -inf.0)            ==>  #f\n(infinite? +inf.0)          ==>  #t\n@end lisp" :similar (odd? negative? positive? zero? infinite? finite?))

(odd? :see even?)
(negative? :see even?)
(positive? :see even?)
(zero? :see even?)
(infinite? :see even?)
(finite? :see even?)
(min :type procedure :synopsis "(max x1 x2 ...)\n(min x1 x2 ...)" :description "These procedures return the maximum or minimum of their arguments.\n\n@lisp\n(max 3 4)              =>  4    ; exact\n(max 3.9 4)            =>  4.0  ; inexact\n@end lisp\nFor any real number x:\n@lisp\n(max +inf.0 x)         =>  +inf.0\n(min -inf.0 x)         =>  -inf.0\n@end lisp \n£\n,(bold \"Note:\") If any argument is inexact, then the result will also be\ninexact" :similar (max))

(max :see min)
(* :type procedure :synopsis "(+ z1 ...)\n(* z1 ...)" :description "These procedures return the sum or product of their arguments.\n@lisp\n(+ 3 4)                 =>  7\n(+ 3)                   =>  3\n(+)                     =>  0\n(+ +inf.0 +inf.0)       =>  +inf.0\n(+ +inf.0 -inf.0)       =>  +nan.0\n(* 4)                   =>  4\n(*)                     =>  1\n(* 5 +inf.0)            =>  +inf.0\n(* -5 +inf.0)           =>  -inf.0\n(* +inf.0 +inf.0)       =>  +inf.0\n(* +inf.0 -inf.0)       =>  -inf.0\n(* 0 +inf.0)            =>  +nan.0\n@end lisp\n,(bold \"Note:\") For any finite number z:\n@lisp\n(+ +inf.0 z)            =>  +inf.0\n(+ -inf.0 z)            =>  -inf.0\n@end lisp" :similar (+))

(+ :see *)
(/ :type procedure :synopsis "(- z)\n(- z1 z2)\n(/ z)\n(/ z1 z2 ...)" :description "With two or more arguments, these procedures return the difference or quotient\nof their arguments, associating to the left. With one argument, however,\nthey return the additive or multiplicative inverse of their argument.\n\n@lisp\n(- 3 4)                 =>  -1\n(- 3 4 5)               =>  -6\n(- 3)                   =>  -3\n(- +inf.0 +inf.0)       => +nan.0\n(/ 3 4 5)               =>  3/20\n(/ 3)                   =>  1/3\n(/ 0.0)                 => +inf.0\n(/ 0)                   => error (division by 0)\n@end lisp" :similar (-))

(- :see /)
(abs :type procedure :synopsis "(abs x)" :description "|Abs| returns the absolute value of its argument.\n@lisp\n(abs -7)                =>  7\n(abs -inf.0)            => +inf.0\n@end lisp" :similar ())

(modulo :type procedure :synopsis "(quotient n1 n2)\n(remainder n1 n2)\n(modulo n1 n2)" :description "These procedures implement number-theoretic (integer) division. n2 should\nbe non-zero. All three procedures return integers. \n£\nIf |n1/n2| is an integer:\n\n@lisp\n(quotient n1 n2)   => n1/n2\n(remainder n1 n2)  => 0\n(modulo n1 n2)     => 0\n@end lisp\n\nIf n1/n2 is not an integer:\n\n@lisp\n(quotient n1 n2)   => nq\n(remainder n1 n2)  => nr\n(modulo n1 n2)     => nm\n@end lisp \n\nwhere |nq| is |n1/n2| rounded towards zero, 0 < abs(nr) < abs(n2), \n0 < abs(nm) < abs(n2), |nr| and |nm| differ from n1 by a multiple of n2, \n|nr| has the same sign as n1, and |nm| has the same sign as n2.\n£\nFrom this we can conclude that for integers |n1| and |n2| with |n2| not \nequal to 0,\n@lisp\n (= n1 (+ (* n2 (quotient n1 n2))\n          (remainder n1 n2)))   =>  #t\n@end lisp\nprovided all numbers involved in that computation are exact.\n\n@lisp\n(modulo 13 4)           =>  1\n(remainder 13 4)        =>  1\n\n(modulo -13 4)          =>  3\n(remainder -13 4)       =>  -1\n\n(modulo 13 -4)          =>  -3\n(remainder 13 -4)       =>  1\n\n(modulo -13 -4)         =>  -1\n(remainder -13 -4)      =>  -1\n\n(remainder -13 -4.0)    =>  -1.0  ; inexact\n@end lisp" :similar (remainder quotient))

(remainder :see modulo)
(quotient :see modulo)
(lcm :type procedure :synopsis "(gcd n1 ...)\n(lcm n1 ...)" :description "These procedures return the greatest common divisor or least common \nmultiple of their arguments. The result is always non-negative.\n\n@lisp\n(gcd 32 -36)            =>  4\n(gcd)                   =>  0\n(lcm 32 -36)            =>  288\n(lcm 32.0 -36)          =>  288.0  ; inexact\n(lcm)                   =>  1\n@end lisp" :similar (gcd))

(gcd :see lcm)
(denominator :type procedure :synopsis "(numerator q)\n(denominator q)" :description "These procedures return the numerator or denominator of their argument; the\nresult is computed as if the argument was represented as a fraction in\nlowest terms. The denominator is always positive. The denominator of\n0 is defined to be 1.\n@lisp\n(numerator (/ 6 4))  =>  3\n(denominator (/ 6 4))  =>  2\n(denominator\n(exact->inexact (/ 6 4))) => 2.0\n@end lisp" :similar (numerator))

(numerator :see denominator)
(round :type procedure :synopsis "(floor x)\n(ceiling x)\n(truncate x)\n(round x)" :description "These procedures return integers. |Floor| returns the largest integer not\nlarger than |x|. |Ceiling| returns the smallest integer not smaller than |x|. \n|Truncate| returns the integer closest to |x| whose absolute value is not\nlarger than the absolute value of |x|. |Round| returns the closest integer \nto |x|, rounding to even when |x| is halfway between two integers.\n£\n,(bold \"Rationale:\") |Round| rounds to even for consistency with the default \nrounding mode specified by the IEEE floating point standard.\n£\n,(bold \"Note:\") If the argument to one of these procedures is inexact, then the\nresult will also be inexact. If an exact value is needed, the result should \nbe passed to the |inexact->exact| procedure.\n\n@lisp\n\n(floor -4.3)          =>  -5.0\n(ceiling -4.3)        =>  -4.0\n(truncate -4.3)       =>  -4.0\n(round -4.3)          =>  -4.0\n\n(floor 3.5)           =>  3.0\n(ceiling 3.5)         =>  4.0\n(truncate 3.5)        =>  3.0\n(round 3.5)           =>  4.0  ; inexact\n\n(round 7/2)           =>  4    ; exact\n(round 7)             =>  7\n@end lisp" :similar (truncate ceiling floor))

(truncate :see round)
(ceiling :see round)
(floor :see round)
(atan :type procedure :synopsis "(exp z)\n(log z)\n(sin z)\n(cos z)\n(tan z)\n(asin z)\n(acos z)\n(atan z)\n(atan y x)" :description "These procedures compute the usual transcendental functions. |Log| computes the\nnatural logarithm of z (not the base ten logarithm). |Asin|, |acos|, \nand |atan| compute arcsine, arccosine, and  arctangent, respectively. \nThe two-argument variant of |atan| computes \n@lisp\n(angle (make-rectangular x y))\n@end lisp \n\nWhen it is possible these procedures produce a real result from a real \nargument." :similar (acos asin tan cos sin log exp))

(acos :see atan)
(asin :see atan)
(tan :see atan)
(cos :see atan)
(sin :see atan)
(log :see atan)
(exp :see atan)
(sqrt :type procedure :synopsis "(sqrt z)" :description "Returns the principal square root of |z|. The result will have either\npositive real part, or zero real part and non-negative imaginary part." :similar ())

(expt :type procedure :synopsis "(expt z1 z2)" :description "Returns |z1| raised to the power |z2|. \n£\n,(bold \"Note:\") |0,(sup \"z\")| is 1 if |z = 0| and |0| otherwise." :similar ())

(angle :type procedure :synopsis "(make-rectangular x1 x2)\n(make-polar x3 x)\n(real-part z)\n(imag-part z)\n(magnitude z)\n(angle z)" :description "If x1, x2, x3, and x4 are real numbers and z is a complex number such that\n£\n|z = x1 + x2.i = x3 . e,(sup \"i.x4\")|\n£\nThen\n@lisp\n(make-rectangular x1 x2)       => z\n(make-polar x3 x4)             => z\n(real-part z)                  => x1\n(imag-part z)                  => x2\n(magnitude z)                  => abs(x3)\n(angle z)                      => xa\n@end lisp\nwhere \n|-,(symbol \"pi\") < xa <= ,(symbol \"pi\")| with |xa = x4 + 2,(symbol \"pi\")n|\nfor some integer n.\n@lisp \n(angle +inf.0)                 => 0.0\n(angle -inf.0)                 => 3.14159265358979\n@end lisp\n£\n,(bold \"Note:\") |Magnitude| is the same as |abs| for a real argument." :similar (magnitude imag-part real-part make-polar make-rectangular))

(magnitude :see angle)
(imag-part :see angle)
(real-part :see angle)
(make-polar :see angle)
(make-rectangular :see angle)
(inexact->exact :type procedure :synopsis "(exact->inexact z)\n(inexact->exact z)" :description "|Exact->inexact| returns an inexact representation of z.  \nThe value returned is the inexact number that is numerically closest to \nthe argument. \n|Inexact->exact| returns an exact representation of z.\nThe value returned is the exact number that is numerically closest to \nthe argument." :similar (exact->inexact))

(exact->inexact :see inexact->exact)
(number->string :type procedure :synopsis "(number->string z)\n(number->string z radix)" :description "|Radix| must be an exact integer, either 2, 8, 10, or 16. If omitted, radix\ndefaults to 10. The procedure |number->string| takes a number and a radix \nand returns as a string an external representation of the given number in \nthe given radix such that\n@lisp\n(let ((number number)\n      (radix radix))\n  (eqv? number\n       (string->number (number->string number radix) radix)))\n@end lisp\nis true. It is an error if no possible result makes this expression true.\n£\nIf |z| is inexact, the radix is 10, and the above expression can be \nsatisfied by a result that contains a decimal point, then the result \ncontains a decimal point and is expressed using the minimum number of digits \n(exclusive of exponent and trailing zeroes) needed to make the above expression\ntrue; otherwise the format of the result is unspecified.\n£\nThe result returned by |number->string| never contains an explicit radix \nprefix.\n£\n,(bold \"Note:\") The error case can occur only when |z| is not a complex number or\nis a complex number with a non-rational real or imaginary part.\n£\n,(bold \"Rationale:\") If |z| is an inexact number represented using flonums, and \nthe radix is 10, then the above expression is normally satisfied by a result\ncontaining a decimal point. The unspecified case allows for infinities, \nNaNs, and non-flonum representations." :similar ())

(string->number :type procedure :synopsis "(string->number string)\n(string->number string radix)" :description "Returns a number of the maximally precise representation expressed by the\ngiven |string|. |Radix| must be an exact integer, either 2, 8, 10, or 16. \nIf supplied, |radix| is a default radix that may be overridden by an explicit\nradix prefix in |string| (e.g. ,(code \"\\\"#o177\\\"\")). If |radix| is not\n supplied, then\nthe default radix is 10. If |string| is not a syntactically valid notation\nfor a number, then |string->number| returns |#f|.\n@lisp\n(string->number \"100\")        =>  100\n(string->number \"100\" 16)     =>  256\n(string->number \"1e2\")        =>  100.0\n(string->number \"15##\")       =>  1500.0\n(string->number \"+inf.0\")     =>  +inf.0\n(string->number \"-inf.0\")     =>  -inf.0  \n@end lisp\n" :similar ())

(decode-float :type extended :synopsis "(decode-float n)" :description "|decode-float| returns three exact integers: |significand|, |exponent|\nand |sign| (where |-1 <= sign <= 1|). The values returned by |decode-float|\nsatisfy: \n@lisp\nn = (* sign significand (expt 2 exponent))\n@end lisp\nHere is an example of |decode-float| usage.\n@lisp\n(receive l (decode-float -1.234) l)\n                    => (5557441940175192 -52 -1)\n(exact->inexact (* -1 \n                    5557441940175192 \n                    (expt 2 -52))\n                    => -1.234\n@end lisp" :similar ())


;; Source file "object.c"


;; Source file "parameter.c"

(make-parameter :type extended :synopsis "(make-parameter init)\n(make-parameter init converter)" :description "Returns a new parameter object which is bound in the global dynamic\nenvironment to a cell containing the value returned by the call\n|(converter init)|. If the conversion procedure |converter| is not\nspecified the identity function is used instead.\n£\nThe parameter object is a procedure which accepts zero or one\nargument. When it is called with no argument, the content of the\ncell bound to this parameter object in the current dynamic\nenvironment is returned. When it is called with one argument, the\ncontent of the cell bound to this parameter object in the current\ndynamic environment is set to the result of the call \n|(converter arg)|, where |arg| is the argument passed to the\nparameter object, and\nan unspecified value is returned.\n\n@lisp\n(define radix\n    (make-parameter 10))\n\n(define write-shared\n   (make-parameter\n      #f\n      (lambda (x)\n        (if (boolean? x)\n            x\n            (error 'write-shared \"bad boolean ~S\" x)))))\n\n (radix)           =>  10\n (radix 2)\n (radix)           =>  2\n (write-shared 0)  => error\n\n (define prompt\n   (make-parameter\n     123\n     (lambda (x)\n       (if (string? x)\n           x\n           (with-output-to-string (lambda () (write x)))))))\n\n (prompt)       =>  \"123\"\n (prompt \">\")\n (prompt)       =>  \">\"\n@end lisp" :similar ())

(parameter? :type extended :synopsis "(parameter? obj)" :description " Returns |#t| if |obj| is a parameter object, otherwise returns |#f|." :similar ())


;; Source file "path.c"


;; Source file "port.c"

(output-port? :type procedure :synopsis "(input-port? obj)\n(output-port? obj)" :description "Returns |#t| if |obj| is an input port or output port respectively, \notherwise returns #f." :similar (input-port?))

(input-port? :see output-port?)
(interactive-port? :type extended :synopsis "(interactive-port? port)" :description "Returns |#t| if |port| is connected to a terminal and |#f| otherwise." :similar ())

(current-output-port :type procedure :synopsis "(current-input-port obj)\n(current-output-port obj)" :description "Returns the current default input or output port." :similar (current-input-port))

(current-input-port :see current-output-port)
(current-error-port :type extended :synopsis "(current-error-port obj)" :description "Returns the current default error port." :similar ())

(read :type procedure :synopsis "(read)\n(read port)" :description "|Read| converts external representations of Scheme objects into the\nobjects themselves. |Read| returns the next object parsable from the given\ninput port, updating port to point to the first character past the end of\nthe external representation of the object.\n£\nIf an end of file is encountered in the input before any characters are found\nthat can begin an object, then an end of file object is returned. The port\nremains open, and further attempts to read will also return an end of file\nobject. If an end of file is encountered after the beginning of an object's\nexternal representation, but the external representation is incomplete \nand therefore not parsable, an error is signalled.\n£\nThe port argument may be omitted, in which case it defaults to the value\nreturned by |current-input-port|. It is an error to read from a closed port.\n£\n,(stklos) |read| supports the ,(link-srfi 10) |#,()| form that can be used\nto denote values that do not have a convenient printed representation. See \nthe SRFI document for more information." :similar ())

(read-with-shared-structure :type extended :synopsis "(read-with-shared-structure)\n(read-with-shared-structure  port)\n(read/ss)\n(read/ss port)" :description "|read-with-shared-structure| is identical to |read|. It has been added to \nbe compatible with ,(link-srfi 38). STklos always knew how to deal with \nrecursive input data. |read/ss| is only a shorter name for \n|read-with-shared-structure|.\n" :similar ())

(define-reader-ctor :type extended :synopsis "(define-reader-ctor tag proc)" :description "This procedure permits to define a new user to reader constructor procedure\nat run-time. It is defined in ,(link-srfi 10) document. See  SRFI document \nfor more information.\n@lisp\n(define-reader-ctor 'rev (lambda (x y) (cons y x)))\n(with-input-from-string \"#,(rev 1 2)\" read)\n                             => (2 . 1)\n@end lisp" :similar ())

(read-char :type procedure :synopsis "(read-char)\n(read-char port)" :description "Returns the next character available from the input |port|, updating the |port|\nto point to the following character. If no more characters are available, \nan end of file object is returned. |Port| may be omitted, in which case \nit defaults to the value returned by |current-input-port|." :similar ())

(read-chars :type extended :synopsis "(read-chars size)\n(read-chars size port)" :description "Returns a newly allocated string made of |size| characters read from |port|.\nIf less than |size| characters are available on the input port, the returned\nstring is smaller than |size| and its size is the number of available \ncharacters. |Port| may be omitted, in which case it defaults to the\nvalue returned by |current-input-port|." :similar ())

(read-chars! :type extended :synopsis "(read-chars! str)\n(read-chars! str port)" :description "This function reads the characters available from |port| in the string |str|\nby chuncks whose size is equal to the length of |str|.\nThe value returned by |read-chars!|is an integer indicating the number\nof characters read. |Port| may be omitted, in which case it defaults to the\nvalue returned by |current-input-port|. \n£\nThis function is similar to |read-chars| except that it avoids to allocate \na new string for each read. \n@lisp\n(define (copy-file from to)\n  (let* ((size 1024)\n         (in  (open-input-file from))\n         (out (open-output-file to))\n         (s   (make-string size)))\n    (let Loop ()\n      (let ((n (read-chars! s in)))\n        (cond\n          ((= n size)\n             (write-chars s out)\n             (Loop))\n          (else\n             (write-chars (substring s 0 n) out)\n             (close-port out)))))))\n@end lisp" :similar ())

(peek-char :type procedure :synopsis "(peek-char)\n(peek-char port)" :description "Returns the next character available from the input |port|, without updating \nthe port to point to the following character. If no more characters are\navailable, an end of file object is returned. |Port| may be omitted, in\nwhich case it defaults to the value returned by |current-input-port|.\n£\n,(bold \"Note:\") The value returned by a call to |peek-char| is the same as the\nvalue that would have been returned by a call to |read-char| with the same\nport. The only difference is that the very next call to |read-char| or \n|peek-char| on that port will return the value returned by the preceding\ncall to |peek-char|. In particular, a call to |peek-char| on an interactive\nport will hang waiting for input whenever a call to |read-char| would have\nhung." :similar ())

(eof-object? :type procedure :synopsis "(eof-object? obj)" :description "Returns |#t| if |obj| is an end of file object, otherwise returns |#f|. " :similar ())

(eof-object :type extended :synopsis "(eof-object)" :description ",(index \"#eof\")\nReturns an end of file object. Note that the special notation |#eof| is \nanother way to return such an end of file object." :similar ())

(char-ready? :type procedure :synopsis "(char-ready?)\n(char-ready? port)" :description "Returns |#t| if a character is ready on the input port and returns |#f|\notherwise. If char-ready returns |#t| then the next read-char operation on\nthe given port is guaranteed not to hang. If the port is at end of file\nthen |char-ready?| returns |#t|. Port may be omitted, in which case it\ndefaults to the value returned by |current-input-port|." :similar ())

(write :type procedure :synopsis "(write obj)\n(write obj port)" :description "Writes a written representation of |obj| to the given |port|. Strings that\nappear in the written representation are enclosed in doublequotes, and \nwithin those strings backslash and doublequote characters are escaped\nby backslashes. Character objects are written using the ,(emph \"#\\\\\") notation. \n|Write| returns an unspecified value. The |port| argument may be omitted, in\nwhich case it defaults to the value returned by |current-output-port|." :similar ())

(write* :type extended :synopsis "(write* obj)\n(write* obj port)" :description "Writes a written representation of |obj| to the given port.  The\nmain difference with the |write| procedure is that |write*|\nhandles data structures with cycles. Circular structure written by \nthis procedure use the ,(code (q \"#n=\")) and ,(code (q \"#n#\"))\nnotations (see ,(ref :mark \"Circular structure\")).\n" :similar ())

(write-with-shared-structure :type extended :synopsis "(write-with-shared-structure obj)\n(write-with-shared-structure obj port)\n(write-with-shared-structure obj port optarg)\n(write/ss obj)\n(write/ss obj port)\n(write/ss obj port optarg)" :description "|write-with-shared-structure| has been added to be compatible with \n,(link-srfi 38). It is is identical to |write*|, except that it accepts one \nmore parameter (|optarg|). This parameter, which is not specified \nin ,(srfi 38), is always ignored. |write/ss| is only a shorter name for\n|write-with-shared-structure|.\n" :similar ())

(display :type procedure :synopsis "(display obj)\n(display obj port)" :description "Writes a representation of |obj| to the given |port|. Strings that\nappear in the written representation are not enclosed in\ndoublequotes, and no characters are escaped within those\nstrings. Character objects appear in the representation as if\nwritten by |write-char| instead of by |write|. |Display| returns an\nunspecified value. The |port| argument may be omitted, in which\ncase it defaults to the value returned by |current-output-port|.\n£\n,(bold \"Rationale:\") |Write| is intended for producing machine-readable\noutput and |display| is for producing human-readable output. " :similar ())

(newline :type procedure :synopsis "(newline)\n(newline port)" :description "Writes an end of line to |port|. Exactly how this is done differs from\none operating system to another. Returns an unspecified value. The |port|\nargument may be omitted, in which case it defaults to the value returned\nby |current-output-port|." :similar ())

(write-char :type procedure :synopsis "(write-char char)\n(write-char char port)" :description "Writes the character |char| (not an external representation of the\ncharacter) to the given |port| and returns an unspecified value. \nThe |port| argument may be omitted, in which case it defaults to the\nvalue returned by |current-output-port|." :similar ())

(write-chars :type extended :synopsis "(write-chars str)\n(write-char str port)" :description "Writes the character of string |str| to the given |port| and\nreturns an unspecified value.  The |port| argument may be omitted,\nin which case it defaults to the value returned by\n|current-output-port|. ,(bold \"Note:\") This function is generally \nfaster than |display| for strings. Furthermore, this primitive does \nnot use the buffer associated to |port|.\n" :similar ())

(format :type extended :synopsis "(format port str obj ...)\n(format str obj)" :description "Writes the |obj|s to the given |port|, according to the format\nstring |str|. |Str| is written literally, except for the following \nsequences:\n\n,(itemize\n(item [|~a| or |~A| is replaced by the printed representation\nof the next |obj|.])\n\n(item [|~s| or |~S| is replaced by the ``slashified'' printed\nrepresentation of the next |obj|.])\n\n(item [|~w| or |~W| is replaced by the printed representation\nof the next |obj| (circular structures are correctly handled and\nprinted using |write*|).])\n\n(item [|~d| or |~D| is replaced by the decimal printed representation\nof the next |obj| (which must be a number).])\n\n(item [|~x| or |~X| is replaced by the hexadecimal printed representation\nof the next |obj| (which must be a number).])\n\n(item [|~o| or |~O| is replaced by the octal printed representation\nof the next |obj| (which must be a number).])\n\n(item [|~b| or |~B| is replaced by the binary printed representation\nof the next |obj| (which must be a number).])\n\n(item [|~c| or |~C| is replaced by the printed representation\nof the next |obj| (which must be a character).])\n\n(item [|~y| or |~Y| is replaced by the pretty-printed representation\nof the next |obj|. The standard pretty-printer is used here.])\n\n(item [|~?| is replaced by the result of the recursive call of |format|\nwith the two next |obj|.])\n\n(item [|~k| or |~K| is another name for |~?|])\n\n(item [|~\\[w\\[,d\\]\\]f| or |~\\[w\\[,d\\]\\]F| is replaced by the printed\nrepresentation of next |obj| (which must be a number) with width |w|\nand |d| digits after the decimal. Eventually, |d| may be omitted.])\n\n(item [|~~| is replaced by a single tilde character.])\n\n(item [|~%| is replaced by a newline])\n\n(item [|~t| or |~t| is replaced by a tabulation character.])\n\n(item [|~&| is replaced by a newline character if it is known that the\nprevious character was not a newline])\n\n(item [|~_| is replaced by a space])\n\n(item [|~h| or |~H| provides some help])\n\n)\n\n|Port| can be a boolean or a port. If |port| is |#t|, output goes to\nthe current output port; if |port| is |#f|, the output is returned as a\nstring.  Otherwise, the output is printed on the specified port.\n@lisp\n   (format #f \"A test.\")        => \"A test.\"\n   (format #f \"A ~a.\" \"test\")   => \"A test.\"\n   (format #f \"A ~s.\" \"test\")   => \"A \\\\\"test\\\\\".\"\n   (format \"~8,2F\" 1/3)         => \"    0.33\"\n   (format \"~6F\" 32)            => \"    32\"\n   (format \"~1,2F\" 4321)        => \"4321.00\"\n   (format \"~1,2F\" (sqrt -3.9)) => \"0.00+1.97i\"\n   (format \"#d~d #x~x #o~o #b~b~%\" 32 32 32 32)\n                                => \"#d32 #x20 #o40 #b100000\\\\n\"\n   (format #f \"~&1~&~&2~&~&~&3~%\")\n                                => \"1\\\\n2\\\\n3\\\\n\"\n   (format \"~a ~? ~a\" 'a \"~s\" '(new) 'test)\n                                => \"a new test\"\n@end lisp\n\n,(bold \"Note:\") The second form of |format| is compliant with \n,(link-srfi 28). That is, when\n|port| is omitted, the output is returned as a string as if |port| was \ngiven the value |#f|.\n£\n,(bold \"Note:\") Since version 0.58, |format| is also compliant with \n,(link-srfi 48)." :similar ())

(error :type extended :synopsis "(error str obj ...)\n(error name str obj ...)" :description "|error| is used to signal an error to the user. The second form \nof |error| takes  a symbol as first parameter; it is generally used for the \nname of the procedure which raises the error.\n£\n,(bold \"Note:\") The specification string may follow the \n,(emph \"tilde conventions\") \nof |format| (see ,(ref :mark \"format\")); in this case this procedure builds an \nerror message according to the specification given in |str|. Otherwise, \nthis procedure is conform to the |error| procedure defined in \n,(link-srfi 23) and  |str| is printed with the |display| procedure, \nwhereas the |obj|s are printed  with the |write| procedure. \n\n£\nHereafter, are some calls of the |error| procedure using a formatted string\n@lisp\n(error \"bad integer ~A\" \"a\")\n                     @print{} bad integer a\n(error 'vector-ref \"bad integer ~S\" \"a\") \n                     @print{} vector-ref: bad integer \"a\"\n(error 'foo \"~A is not between ~A and ~A\" \"bar\" 0 5)\n                     @print{} foo: bar is not between 0 and 5\n@end lisp\n\nand some conform to ,(srfi 23)\n@lisp\n(error \"bad integer\" \"a\")\n                    @print{} bad integer \"a\"\n(error 'vector-ref \"bad integer\" \"a\")\n                   @print{} vector-ref: bad integer \"a\"\n(error \"bar\" \"is not between\" 0 \"and\" 5)\n                   @print{} bar \"is not between\" 0 \"and\" 5\n@end lisp" :similar ())

(close-output-port :type procedure :synopsis "(close-input-port port)\n(close-output-port port)" :description "Closes the port associated with |port|, rendering the port incapable of\ndelivering or accepting characters. These routines have no effect if the\nport has already been closed. The value returned is ,(emph \"void\")." :similar (close-input-port))

(close-input-port :see close-output-port)
(close-port :type extended :synopsis "(close-port port)" :description "Closes the port associated with |port|." :similar ())

(port-closed? :type extended :synopsis "(port-closed? port)" :description "Returns |#t| if |port| is closed and |#f| otherwise." :similar ())

(read-line :type extended :synopsis "(read-line)\n(read-line port)" :description "Reads the next line available from the input port |port|. This function\nreturns 2 values: the first one is is the string which contains the line\nread, and the second one is the end of line delimiter. The end of line\ndelimiter can be an end of file object, a character or a string in case \nof a multiple character delimiter. If no more characters are available \non |port|, an end of file object is returned.  |Port| may be omitted, \nin which case it defaults to the value returned by |current-input-port|.\n£\n,(bold \"Note:\") As said in ,(ref :mark \"values\"), if |read-line| is not\nused in  the context of |call-with-values|, the second value returned by \nthis procedure is ignored." :similar ())

(copy-port :type extended :synopsis "(copy-port in out)\n(copy-port in out max)" :description "Copy the content of port |in|, which must be opened for readind, on\nport |out|, which must be opened for writing. If |max| is nont specified,\nAll the characters from the input port are copied on ouput port. If |max|\nis specified, it must be an integer indicatin the maximum number of characters\nwhich are copied from |in| to |out|." :similar ())

(flush-output-port :type extended :synopsis "(flush-output-port)\n(flush-output-port port)" :description "Flushes the buffer associated with the given output |port|. The\n|port| argument may be omitted, in which case it defaults to the value\nreturned by |current-output-port|" :similar ())

(port-current-line :type extended :synopsis "(port-current-line)\n(port-current-line port)" :description "Returns the current line number associated to the given input |port| as an\ninteger. The |port| argument may be omitted, in which case it defaults to\nthe value returned by |current-input-port|. \n£\n,(bold \"Note\"): The |port-seek|, |read-chars| and |read-chars!| procedures\ngenerally break the line-number. After using one of theses procedures, the \nvalue returned by |port-current-line| will be |-1| (except a |port-seek| \nat the beginning of the port reinitializes the line counter)." :similar ())

(port-current-position :type extended :synopsis "(port-current-position)\n(port-current-position port)" :description "Returns the position associated to the given input |port| as an\ninteger (i.e. number of characters from the beginning of the port). \nThe |port| argument may be omitted, in which case it defaults to\nthe value returned by |current-input-port|." :similar ())

(seek-file-port :type extended :synopsis "(port-seek port pos)\n(port-seek port pos whence)" :description "Sets the file position for the given |port| to the position |pos|.\nThe new position, measured in bytes, is obtained by adding |pos|\nbytes to the position specified by |whence|. If passed, |whence|\nmust be one of |:start|, |:current| or |:end|. The resulting\nposition is relative to the start of the file, the current position\nindicator, or end-of-file, respectively. If |whence| is omitted, it\ndefaults to |:start|.\n£\n,(bold \"Note\"): After using port-seek, the value returned by \n|port-current-line| may be incorrect. " :similar ())

(port-rewind :type extended :synopsis "(port-rewind port)" :description "Sets the port position to the beginning of |port|. The value returned by \n|port-rewind| is ,(emph \"void\")." :similar ())

(logger :type extended :synopsis "(logger str obj ...)" :description "TODO" :similar ())


;; Source file "print.c"


;; Source file "proc.c"

(procedure? :type procedure :synopsis "(procedure? obj)" :description "Returns |#t| if |obj| is a procedure, otherwise returns |#f|.\n\n@lisp\n(procedure? car)                            =>  #t\n(procedure? 'car)                           =>  #f\n(procedure? (lambda (x) (* x x)))           =>  #t\n(procedure? '(lambda (x) (* x x)))          =>  #f\n(call-with-current-continuation procedure?) =>  #t\n@end lisp" :similar ())

(closure? :type extended :synopsis "(closure? obj)" :description "Returns |#t| if |obj| is a procedure created with the |lambda| syntax and \n|#f| otherwise." :similar ())

(map :type procedure :synopsis "(map proc list1 list2 ...)" :description "The |list|s must be lists, and |proc| must be a procedure taking as many\narguments as there are lists and returning a single value.  \nIf more than one list is given, then they must all be the same length.  \n|Map| applies |proc| element-wise to the elements of the |list|s and returns \na list of the results, in order.  The dynamic order in which proc is applied\nto the elements of the lists is unspecified.\n@lisp\n(map cadr '((a b) (d e) (g h)))   =>  (b e h)\n\n(map (lambda (n) (expt n n))\n     '(1 2 3 4 5))                =>  (1 4 27 256 3125)\n\n(map + '(1 2 3) '(4 5 6))         =>  (5 7 9)\n\n(let ((count 0))\n  (map (lambda (ignored)\n      (set! count (+ count 1))\n      count)\n       '(a b)))                   =>  (1 2) ,(emph \"or\") (2 1)\n@end lisp" :similar ())

(for-each :type procedure :synopsis "(for-each proc list1 list2 ...)" :description "The arguments to |for-each| are like the arguments to |map|, but |for-each|\ncalls proc for its side effects rather than for its values.\nUnlike |map|, |for-each| is guaranteed to call proc on the elements of \nthe lists in order from the first element(s) to the last, and the value \nreturned by |for-each| is ,(emph \"void\").\n@lisp\n(let ((v (make-vector 5)))\n  (for-each (lambda (i)\n              (vector-set! v i (* i i)))\n            '(0 1 2 3 4))\n  v)                                =>  #(0 1 4 9 16)\n@end lisp" :similar ())


;; Source file "process.c"

(fork :type extended :synopsis "(fork)\n(fork thunk)" :description "This procedure is a wrapper around the standard Unix |fork| system\ncall which permits to create a new (heavy) process. \nWhen called without parameter, this procedure returns two times \n(one time in the parent process and one time in the child process). \nThe value returned in the parent process is a process object \nrepresenting the child process and the value returned in the child \nprocess is always the value |¤f|.\nWhen called with a parameter (which must be a thunk), the new process\nexcutes |thunk| and terminate it execution when |thunk| returns. The \nvalue returned in the parent process is a process object representing\nthe child process." :similar ())

(process? :type extended :synopsis "(process? obj)" :description "Returns |¤t| if |obj| is a process , otherwise returns |¤f|." :similar ())

(process-alive? :type extended :synopsis "(process-alive? proc)" :description "Returns |¤t| if process |proc| is currently running, otherwise returns |¤f|." :similar ())

(process-pid :type extended :synopsis "(process-pid proc)" :description "Returns an integer which represents the Unix identification (PID) of the \nprocessus." :similar ())

(process-list :type extended :synopsis "(process-list)" :description "Returns the list of processes which are currently running (i.e. alive)." :similar ())

(process-error :type extended :synopsis "(process-input proc)\n(process-output proc)\n(process-error proc)" :description "Returns the file port associated to the standard input, output or error\nof |proc|, if it is redirected in (or to) a pipe; otherwise\nreturns |¤f|. Note that the returned port is opened for reading\nwhen calling |process-output| or |process-error|; it is opened\nfor writing when calling |process-input|." :similar (process-output process-input))

(process-output :see process-error)
(process-input :see process-error)
(process-wait :type extended :synopsis "(process-wait proc)" :description "Stops the current process (the Scheme process) until |proc| completion. \n|Process-wait| returns |¤f| when |proc| is already terminated; it returns\n|¤t| otherwise. " :similar ())

(process-exit-status :type extended :synopsis "(process-exit-status proc)" :description "Returns the exit status of |proc| if it has finished its execution; \nreturns |¤f| otherwise." :similar ())

(process-send-signal :type extended :synopsis "(process-send-signal proc sig)" :description "Sends the integer signal |sig| to |proc|. Since value of |sig| is system\ndependant, use the symbolic defined signal constants to make your program \nindependant of the running system (see ,(ref :mark \"signals\")). \nThe result of |process-send-signal| is ,(emph \"void\")." :similar ())


;; Source file "promise.c"

(force :type procedure :synopsis "(force promise)" :description "Forces the value of |promise| (see ,(ref :mark \"delay\")). If no value has been\ncomputed for the promise, then a value is computed and\nreturned. The value of the promise is cached (or \"memoized\") so\nthat if it is forced a second time, the previously computed value\nis returned.\n\n@lisp\n(force (delay (+ 1 2)))        =>  3\n(let ((p (delay (+ 1 2))))\n  (list (force p) (force p)))  =>  (3 3)\n\n(define a-stream\n  (letrec ((next (lambda (n)\n                   (cons n (delay (next (+ n 1)))))))\n    (next 0)))\n(define head car)\n(define tail (lambda (stream) (force (cdr stream))))\n\n(head (tail (tail a-stream)))  =>  2\n@end lisp\n\n|Force| and |delay| are mainly intended for programs written in\nfunctional style. The following examples should not be considered\nto illustrate good programming style, but they illustrate the\nproperty that only one value is computed for a promise, no matter\nhow many times it is forced.\n@lisp\n(define count 0)\n(define p (delay (begin (set! count (+ count 1))\n                        (if (> count x)\n                            count\n                            (force p)))))\n(define x 5)\np                     =>  a promise\n(force p)             =>  6\np                     =>  a promise, still\n(begin (set! x 10)\n       (force p))     =>  6\n@end lisp\n,(bold \"Note:\") See R5RS for details on a posssible way to implement \n|force| and |delay|. " :similar ())

(promise? :type extended :synopsis "(promise? obj)" :description " Returns |#t| if |obj| is a promise, otherwise returns |#f|." :similar ())


;; Source file "read.c"

(read-case-sensitive :type extended :synopsis "(read-case-sensitive)\n(read-case-sensitive value)" :description "This parameter object permits to change the default behaviour of \nthe |read| primitive when reading a symbol. If this parameter has a \na true value a symbol is not converted to a default case when interned. \nSince ,(rfive) requires that symbol are case insignificant, the default \nvalue  of this parameter is ¤f.\n@lisp\n(read-case-sensitive)        => ¤f\n(define x 'Symbol)\n(display x)             @print{} symbol\n(read-case-sensitive ¤t)\n(define y 'Symbol)\n(display y)             @print{} Symbol\n@end lisp\n,(bold \"Note:\")  Default behaviour can be changed for a whole execution \nwith the |--case-sensitive| option.\n£\n,(bold \"Note:\") See also syntax for ,(ref :mark \"bar-in-symbol\" :text  \n[special characters]) in symbols.\n" :similar ())


;; Source file "regexp.c"

(string->regexp :type extended :synopsis "(string->regexp string)" :description "|String->regexp| takes a string representation of a regular\nexpression and compiles it into a regexp value. Other regular\nexpression procedures accept either a string or a regexp value as\nthe matching pattern. If a regular expression string is used\nmultiple times, it is faster to compile the string once to a regexp\nvalue and use it for repeated matches instead of using the string\neach time.  " :similar ())

(regexp? :type extended :synopsis "(regexp? obj) " :description "|Regexp| returns |#t| if |obj| is a regexp value created by the |regexp|, \notherwise |regexp| returns |#f|." :similar ())

(regexp-match-positions :type extended :synopsis "(regexp-match pattern str)\n(regexp-match-positions pattern str)" :description "These functions attempt to match |pattern| (a string or a regexp value) \nto |str|. If the match fails, |#f| is returned. If the match succeeds, \na list (containing strings for |regexp-match| and positions for \n|regexp-match-positions| is returned. The first string (or positions) in\nthis list is the portion of string that matched pattern. If two portions \nof string can match pattern, then the earliest and longest match is found,\nby default. \n\nAdditional strings or positions are returned in the list if pattern contains\nparenthesized sub-expressions; matches for the sub-expressions are provided\nin the order of the opening parentheses in pattern. \n@lisp\n(regexp-match-positions \"ca\" \"abracadabra\")\n                 => ((4 6))\n(regexp-match-positions \"CA\" \"abracadabra\")\n                 => #f\n(regexp-match-positions \"(?i)CA\" \"abracadabra\")\n                 => ((4 6))\n(regexp-match \"(a*)(b*)(c*)\" \"abc\")\n                 => (\"abc\" \"a\" \"b\" \"c\")\n(regexp-match-positions \"(a*)(b*)(c*)\" \"abc\")\n                 => ((0 3) (0 1) (1 2) (2 3))\n(regexp-match-positions \"(a*)(b*)(c*)\" \"c\")\n                 => ((0 1) (0 0) (0 0) (0 1))\n(regexp-match-positions \"(?<=\\\\\\\\d{3})(?<!999)foo\" \n                        \"999foo and 123foo\")\n     => ((14 17)) \n@end lisp" :similar (regexp-match))

(regexp-match :see regexp-match-positions)
(regexp-quote :type extended :synopsis "(regexp-quote str)" :description "Takes an arbitrary string and returns a string where characters of\n|str| that could serve as regexp metacharacters are escaped with a\nbackslash, so that they safely match only themselves.\n@lisp\n(regexp-quote \"cons\")       => \"cons\"\n(regexp-quote \"list?\")      => \"list\\\\\\\\?\"\n@end lisp\n|regexp-quote| is useful when building a composite regexp from\na mix of regexp strings and verbatim strings. " :similar ())


;; Source file "signal.c"


;; Source file "sio.c"


;; Source file "socket.c"

(make-server-socket :type extended :synopsis "(make-server-socket)\n(make-server-socket port-number)" :description "|make-server-socket| returns a new socket object. If |port-number|\nis specified, the socket is listening on the specified port; \notherwise, the communication port is chosen by the system. " :similar ())

(make-client-socket :type extended :synopsis " (make-client-socket hostname port-number)\n (make-client-socket hostname port_number line-buffered) " :description "|make-client-socket| returns a new socket object. This socket\nestablishes a link between the running program and the application\nlistening on port |port-number| of |hostname|.  If  the optional argument\n|line-buffered| has a true value, a line buffered policy is used when writing \nto the client socket (i.e. characters on the socket are tranmitted as soon \nas a ,(code \"#\\\\newline\") character is encountered). The default value of \n|line-buffered| is |#t|.\n" :similar ())

(socket-shutdown :type extended :synopsis "(socket-shutdown sock)\n(socket-shutdown sock close)" :description "|Socket-shutdown| shutdowns the connection associated to\n|socket|. If the socket is a server socket, |socket-shutdown| is called\non all the client sockets connected to this server.\n|Close| indicates if the the socket must be closed or not, when\nthe connection is destroyed. Closing the socket forbids further \nconnections on the same port with the |socket-accept| procedure.\nOmitting a value for |close| implies the closing of socket.\n£\nThe following example shows a simple server: when there is \na new connection on the port number 12345, the server displays \nthe first line sent to it by the client, discards the others and\ngo back waiting for further client connections.\n@lisp\n(let ((s (make-server-socket 12345)))\n   (let loop ()\n      (let ((ns (socket-accept s)))\n        (format #t \"I've read: ~A\\\\n\" \n                (read-line (socket-input ns)))\n        (socket-shutdown ns #f)\n        (loop))))\n@end lisp" :similar ())

(socket-accept :type extended :synopsis "(socket-accept socket)\n(socket-accept socket line-buffered)" :description "|socket-accept| waits for a client connection on the given\n|socket|. If no client is already waiting for a connection, this\nprocedure blocks its caller; otherwise, the first connection request \non the queue of pending connections is connected and |socket-accept| \nreturns a new client socket to serve this request. \nThis procedure must be called on a server socket created\nwith |make-server-socket|. The result of |socket-accept| is undefined. \n|Line-buffered| indicates if the port should be considered as a \nline buffered. If |line-buffered| is omitted, it defaults to |#t|.\n£\nThe following example is a simple server which waits for a connection\non the port 12345 ,(footnote [Under Unix, you can simply connect to\na listening socket with the |telnet| command. With the given\nexample, this can be achieved by typing the following command in a \nwindow shell: \n,(raw-code \"$ telnet localhost 12345\")]).\n Once the connection with the\ndistant program is established, we read a line on the input port\nassociated to the socket and we write the length of this line on its\noutput port. \n@lisp\n(let* ((server (make-server-socket 13345))\n       (client (socket-accept server))\n       (l      (read-line (socket-input client))))\n  (format (socket-output client) \n          \"Length is: ~a\\n\" (string-length l))\n  (socket-shutdown server))\n@end lisp\n\n Note that shutting down the |server| socket suffices here to close\nalso the connection to |client|. " :similar ())

(socket? :type extended :synopsis "(socket? obj)" :description "Returns |#t| if |socket| is a socket, otherwise returns |#f|." :similar ())

(socket-client? :type extended :synopsis "(socket-client? obj)" :description "Returns |#t| if |socket| is a client socket, otherwise returns |#f|." :similar ())

(socket-server? :type extended :synopsis "(socket-server? obj)" :description "Returns |#t| if |socket| is a server socket, otherwise returns |#f|." :similar ())

(socket-port-number :type extended :synopsis "(socket-port-number socket)" :description "Returns the integer number of the port used for |socket|." :similar ())

(socket-output :type extended :synopsis "(socket-input socket)\n(socket-output socket)" :description "Returns the file port associated for reading or writing with the\nprogram connected with |socket|. If no connection has already been\nestablished, these functions return |#f|.\n\nThe following example shows how to make a client socket. Here we\ncreate a socket on port 13 of the machine |kaolin.unice.fr|,(footnote\n[Port 13 is generally used for testing:\nmaking a connection to it permits to know the distant system's idea\nof the time of day.]):\n@lisp\n(let ((s (make-client-socket \"kaolin.unice.fr\" 13)))\n  (format #t \"Time is: ~A~%\" (read-line (socket-input s)))\n  (socket-shutdown  s))\n@end lisp" :similar (socket-input))

(socket-input :see socket-output)
(socket-host-name :type extended :synopsis "(socket-host-name socket)" :description "Returns a string which contains the name of the distant host\nattached to |socket|. If |socket| has been created with\n|make-client-socket| this procedure returns the official name of\nthe distant machine used for connection. If |socket| has been\ncreated with |make-server-socket|, this function returns the\n official name of the client connected to the socket. If no client\nhas used yet |socket|, this function returns |#f|.  " :similar ())

(socket-host-address :type extended :synopsis "(socket-host-address socket)" :description "Returns a string which contains the IP number of the distant host\nattached to |socket|. If |socket| has been created with\n|make-client-socket| this procedure returns the IP number of the\ndistant machine used for connection. If |socket| has been created\nwith |make-server-socket|, this function returns the address of the\nclient connected to the socket.  If no client has used yet\n|socket|, this function returns |#f|.  " :similar ())

(socket-local-address :type extended :synopsis "(socket-local-address socket)" :description "Returns a string which contains the IP number of the local host \nattached to |socket|." :similar ())


;; Source file "sport.c"

(open-input-string :type extended :synopsis "(open-input-string str)" :description "Returns an input string port capable of delivering characters from\n|str|." :similar ())

(open-output-string :type extended :synopsis "(open-output-string)" :description "Returns an output string port capable of receiving and collecting characters." :similar ())

(get-output-string :type extended :synopsis "(get-output-string port)" :description "Returns a string containing all the text that has been written on the\noutput string |port|.\n@lisp\n (let ((p (open-output-string)))\n    (display \"Hello, world\" p)\n    (get-output-string p))         => \"Hello, world\"\n@end lisp" :similar ())

(output-string-port? :type extended :synopsis "(input-string-port? obj)\n(output-string-port? obj)" :description "Returns |#t| if |obj| is an input string port or output string port \nrespectively, otherwise returns #f." :similar (input-string-port?))

(input-string-port? :see output-string-port?)

;; Source file "stklos.c"


;; Source file "str.c"

(string? :type procedure :synopsis "(string? obj)" :description "Returns |#t| if |obj| is a string, otherwise returns |#f|." :similar ())

(make-string :type procedure :synopsis "(make-string k)\n(make-string k char)" :description "|Make-string| returns a newly allocated string of length |k|. If |char| is\ngiven, then all elements of the string are initialized to |char|, otherwise\nthe contents of the string are unspecified." :similar ())

(string :type procedure :synopsis "(string char ...)" :description "Returns a newly allocated string composed of the arguments." :similar ())

(string-length :type procedure :synopsis "(string-length string)" :description "Returns the number of characters in the given |string|." :similar ())

(string-ref :type procedure :synopsis "(string-ref string k)" :description "|String-ref| returns character k of string using zero-origin indexing\n(|k| must be a valid index of string)." :similar ())

(string-set! :type procedure :synopsis "(string-set! string k char)" :description "|String-set!| stores |char| in element |k| of |string| and returns \n,(emph \"void\") (|k| must be a valid index of |string|). \n\n@lisp\n(define (f) (make-string 3 #\\*))\n(define (g) \"***\")\n(string-set! (f) 0 #\\?)  =>  void\n(string-set! (g) 0 #\\?)  =>  error\n(string-set! (symbol->string 'immutable) 0 #\\?)  \n                         =>  error\n@end lisp" :similar ())

(string-ci=? :type procedure :synopsis "(string=? string1 string2)\n(string-ci=? string1 string2)" :description "Returns |#t| if the two strings are the same length and contain the same\ncharacters in the same positions, otherwise returns |#f|. |String-ci=?|\ntreats upper and lower case letters as though they were the same character,\nbut |string=?| treats upper and lower case as distinct characters." :similar (string=?))

(string=? :see string-ci=?)
(string-ci>=? :type procedure :synopsis "(string<? string1 string2)\n(string>? string1 string2)\n(string<=? string1 string2)\n(string>=? string1 string2)\n(string-ci<? string1 string2)\n(string-ci>? string1 string2)\n(string-ci<=? string1 string2)\n(string-ci>=? string1 string2)" :description "These procedures are the lexicographic extensions to strings of the\ncorresponding orderings on characters. For example, |string<?| is the\nlexicographic ordering on strings induced by the ordering |char<?| on\ncharacters. If two strings differ in length but are the same up to the\nlength of the shorter string, the shorter string is considered to be\nlexicographically less than the longer string.\n" :similar (string-ci>? string-ci<=? string-ci<? string>=? string>? string<=? string<?))

(string-ci>? :see string-ci>=?)
(string-ci<=? :see string-ci>=?)
(string-ci<? :see string-ci>=?)
(string>=? :see string-ci>=?)
(string>? :see string-ci>=?)
(string<=? :see string-ci>=?)
(string<? :see string-ci>=?)
(substring :type procedure :synopsis "(substring string start end)" :description "|String| must be a string, and |start| and |end| must be exact integers \nsatisfying\n@lisp\n0 <= start <= end <= (string-length string).\n@end lisp\n|Substring| returns a newly allocated string formed from the characters\nof |string| beginning with index |start| (inclusive) and ending with\nindex |end| (exclusive)." :similar ())

(string-append :type procedure :synopsis "(string-append string ...)" :description "Returns a newly allocated string whose characters form the concatenation\nof the given strings." :similar ())

(list->string :type procedure :synopsis "(string->list string)\n(list->string list)" :description "|String->list| returns a newly allocated list of the characters that make\nup the given string. |List->string| returns a newly allocated string \nformed from the characters in the list |list|, which must be a list of\ncharacters. |String->list| and |list->string| are inverses so far as\n|equal?| is concerned." :similar (string->list))

(string->list :see list->string)
(string-copy :type procedure :synopsis "(string-copy string)" :description "Returns a newly allocated copy of the given |string|." :similar ())

(string-fill! :type extended :synopsis "(string-fill! string char)" :description "Stores |char| in every element of the given |string| and returns ,(emph \"void\")." :similar ())

(string-find? :type extended :synopsis "(string-find? str1 str2)" :description "Returns |#t| if |str1| appears somewhere in |str2|; otherwise returns |#f|." :similar ())

(string-index :type extended :synopsis "(string-index str1 str2)" :description "Returns the (first) index where |str1| is a substring of |str2| if it exists;\notherwise returns |#f|.\n@lisp\n(string-index \"ca\" \"abracadabra\") =>  4\n(string-index \"ba\" \"abracadabra\") =>  #f\n@end lisp" :similar ())

(string-split :type extended :synopsis "(string-split str)\n(string-split str delimiters)" :description "parses |string| and returns a list of tokens ended by a character of the\n|delimiters| string. If |delimiters| is omitted, it defaults to a string \ncontaining a space, a tabulation and a newline characters. \n@lisp\n(string-split \"/usr/local/bin\" \"/\") \n                       => (\"usr\" \"local\" \"bin\")\n(string-split \"once   upon a time\") \n                       => (\"once\" \"upon\" \"a\" \"time\")\n@end lisp" :similar ())

(string-mutable? :type extended :synopsis "(string-mutable? obj)" :description "Returns |#t| if |obj| is a mutable string, otherwise returns |#f|. \n@lisp\n(string-mutable? \"abc\")                => #f\n(string-mutable? (string-copy \"abc\"))  => #t\n(string-mutable? (string #\\a #\\b #\\c)) => #t\n(string-mutable? 12)                   => #f\n@end lisp" :similar ())

(string-downcase :type extended :synopsis "(string-downcase str)\n(string-downcase str start)\n(string-downcase str start end)" :description "Returns a string in which the upper case letters of string |str| between the \n|start| and |end| indices have been replaced by their lower case equivalent.\nIf |start| is omited, it defaults to 0. If |end| is omited, it defaults to\nthe length of |str|. \n@lisp\n(string-downcase \"Foo BAR\")        => \"foo bar\"\n(string-downcase \"Foo BAR\" 4)      => \"bar\"\n(string-downcase \"Foo BAR\" 4 6)    => \"ba\"\n@end lisp" :similar ())

(string-downcase! :type extended :synopsis "(string-downcase! str)\n(string-downcase! str start)\n(string-downcase! str start end)" :description "This is the in-place side-effecting variant of |string-downcase|. \n@lisp\n(string-downcase! (string-copy \"Foo BAR\") 4)    => \"Foo bar\"\n(string-downcase! (string-copy \"Foo BAR\") 4 6)  => \"Foo baR\"\n@end lisp" :similar ())

(string-upcase :type extended :synopsis "(string-upcase str)\n(string-upcase str start)\n(string-upcase str start end)" :description "Returns a string in which the lower case letters of string |str| between the \n|start| and |end| indices have been replaced by their upper case equivalent.\nIf |start| is omited, it defaults to 0. If |end| is omited, it defaults to\nthe length of |str|. " :similar ())

(string-upcase! :type extended :synopsis "(string-upcase! str)\n(string-upcase! str start)\n(string-upcase! str start end)" :description "This is the in-place side-effecting variant of |string-upcase|. " :similar ())

(string-titlecase :type extended :synopsis "(string-titlecase str)\n(string-titlecase str start)\n(string-titlecase str start end)" :description "This function returns a string.  For every character |c| in the\nselected range of |str|, if |c| is preceded by a cased character, it\nis downcased; otherwise it is titlecased. If |start| is omited, it \ndefaults to 0. If |end| is omited, it defaults to the length of |str|. \nNote that if a |start| index is specified, then the character preceding\n|s[start]| has no effect on the titlecase decision for character |s[start]|.\n@lisp\n(string-titlecase \"--capitalize tHIS sentence.\") \n         =>  \"--Capitalize This Sentence.\"\n(string-titlecase \"see Spot run. see Nix run.\") \n         =>  \"See Spot Run. See Nix Run.\"\n(string-titlecase \"3com makes routers.\") \n         =>  \"3Com Makes Routers.\"\n(string-titlecase \"greasy fried chicken\" 2) \n         => \"Easy Fried Chicken\"\n@end lisp" :similar ())

(string-titlecase! :type extended :synopsis "(string-titlecase! str)\n(string-titlecase! str start)\n(string-titlecase! str start end)" :description "This is the in-place side-effecting variant of |string-titlecase|. " :similar ())


;; Source file "struct.c"

(make-struct-type :type extended :synopsis "(make-struct-type name parent slots)" :description "This form which is more general than |define-struct| permits to define a \nnew structure type whose name is |name|. Parent is the structure \ntype from which is the new structure type is a subtype (or |¤f| is the \nnew structure-type has no super type). |Slots| is the list of the slot \nnames which constitute the structure tpe. \n£\nWhen a structure type is s subtype of a previous type, its slots are added \nto the ones of the super type. " :similar ())

(struct-type? :type extended :synopsis "(struct-type? obj)" :description "Returns |¤t| if |obj| is a structure type, otherwise return |#f|.\n@lisp\n(let ((type (make-struct-type 'point #f '(x y))))\n  (struct-type? type))         => #t\n@end lisp" :similar ())

(struct-type-slots :type extended :synopsis "(struct-type-slots structype)" :description "Returns the slots of the structure type |structype| as a list.\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define circle (make-struct-type 'circle point '(r)))\n(struct-type-slots point)   => (x y) \n(struct-type-slots circle)  => (x y r)\n@end lisp" :similar ())

(struct-type-parent :type extended :synopsis "(struct-type-parent structype)" :description "Returns the super type of the structure type |structype|, if it exists \nor |#f| otherwise." :similar ())

(struct-type-name :type extended :synopsis "(struct-type-name structype)" :description "Returns the name associated to the structure type |structype|." :similar ())

(struct-type-change-writer! :type extended :synopsis "(struct-type-change-writer! structype proc)" :description "Change the default writer associated to structures of type |structype| to \nto the |proc| procedure. The |proc| procedure must accept 2 arguments \n(the structure to write and the port wher the structure must be written \nin that order). The value returned by |struct-type-change-writer!| is the\nold writer associated to |structype|. To restore the standard wtructure \nwriter for |structype|, use the special value |#f|.\n\n@lisp\n(define point (make-struct-type 'point #f '(x y)))\n\n(struct-type-change-writer!\n  point\n  (lambda (s port)\n    (let ((type (struct-type s)))\n      (format port \"{~A\" (struct-type-name type))\n      ;; display the slots and their value\n      (for-each (lambda (x)\n\t\t  (format port \" ~A=~S\" x (struct-ref s x)))\n\t\t(struct-type-slots type))\n      (format port \"}\"))))\n(display (make-struct point 1 2)) @print{} {point x=1 y=2}\n@end lisp" :similar ())

(make-struct :type extended :synopsis "(make-struct structype expr ...)" :description "Returns a newly allocated instance of the structure type |structype|, \nwhose slots are initialized to |expr| ... If fewer |expr| than the number of \ninstances are given to |make-struct|, the remaining slots are inialized with \nthe special ,(emph \"void\") value." :similar ())

(struct? :type extended :synopsis "(struct? obj)" :description "Returns |¤t| if |obj| is a structure, otherwise return |#f#|.\n@lisp\n(let* ((type (make-struct-type 'point #f '(x y)))\n       (inst (make-struct type 1 2)))\n  (struct? inst))         => #t\n@end lisp" :similar ())

(struct-type :type extended :synopsis "(struct-type s)" :description "Returns the structure type of the |s| structure" :similar ())

(struct-ref :type extended :synopsis "(struct-ref s slot-name)" :description "Returns the value associated to slot |slot-name| of the |s| structure.\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define circle (make-struct-type 'circle point '(r)))\n(define p (make-struct point 1 2))\n(define c (make-struct circle 10 20 30))\n(struct-ref p 'y) => 2\n(struct-ref c 'r) => 30\n@end lisp" :similar ())

(struct-set! :type extended :synopsis "(struct-set! s slot-name value)" :description "Stores value in the to slot |slot-name| of the |s| structure. The value \nreturned by |struct-set!| is ,(emph \"void\").\n\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define p (make-struct point 1 2))\n(struct-ref p 'x) => 1\n(struct-set! p 'x 0)\n(struct-ref p 'x) => 0\n@end lisp" :similar ())

(struct-is-a? :type extended :synopsis "(struct-is-a? s structype)" :description "Return a boolean that indicates if the structure |s| is a of type |structype|.\nNote that if |s| is an instance of a subtype of ,(emph \"S\"), it is considered\nalso as an instance of type ,(emph \"S\").\n\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define circle (make-struct-type 'circle point '(r))) \n(define p (make-struct point 1 2))\n(define c (make-struct circle 10 20 30))\n(struct-is-a? p point)   => #t\n(struct-is-a? c point)   => #t\n(struct-is-a? p circle)  => #f\n(struct-is-a? c circle)  => #t\n@end lisp" :similar ())

(struct->list :type extended :synopsis "(struct->list s)" :description "Returns the content of structure |s| as an A-list whose keys are the \nslots of the structure type of |s|.\n@lisp\n(define point  (make-struct-type 'point #f '(x y)))\n(define p (make-struct point 1 2))\n(struct->list p) => ((x . 1) (y . 2))\n@end lisp" :similar ())


;; Source file "symbol.c"

(symbol? :type procedure :synopsis "(symbol? obj)" :description "Returns |#t| if obj is a symbol, otherwise returns |#f|.\n@lisp\n   (symbol? 'foo)          =>  #t\n   (symbol? (car '(a b)))  =>  #t\n   (symbol? \"bar\")         =>  #f\n   (symbol? 'nil)          =>  #t\n   (symbol? '())           =>  #f\n   (symbol? #f)            =>  #f\n   (symbol? :key)          =>  #f\n@end lisp" :similar ())

(symbol->string :type procedure :synopsis "(symbol->string string)" :description "Returns the name of |symbol| as a string. If the symbol was part of an\nobject returned as the value of a literal expression or by a call to the \n|read| procedure, and its name contains alphabetic characters, then the\nstring returned will contain characters in the implementation's preferred \nstandard case -- STklos prefers lower case. If the symbol was returned \nby |string->symbol|, the case of characters in the string returned will be\nthe same as the case in the string that was passed to |string->symbol|. It\nis an error to apply mutation procedures like |string-set!| to strings \nreturned by this procedure.\n@lisp\n   (symbol->string 'flying-fish)  =>  \"flying-fish\"\n   (symbol->string 'Martin)       =>  \"martin\"\n   (symbol->string (string->symbol \"Malvina\"))\n                                  =>  \"Malvina\"\n@end lisp" :similar ())

(string->symbol :type procedure :synopsis "(string->symbol string)" :description "Returns the symbol whose name is |string|. This procedure can create \nsymbols with names containing special characters or letters in the \nnon-standard case, but it is usually a bad idea to create such symbols \nbecause in some implementations of Scheme they cannot be read as themselves. \n\n@lisp\n   (eq? 'mISSISSIppi 'mississippi)     =>  #t\n   (string->symbol \"mISSISSIppi\")      =>  @pipemISSISSIppi@pipe\n   (eq? 'bitBlt (string->symbol \"bitBlt\"))\n                                       =>  #f\n   (eq? 'JollyWog\n        (string->symbol\n          (symbol->string 'JollyWog))) =>  #t\n   (string=? \"K. Harper, M.D.\"\n             (symbol->string\n               (string->symbol \"K. Harper, M.D.\")))\n                                       =>  #t\n@end lisp" :similar ())

(string->uninterned-symbol :type extended :synopsis "(string->unterned-symbol string)" :description "Returns the symbol whose print name is made from the characters of\n|string|. This symbol is guaranteed to be ,(emph \"unique\") (i.e. not\n|eq?| to any other symbol):\n@lisp\n(let ((ua (string->uninterned-symbol \"a\")))\n  (list (eq? 'a ua)\n        (eqv? 'a ua)\n        (eq? ua (string->uninterned-symbol \"a\"))\n        (eqv? ua (string->uninterned-symbol \"a\"))))\n          => (#f #t #f #t)\n@end lisp" :similar ())


;; Source file "system.c"

(winify-file-name :type extended :synopsis "(winify-file-name fn)" :description "On Win32 system, when compiled with the Cygwin environment,\nfile names are internally represented in a POSIX-like internal form.\n|Winify-file-bame| permits to obtain back the Win32 name of an interned \nfile name\n@lisp\n(winify-file-name \"/tmp\")\n    => \"C:\\\\\\\\cygwin\\\\\\\\tmp\"\n(list (getcwd) (winify-file-name (getcwd)))\n    => (\"//saxo/homes/eg/Projects/STklos\"\n        \"\\\\\\\\\\\\\\\\saxo\\\\\\\\homes\\\\\\\\eg\\\\\\\\Projects\\\\\\\\STklos\")\n@end lisp" :similar ())

(posixify-file-name :type extended :synopsis "(posixify-file-name fn)" :description "On Win32 system, when compiled with the Cygwin environment,\nfile names are internally represented in a POSIX-like internal form.\n|posixify-file-bame| permits to obtain the interned file name from \nits external form.\nfile name\n@lisp\n(posixify-file-name \"C:\\\\\\\\cygwin\\\\\\\\tmp\")\n       => \"/tmp\"\n@end lisp" :similar ())

(expand-file-name :type extended :synopsis "(expand-file-name path)" :description "|Expand-file-name| expands the filename given in |path| to\nan absolute path. \n@lisp\n  ;; Current directory is ~eg/stklos (i.e. /users/eg/stklos)\n  (expand-file-name \"..\")            => \"/users/eg\"\n  (expand-file-name \"~eg/../eg/bin\") => \"/users/eg/bin\"\n  (expand-file-name \"~/stklos)\"      => \"/users/eg/stk\"\n@end lisp " :similar ())

(canonical-file-name :type extended :synopsis "(canonical-file-name path)" :description "Expands all symbolic links in |path| and returns its canonicalized\nabsolute path name. The resulting path does not have symbolic links. \nIf |path| doesn't designate a valid path name, |canonical-file-name| \nreturns |¤f|." :similar ())

(getcwd :type extended :synopsis "(getcwd)" :description "Returns a string containing the current working directory." :similar ())

(chdir :type extended :synopsis "(chdir dir)" :description "Changes the current directory to the directory given in string |dir|." :similar ())

(getpid :type extended :synopsis "(getpid)" :description "Returns the system process number of the current program (i.e. the\nUnix ,(emph \"pid\")) as an integer." :similar ())

(system :type extended :synopsis "(system string)" :description "Sends the given |string| to the system shell |/bin/sh|. The result of\n|system| is the integer status code the shell returns." :similar ())

(file-exists? :type extended :synopsis "(file-is-directory?  string)\n(file-is-regular?    string)\n(file-is-readable?   string)\n(file-is-writable?   string)\n(file-is-executable? string)\n(file-exists?        string)" :description "Returns |#t| if the predicate is true for the path name given in\n|string|; returns |#f| otherwise (or if |string| denotes a file\nwhich does not exist)." :similar (file-is-executable? file-is-readable? file-is-writable? file-is-regular? file-is-directory?))

(file-is-executable? :see file-exists?)
(file-is-readable? :see file-exists?)
(file-is-writable? :see file-exists?)
(file-is-regular? :see file-exists?)
(file-is-directory? :see file-exists?)
(file-size :type extended :synopsis "(file-size string)" :description "Returns the size of the file whose path name is given in\n|string|.If |string| denotes a file which does not exist, \n|file-size| returns |#f|." :similar ())

(glob :type extended :synopsis "(glob pattern ...)" :description "|Glob| performs file name ``globbing'' in a fashion similar to the \ncsh shell. |Glob| returns a list of the filenames that match at least\none of |pattern| arguments.  The |pattern| arguments may contain\nthe following special characters:\n,(itemize \n(item [|?| Matches any single character.])\n(item [|*| Matches any sequence of zero or more characters.])\n(item [|\\[chars\\]| Matches any single character in |chars|. \nIf chars contains a sequence of the form |a-b| then any character \nbetween |a| and |b| (inclusive) will match.])\n(item [|\\\\x| Matches the character |x|.])\n(item [|{a,b,...}| Matches any of the strings |a|, |b|, etc.])\n)\n\nAs with csh, a '.' at the beginning of a file's name or just after \na '/ must be matched explicitly or with a |@{@}| construct.  \nIn addition, all '/' characters must be matched explicitly.\n£\nIf the first character in a pattern is '~' then it refers to\nthe home directory of the user whose name follows the '~'.\nIf the '~' is followed immediately by `/' then the value of\nthe environment variable HOME is used.\n£\n|Glob| differs from csh globbing in two ways.  First, it does not\nsort its result list (use the |sort| procedure if you want the list\nsorted).\nSecond, |glob| only returns the names of files that actually exist; \nin csh no check for existence is made unless a pattern contains a \n|?|, |*|, or |\\[\\]| construct." :similar ())

(remove-file :type extended :synopsis "(remove-file string)" :description "Removes the file whose path name is given in |string|.\nThe result of |remove-file| is ,(emph \"void\")." :similar ())

(rename-file :type extended :synopsis "(rename-file string1 string2)" :description "Renames the file whose path-name is |string1| to a file whose path-name is\n|string2|. The result of |rename-file| is ,(emph \"void\")." :similar ())

(copy-file :type extended :synopsis "(copy-file string1 string2)" :description "Copies the file whose path-name is |string1| to a file whose path-name is\n|string2|. If the file |string2| already exists, its content prior \nthe call to |copy-file| is lost. The result of |copy-file| is ,(emph \"void\")." :similar ())

(temporary-file-name :type extended :synopsis "(temporary-file-name)" :description "Generates a unique temporary file name. The value returned by\n|temporary-file-name| is the newly generated name of |#f|\nif a unique name cannot be generated." :similar ())

(register-exit-function! :type extended :synopsis "(register-exit-function! proc)" :description "This function registers |proc| as an exit function. This function will \nbe called when the program exits. When called, |proc| will be passed one \nparmater which is the status given to the |exit| function. The result of \n|register-exit-function!| is undefined. \n@lisp\n(let* ((tmp (temporary-file-name))\n       (out (open-output-file tmp)))\n  (register-exit-function! (lambda (n)\n                             (when (zero? n)\n                               (remove-file tmp))))\n  out)\n@end lisp" :similar ())

(exit :type extended :synopsis "(exit) \n(exit ret-code)" :description "Exits the program with the specified integer return code. If |ret-code|\nis omitted, the program terminates with a return code of 0.\nIf  program has registerd exit functions with |register-exit-function!|, \nthey are called (in an order which is the reverse of their call order)." :similar ())

(machine-type :type extended :synopsis "(machine-type)" :description "Returns a string identifying the kind of machine which is running the\nprogram. The result string is of the form \n|[os-name]-[os-version]-[processor-type]|." :similar ())

(date :type extended :synopsis "(date)" :description "Returns the current date in a string" :similar ())

(clock :type extended :synopsis "(clock)" :description "Returns an approximation of processor time, in milliseconds, used so far by the\nprogram." :similar ())

(current-time :type extended :synopsis "(current-time)" :description "Returns the time since the Epoch (that is 00:00:00 UTC, January 1, 1970), \nmeasured in seconds." :similar ())

(full-current-time :type extended :synopsis "(full-current-time)" :description "Returns the time of the day as a pair where \n,(itemize\n(item [the  first element is the time since the Epoch \n(that is 00:00:00 UTC, January 1, 1970),  measured in seconds. ])\n\n(item [the second element is the number of microseconds in the given \nsecond.])\n)" :similar ())

(sleep :type extended :synopsis "(sleep n)" :description "Suspend the execution of the program for at |ms| milliseconds. Note that due \nto system clock resolution, the pause may be a little bit longer. If a\nsignal arrives during the pause, the execution may be resumed. \n" :similar ())

(seconds->date :type extended :synopsis "(seconds->date n)" :description "Convert the date |n| expressed as a number of seconds since the Epoch\nto a date." :similar ())

(date->seconds :type extended :synopsis "(date->seconds d)" :description "Convert the date |d| to the number of seconds since the ,(emph \"Epoch\")." :similar ())

(running-os :type extended :synopsis "(running-os)" :description "Returns the name of the underlying Operating System which is running \nthe program. \nThe value returned by |runnin-os| is a symbol. For now, this procedure \nreturns either |unix|, |windows|, or |cygwin-windows|." :similar ())

(getenv :type extended :synopsis "(getenv str)\n(getenv)" :description "Looks for the environment variable named |str| and returns its\nvalue as a string, if it exists. Otherwise, |getenv| returns |#f|.\nIf |getenv| is called without parameter, it returns the list of \nall the environment variables accessible from the program as an \nA-list.\n@lisp\n(getenv \"SHELL\")   \n     => \"/bin/zsh\"\n(getenv)\n     => ((\"TERM\" . \"xterm\") (\"PATH\" . \"/bin:/usr/bin\") ...)\n@end lisp" :similar ())

(setenv! :type extended :synopsis "(setenv! var value)" :description "Sets the environment variable |var| to |value|. |Var| and\n|value| must be strings. The result of |setenv!| is ,(emph \"void\")." :similar ())

(unsetenv! :type extended :synopsis "(setenv! var)" :description "Unsets the environment variable |var|. |Var|   must be a strings. \nThe result of |unsetenv!| is ,(emph \"void\")." :similar ())

(hostname :type extended :synopsis "(hostname)" :description "Return the  host name of the current processor as a string." :similar ())


;; Source file "uvector.c"


;; Source file "vector.c"

(vector? :type procedure :synopsis "(vector? obj)" :description "Returns |#t| if |obj| is a vector, otherwise returns |#f|." :similar ())

(make-vector :type procedure :synopsis "(make-vector k)\n(make-vector k fill)" :description "Returns a newly allocated vector of |k| elements. If a second argument is\ngiven, then each element is initialized to |fill|. Otherwise the initial \ncontents of each element is unspecified." :similar ())

(vector :type procedure :synopsis "(vector obj ...)" :description "Returns a newly allocated vector whose elements contain the given arguments. \nAnalogous to |list|.\n\n@lisp\n(vector 'a 'b 'c)               =>  #(a b c)\n@end lisp" :similar ())

(vector-length :type procedure :synopsis "(vector-length vector)" :description "Returns the number of elements in |vector| as an exact integer." :similar ())

(vector-ref :type procedure :synopsis "(vector-ref vector k)" :description "|k| must be a valid index of |vector|. |Vector-ref| returns the contents of\nelement |k| of vector.\n@lisp\n(vector-ref '#(1 1 2 3 5 8 13 21)\n            5)         =>  8\n(vector-ref '#(1 1 2 3 5 8 13 21)\n            (let ((i (round (* 2 (acos -1)))))\n              (if (inexact? i)\n                  (inexact->exact i)\n                  i))) => 13\n@end lisp" :similar ())

(vector-set! :type procedure :synopsis "(vector-set! vector k obj)" :description "|k| must be a valid index of |vector|. |Vector-set!| stores |obj| in element\n|k| of |vector|. The value returned by |vector-set!| is ,(emph \"void\").\n\n@lisp\n(let ((vec (vector 0 '(2 2 2 2) \"Anna\")))\n  (vector-set! vec 1 '(\"Sue\" \"Sue\"))\n  vec)      =>  #(0 (\"Sue\" \"Sue\") \"Anna\")\n\n(vector-set! '#(0 1 2) 1 \"doe\")  =>  error  ; constant vector\n@end lisp" :similar ())

(list->vector :type procedure :synopsis "(vector->list vector)\n(list->vector list)" :description "|Vector->list| returns a newly allocated list of the objects contained in\nthe elements of |vector|. |List->vector| returns a newly created vector\ninitialized to the elements of the list |list|.\n\n@lisp\n(vector->list '#(dah dah didah))  =>  (dah dah didah)\n(list->vector '(dididit dah))     =>  #(dididit dah)\n@end lisp" :similar (vector->list))

(vector->list :see list->vector)
(vector-fill! :type procedure :synopsis "(vector-fill! vector fill)" :description "Stores |fill| in every element of |vector|. The value returned by\n|vector-fill!| is ,(emph \"void\")." :similar ())

(vector-copy :type extended :synopsis "(vector-copy v)" :description "Return a copy of vectot |v|. Note that, if |v| is a constant vector, \nits copy is not constant. " :similar ())

(vector-resize :type extended :synopsis "(vector-resize v size)\n(vector-resize v size fill)" :description "Returns a copy of v of the given |size|. If |size| is greater\nthan the vector size of |v|, the contents of the newly allocated vector cells\nis  set to the value of |fill|. If |fill| is omitted the content of the \nnew cells is ,(emph \"void\")." :similar ())

(vector-mutable? :type extended :synopsis "(vector-mutable? obj)" :description "Returns |#t| if |obj| is a mutable vector, otherwise returns |#f|. \n@lisp\n(vector-mutable? '#(1 2 a b))            => #f\n(vector-mutable? (vector-copy '#(1 2)))  => #t\n(vector-mutable? (vector 1 2 3))         => #t\n(vector-mutable? 12)                     => #f\n@end lisp" :similar ())

(sort :type extended :synopsis "(sort obj predicate)" :description "|Obj| must be a list or a vector. |Sort| returns a copy of |obj| sorted\naccording to |predicate|. |Predicate| must be a procedure which takes\ntwo arguments and returns a true value if the first argument is strictly\n``before'' the second.\n\n@lisp\n(sort '(1 2 -4 12 9 -1 2 3) <) \n               => (-4 -1 1 2 2 3 9 12)\n(sort '#(\"one\" \"two\" \"three\" \"four\") \n      (lambda (x y) (> (string-length x) (string-length y))))\n               => '#(\"three\" \"four\" \"one\" \"two\")\n@end lisp" :similar ())


;; Source file "vm.c"

(apply :type procedure :synopsis "(apply proc arg1 ... args)" :description "|Proc| must be a procedure and |args| must be a list. Calls |proc| with the\nelements of the list \n@lisp\n(append (list arg1 ...) args)\n@end lisp \nas the actual arguments.\n@lisp\n(apply + (list 3 4))              =>  7\n\n(define compose\n  (lambda (f g)\n     (lambda args\n       (f (apply g args)))))\n\n((compose sqrt *) 12 75)          =>  30\n@end lisp" :similar ())

(values :type procedure :synopsis "(values obj ...)" :description "Delivers all of its arguments to its continuation. \n,(bold \"Note:\") R5RS imposes to use multiple values in the context of \nof a |call-with-values|. In STklos, if |values| is not used with \n|call-with-values|, only the first value is used (i.e. others values are \n,(emph \"ignored\")).\n" :similar ())

(call-with-values :type procedure :synopsis "(call-with-values producer consumer)" :description "Calls its producer argument with no values and a continuation that, \nwhen passed some values, calls the consumer procedure with those values \nas arguments. The continuation for the call to consumer is the \ncontinuation of the call to call-with-values. \n@lisp\n(call-with-values (lambda () (values 4 5))\n                  (lambda (a b) b))                =>  5\n\n(call-with-values * -)                             =>  -1\n@end lisp" :similar ())


;; Source file "vport.c"

(open-input-virtual :type extended :synopsis "(open-input-virtual :key  (read-char #f) (ready? #f) (eof? #f) (close #f))" :description "Returns a virtual port using the |read-char| procedure to read a\ncharacter from the port, |ready?| to know if there is any data to\nread from the port, |eof?| to know if the end of file is reached\non the port and finally |close| to close the port. All theses\nprocedure takes one parameter which is the port from which the input\ntakes place.  |Open-input-virtual| accepts also the special value\n|¤f| for the I/O procedures with the following conventions:\n,(itemize\n   (item [if |read-char| or |eof?| is |¤f|, any attempt to read\nthe virtual port will return an eof object;])\n   (item [if |ready?| is |¤f|, the file is always  ready\nfor reading;])\n   (item [if |close| is |¤f|, no action is done when the port is\nclosed.]))\n£\nHereafter is a possible implementation of |open-input-string|\nusing virtual ports: \n@lisp\n(define (open-input-string str)\n  (let ((index 0))\n    (open-input-virtual\n       :read-char (lambda (p)\n                 ;; test on eof is already done by the system\n                 (let ((res (string-ref str index)))\n                   (set! index (+ index 1))\n                   res))\n       :eof? (lambda (p) (>= index (string-length str))))))\n@end lisp" :similar ())

(open-output-virtual :type extended :synopsis "(open-output-virtual :key  (write-char #f) (write-string #f) (flush #f) (close #f))" :description "Returns a virtual port using the |write-char| procedure to write a\ncharacter to the port, |write-string| to write a string to the port,\n|flush| to (eventuelly) flush the characters on the port and finally \n|close|to close the port. |Write-char| takes two parameters: a character and\nthe port to which the output must be done. |write-string| takes two\nparameters: a string and a port. |Flush| and |Close| take one\nparameter which is the port on which the action must be done.\n|Open-output-virtual| accepts also the special value |¤f|\nfor the I/O procedures. If a procedure is |¤f| nothing is done\non the corresponding action.\n£\nHereafter is an (very inefficient) implementation of a variant of\n|open-output-string| using virtual ports. The value of the output\nstring is printed when the port is closed:\n@lisp\n(define (open-output-string)\n  (let ((str \"\"))\n    (open-output-virtual\n       :write-char (lambda (c p)\n                  (set! str (string-append str (string c))))\n       :write-string (lambda (s p)\n                    (set! str (string-append str s)))\n       :close (lambda (p) (write str) (newline)))))\n@end lisp\n,(bold \"Note:\") |write-string| is mainly used for writing strings and is \ngenerally more efficient than writing the string character by character. \nHowever, if |write-string| is not provided, strings are printed with \n|write-char|.  On the other hand, if |write-char| is absent, \ncharacters are written by successive allocation of one character strings. \n£\nHereafter is another example: a virtual file port where all characters \nare converted to upper case:\n@lisp\n(define (open-output-uppercase-file file)\n  (let ((out (open-file file \"w\")))\n    (and out\n         (open-output-virtual\n             :write-string (lambda (s p)\n                             (display (string-upper s) out))\n             :close (lambda (p)\n                      (close-port out))))))\n@end lisp" :similar ())

(output-virtual-port? :type extended :synopsis "(input-virtual-port? obj)\n(output-virtual-port? obj)" :description "Returns |#t| if |obj| is a virtual input port or a virtual output port \nrespectively, otherwise returns #f." :similar (input-virtual-port?))

(input-virtual-port? :see output-virtual-port?)
;; **DO NOT EDIT**			-*- scheme -*-
;; File generated automatically on Thu Nov  3 22:10:11 CET 2005


;; Source file "STklos.init"


;; Source file "bigloo.stk"


;; Source file "compfile.stk"


;; Source file "date.stk"

(make-date :type extended :synopsis "(make-date :key second minute hour day month year)" :description "Build a date from its argument. |hour|, |minute|, |second| default to 0;\n|day| and |month| default to 1; |year| defaults to 1970" :similar ())

(date? :type extended :synopsis "(date? obj)" :description "Return |¤t| if |obj| is a date, and otherwise returns |¤f|." :similar ())

(date-second :type extended :synopsis "(date-second d)" :description "Return the second of date |d|, in the range 0 to 59." :similar ())

(date-minute :type extended :synopsis "(date-minute d)" :description "Return the minute of date |d|, in the range 0 to 59." :similar ())

(date-hour :type extended :synopsis "(date-hour d)" :description "Return the hour of date |d|, in the range 0 to 23." :similar ())

(date-day :type extended :synopsis "(date-day d)" :description "Return the day of date |d|, in the range 1 to 31" :similar ())

(date-month :type extended :synopsis "(date-month d)" :description "Return the month of date |d|, in the range 1 to 12" :similar ())

(date-year :type extended :synopsis "(date-year d)" :description "Return the year of date |d|." :similar ())

(date-week-day :type extended :synopsis "(date-week-day d)" :description "Return the week day of date |d|, in the range 0 to 6 (0 is Sunday)." :similar ())

(date-year-day :type extended :synopsis "(date-year-day d)" :description "Return the the number of days since January 1 of date |d|, in the range\n1 to 366." :similar ())

(date-dst :type extended :synopsis "(date-dst d)" :description "Return an indication about daylight saving adjustment:\n,(itemize\n  (item [0 if no daylight saving adjustment])\n  (item [1 if daylight saving adjustment])\n  (item [-1 if the information is not available]))" :similar ())

(date-tz :type extended :synopsis "(date-tz d)" :description "Return the time zone of date |d|." :similar ())

(seconds->list :type extended :synopsis "(seconds->list sec)" :description "Returns a keyword list for the date given by |sec| (a date based on the \nEpoch). The keyed values returned are\n,(itemize \n(item [second : 0 to 59 (but can be up to 61 to allow for leap seconds)])\n(item [minute : 0 to 59])\n(item [hour : 0 to 23])\n(item [day : 1 to 31])\n(item [month : 1 to 12])\n(item [year : e.g., 2002])\n(item [week-day : 0 (Sunday) to 6 (Saturday)])\n(item [year-day : 0 to 365 (365 in leap years)])\n(item [dst : indication about daylight savings time. See ,(ref :mark \"date-dst\")])\n(item [tz : the difference between Coordinated Universal Time\n(UTC) and local standard time in seconds.])\n)\n@lisp\n(seconds->list (current-time))   \n       => (:second 51 :minute 26 :hour 19\n           :day 5 :month 11 :year 2004\n           :week-day 5 :year-day 310\n           :dst 0 :tz -3600)\n@end lisp" :similar ())

(current-date :type extended :synopsis "(current-date)" :description "Returns the current system date." :similar ())

(seconds->string :type extended :synopsis "(seconds->string format n)" :description "Convert a date expressed in seconds using the string |format| as a\nspecification. Conventions for |format| are given below:\n,(itemize\n (item (bold \"~~ \") [a literal ~])\n (item (bold \"~a \") [locale's abbreviated weekday name (Sun...Sat)])\n (item (bold \"~A \") [locale's full weekday name (Sunday...Saturday)])\n (item (bold \"~b \") [locale's abbreviate month name (Jan...Dec)])\n (item (bold \"~B \") [locale's full month day (January...December)])\n (item (bold \"~c \") [locale's date and time\n(e.g., ,(code \"Fri Jul 14 20:28:42-0400 2000\"))])\n (item (bold \"~d \") [day of month, zero padded (01...31)])\n (item (bold \"~D \") [date (mm/dd/yy)])\n (item (bold \"~e \") [day of month, blank padded ( 1...31)])\n (item (bold \"~f \") [seconds+fractional seconds, using locale's\n        decimal separator (e.g. 5.2).])\n (item (bold \"~h \") [same as ~b])\n (item (bold \"~H \") [hour, zero padded, 24-hour clock (00...23)])\n (item (bold \"~I \") [hour, zero padded, 12-hour clock (01...12)])\n (item (bold \"~j \") [day of year, zero padded])\n (item (bold \"~k \") [hour, blank padded, 24-hour clock (00...23)])\n (item (bold \"~l \") [hour, blank padded, 12-hour clock (01...12)])\n (item (bold \"~m \") [month, zero padded (01...12)])\n (item (bold \"~M \") [minute, zero padded (00...59)])\n (item (bold \"~n \") [new line])\n (item (bold \"~p \") [locale's AM or PM])\n (item (bold \"~r \") [time, 12 hour clock, same as ,(code \"~I:~M:~S ~p\")])\n (item (bold \"~s \") [number of full seconds since \"the epoch\" (in UTC)])\n (item (bold \"~S \") [second, zero padded (00...61)])\n (item (bold \"~t \") [horizontal tab])\n (item (bold \"~T \") [time, 24 hour clock, same as ,(code \"~H:~M:~S\")])\n (item (bold \"~U \") [week number of year with Sunday as first day of week\n        (00...53)])\n (item (bold \"~V \") [weekISO 8601:1988 week number of year (01...53)\n      (week 1 is the first week that has at least 4 days in the current year,\n       and  with  Monday  as  the first day of the week)])\n (item (bold \"~w \") [day of week (1...7, 1 is Monday)])\n (item (bold \"~W \") [week number of year with Monday as first day of week\n        (01...52)])\n (item (bold \"~x \") [week number of year with Monday as first day of week\n        (00...53)])\n (item (bold \"~X \") [locale's date representation, for example: \"07/31/00\"])\n (item (bold \"~y \") [last two digits of year (00...99)])\n (item (bold \"~Y \") [year])\n (item (bold \"~z \") [time zone in RFC-822 style])\n (item (bold \"~Z \") [symbol time zone])\n)" :similar ())

(date->string :type extended :synopsis "(date->string format d)" :description "Convert the date |d|using the string |format| as a\nspecification. Conventions for format are the same as the one\nof ,(ref :mark \"seconds->string\")." :similar ())


;; Source file "describe.stk"


;; Source file "expand.ss"


;; Source file "full-syntax.stk"

(let-syntax :type syntax :synopsis "(let-syntax <bindings> <body>)" :description "|<Bindings>| should have the form\n@lisp\n((<keyword> <transformer spec>) ...)\n@end lisp\nEach |<keyword>| is an identifier, each |<transformer spec>| is an instance of\n|syntax-rules|, and |<body>| should be a sequence of one or more expressions.  It\nis an error for a |<keyword>| to appear more than once in the list of keywords\nbeing bound.\n£\nThe |<body>| is expanded in the syntactic environment obtained by\nextending the syntactic environment of the |let-syntax| expression with macros\nwhose keywords are the |<keyword>|s, bound to the specified transformers.  Each\nbinding of a |<keyword>| has |<body>| as its region.\n£\n,(bold \"Note:\") |let-syntax| is available only after having required the file\n|\"full-syntax\"|.\n@lisp\n(let-syntax ((when (syntax-rules ()\n\t\t     ((when test stmt1 stmt2 ...)\n\t\t      (if test\n\t\t\t  (begin stmt1\n\t\t\t\t stmt2 ...))))))\n  (let ((if #t))\n    (when if (set! if 'now))\n    if))                           =>  now\n\n(let ((x 'outer))\n  (let-syntax ((m (syntax-rules () ((m) x))))\n    (let ((x 'inner))\n      (m))))                       =>  outer\n@end lisp" :similar ())

(letrec-syntax :type syntax :synopsis "(letrec-syntax <bindings> <body>)" :description "Syntax of |letrec-syntax| is the same as for |let-syntax|.\n£\nThe |<body>| is expanded in the syntactic environment obtained by\nextending the syntactic environment of the |letrec-syntax| expression\nwith macros whose keywords are the |<keyword>|s, bound to the specified\ntransformers.  Each binding of a |<keyword>| has the |<bindings>| as well\nas the |<body>| within its region, so the transformers can transcribe\nexpressions into uses of the macros introduced by the |letrec-syntax|\nexpression.\n£\n,(bold \"Note:\") |letrec-syntax| is available only after having required the file\n|\"full-syntax\"|.\n\n@lisp\n(letrec-syntax\n  ((my-or (syntax-rules ()\n            ((my-or) #f)\n            ((my-or e) e)\n            ((my-or e1 e2 ...)\n             (let ((temp e1))\n               (if temp\n                   temp\n                   (my-or e2 ...)))))))\n  (let ((x #f)\n        (y 7)\n        (temp 8)\n        (let odd?)\n        (if even?))\n    (my-or x\n           (let temp)\n           (if y)\n           y)))        =>  7\n@end lisp" :similar ())


;; Source file "full-conditions.stk"


;; Source file "getopt.stk"

(arg-usage :type extended :synopsis "(arg-usage port)\n(arg-usage port as-sexpr)" :description "This procedure is only bound inside a |parse-arguments| form.\nIt pretty prints the help associated to the clauses of the\n|parse-arguments| form on the given port. If the argument\n|as-sexpr| is passed and is not |¤f|, the help strings are\nprinted on |port| as ,(emph \"S-expr\")s. This is useful if the help\nstrings need to be manipulated by a program.\n" :similar ())

(parse-arguments :type extended :synopsis "(parse-arguments <args> <clause1> <clause2> ...)" :description "The |parse-arguments| special form is used to parse the\ncommand line arguments of a Scheme script. The implementation of\nthis form internally uses the GNU C |getopt| function. As a\nconsequence |parse-arguments| accepts options which start with\nthe '-' (short option) or '--' characters (long option).\n£\nThe first argument of |parse-arguments| is a list of the arguments\ngiven to the program (comprising the program name in the CAR of this\nlist). Following arguments are clauses. Clauses are described later.\n£\nBy  default, |parse-arguments| permutes the contents of (a copy) of\nthe arguments as it scans, so that eventually all the non-options are\nat the end. However, if the shell environment variable |POSIXLY_CORRECT|\nis set, then option processing stops as soon as a non-option argument\nis encountered. \n£\nA clause must follow the syntax: \n,(raw-code [\n<clause>       => string @pipe <list-clause>\n<list clause>  => (<option descr> <expr> ...) @pipe (else <expr> ...)\n<option descr> => (<option name> [<keyword> value]*)\n<option name>  => string\n<keyword>      => :alternate @pipe :arg @pipe :help\n])\n\nA string clause is used to build the  help associated to the command.\nA list clause must follow the syntax describes an option. The |<expr>|s\nassociated to a list clauses are executed when the option is recognized.\nThe |else| clauses is executed when all parameters have been parsed.\nThe |:alternate| key permits to have an alternate name for an option\n(generally a short or long name if the option name is a\nshort or long name).  The |:help| is used to provide help about the\nthe option. The |:arg| is used when the option admit a parameter: \nthe symbol given after |:arg| will be bound to the value of the option\nargument when the corresponding |<expr>|s will be executed.\n£\nIn an |else| clause the symbol |other-arguments| is bound to the\nlist of the arguments which are not options.\n£\nThe following example shows a rather complete usage of the\n|parse-arguments| form\n\n@lisp\n#!/usr/bin/env stklos-script\n\n(define (main args)\n  (parse-arguments args\n     \"Usage: foo [options] [parameter ...]\"\n     \"General options:\"\n       ((\"verbose\" :alternate \"v\" :help \"be more verbose\")\n         (format #t \"Seen the verbose option~%\"))\n       ((\"long\" :help \"a long option alone\")\n         (format #t \"Seen the long option~%\"))\n       ((\"s\" :help \"a short option alone\")\n         (format #t \"Seen the short option~%\"))\n     \"File options:\"\n       ((\"input\" :alternate \"f\" :arg file\n                 :help \"use <file> as input\")\n         (format #t \"Seen the input option with ~S argument~%\" file))\n       ((\"output\" :alternate \"o\" :arg file\n                  :help \"use <file> as output\")\n         (format #t \"Seen the output option with ~S argument~%\" file))\n     \"Misc:\"\n       ((\"help\" :alternate \"h\"\n                :help \"provides help for the command\")\n         (arg-usage (current-error-port))\n         (exit 1))\n       (else \n     (format #t\n             \"All options parsed. Remaining arguments are ~S~%\"\n             other-arguments))))\n@end lisp\n\nThe following program invocation\n@lisp\nfoo -vs --input in -o out arg1 arg2\n@end lisp\n\nproduces the following output\n,(raw-code [\nSeen the verbose option\nSeen the short option\nSeen the input option with \"in\" argument\nSeen the output option with \"out\" argument\nAll options parsed. Remaining arguments are (\"arg1\" \"arg2\")\n])\n\nFinally, the program invocation\n@lisp\nfoo --help\n@end lisp\nproduces the following output\n,(raw-code [\nUsage: foo [options] [parameter ...]\nGeneral options:\n  --verbose, -v               be more verbose\n  --long                      a long option alone\n  -s                          a short option alone\nFile options:\n  --input=<file>, -f <file>   use <file> as input\n  --output=<file>, -o <file>  use <file> as output\nMisc:\n  --help, -h                  provides help for the command\n])\n\n,(bold \"Note:\")\n,(itemize\n(item [Short option can be concatenated. That is,\n@lisp\nprog -abc\n@end lisp\nis equivalent to the following program call\n@lisp\nprog -a -b -c\n@end lisp])\n(item [Any argument following a '--' argument is no more considered as\nan option, even if it starts with a '-' or '--'.])\n(item [Option with a parameter can be written in several ways. For instance\nto set the output in the |bar| file for the previous example can be expressed as\n,(itemize \n(item [|--output=bar|])\n(item [|-o bar|])\n(item [|-obar|]))])\n)" :similar ())


;; Source file "lex-rt.stk"


;; Source file "make-C-boot.stk"


;; Source file "match.stk"

(match-lambda :type extended-syntax :synopsis "(match-lambda <clause> ...)" :description "|match-lambda| expands into a lambda-expression expecting an argument\nwhich, once applied to an expression, behaves exactly like a\n|match-case| expression.\n@lisp\n((match-lambda\n  ((?x ?x) 'foo)\n  ((?x ?- ?x) 'bar))\n '(a b a))           => bar\n@end lisp" :similar ())

(match-case :type extended-syntax :synopsis "(match-case <key> <clause> ...)" :description "The argument key may be any expression and each clause has the form\n@lisp\n(<pattern> <expression> ...)\n@end lisp \nA match-case expression is evaluated as follows: |<key>| is evaluated\nand the result is compared with each successive pattern. If the |<pattern>|\nin some clause yields a match, then the |<expression>|s in that clause are\nevaluated from left to right in an environment where the pattern variables\nare bound to the corresponding subparts of |<key>|, and the result of the\nlast expression in that clause is returned as the result of the\n|match-case| expression. If no pattern in any clause matches the |<key>|,\nthen, if there is an |else| clause, its expressions are evaluated and\nthe result of the last is the result of the whole |match-case|\nexpression; otherwise the result of the |match-case| expression\nis unspecified.\n£\nThe equality predicate used for tests is |eq?|.\n@lisp \n(match-case '(a b a)\n   ((?x ?x) 'foo)\n   ((?x ?- ?x) 'bar))   => bar\n\n(match-case '(a (b c) d)\n   ((?x ?y) (list 'length=2 y x))\n   ((?x ?y ?z) (list 'length=3 z y x)))\n                        => (length=3 d (b c) a)\n@end lisp" :similar ())


;; Source file "pp.stk"

(pp :type extended :synopsis "(pretty-print sexpr :key port width)\n(pp sexpr :key port width)" :description "This function tries to obtain a pretty-printed representation of |sexpr|.\nThe pretty-printed form is written on |port| with lines which are no\nmore long than |width| characters. If |port| is omitted if defaults to\nthe current error port. As a special convention, if |port| is |¤t|,\noutput goes to the current output port and if |port| is |¤f|, the output\nis returned as a string by |pretty-print|.\nNote that |pp| is another name for |pretty-print|.\n" :similar (pretty-print))

(pretty-print :see pp)

;; Source file "slib.stk"


;; Source file "srfi-1.stk"


;; Source file "srfi-2.stk"


;; Source file "srfi-4.stk"


;; Source file "srfi-7.stk"


;; Source file "srfi-9.stk"


;; Source file "srfi-11.stk"


;; Source file "srfi-13.stk"


;; Source file "srfi-14.stk"


;; Source file "srfi-17.stk"


;; Source file "srfi-26.stk"


;; Source file "srfi-27.stk"

(random-integer :type extended :synopsis "(random-integer n)" :description "Return an integer in the range \\[0, ..., |n|\\[.  Subsequent results of\nthis procedure appear to be independent uniformly distributed over\nthe range \\[0, ..., |n|\\[. The argument |n| must be a positive integer,\notherwise an error is signaled. This function is equivalent to the eponym\nfunction of SRFI-27 (see ,(link-srfi 27) definition for more details)." :similar ())

(random-real :type extended :synopsis "(random-real)" :description "Return a real number |r| such that |0 < r < 1|.\nSubsequent results of this procedure appear to be independent uniformly\ndistributed. This function is equivalent to the eponym\nfunction of SRFI-27 (see ,(link-srfi 27) definition for more details)." :similar ())


;; Source file "srfi-31.stk"


;; Source file "srfi-34.stk"

(with-handler :type extended-syntax :synopsis "(with-handler <handler> <expr1> ... <exprn>)" :description "Evaluates the sequences of expressions |<expr1>| to |<exprn>|.\n|<handler>| must be a procedure that accepts one argument. It is installed\nas the current exception handler for the dynamic extent (as determined by\ndynamic-wind) of the evaluations of the expressions\n@lisp\n(with-handler (lambda (c)\n                (display \"Catch an error\\\\n\"))\n   (display \"One ... \")\n   (+ \"will yield\" \"an error\")\n   (display \"... Two\"))\n       @print{} \"One ... Catch an error\"\n@end lisp" :similar ())

(with-exception-handler :type extended-syntax :synopsis "(with-exception-handler <handler> <thunk>)" :description "This form is similar to |with-handler|. It uses a ,(emph \"thunk\") instead of\na sequence of expressions. It is conform to ,(link-srfi 34).\nIn fact, \n@lisp\n(with-handler <handler> <expr1> ... <exprn>)\n@end lisp\nis equivalent to\n@lisp\n(with-exception-handler <handler>\n  (lambda () <expr1> ... <exprn>))\n@end lisp" :similar ())

(guard :type extended-syntax :synopsis "(guard (<var> <clause1 > <clause2 > ...)  <body>)" :description "Evaluating a guard form evaluates |<body>| with an exception handler\nthat binds the raised object to |<var>| and within the scope of that\nbinding evaluates the clauses as if they were the clauses of a cond\nexpression. That implicit cond  expression is evaluated with the\ncontinuation and dynamic environment of the |guard| expression.\nIf every |<clause>|'s test evaluates to false and there is no |else|\nclause, then |raise|  is re-invoked on the raised object within the\ndynamic environment of the original call to |raise| except that the\ncurrent exception handler is that of the |guard| expression.\n\n@lisp\n(guard (condition\n         ((assq 'a condition) =\\> cdr)\n         ((assq 'b condition)))\n  (raise (list (cons 'a 42))))\n         => 42\n\n(guard (condition\n         ((assq 'a condition) =\\> cdr)\n         ((assq 'b condition)))\n  (raise (list (cons 'b 23))))\n         => (b . 23)\n\n(with-handler (lambda (c) (format \"value ~A was raised\" c))\n  (guard (condition\n\t  ((assq 'a condition) =\\> cdr)\n\t  ((assq 'b condition)))\n\t (raise (list (cons 'x 0)))))\n         => \"value ((x . 0)) was raised\"\n@end lisp " :similar ())


;; Source file "srfi-35.stk"


;; Source file "srfi-36.stk"


;; Source file "srfi-48.stk"


;; Source file "srfi-60.stk"


;; Source file "srfi-70.stk"


;; Source file "trace.stk"

(trace :type extended-syntax :synopsis "(trace f-name ...)" :description "Invoking |trace| with one or more function names causes the functions\nnamed to be traced. Henceforth, whenever such a function is invoked,\ninformation about the call and the returned values, if any, will be\nprinted on the current error port.\n\nCalling |trace| with no argument returns the list of traced functions." :similar ())

(untrace :type extended-syntax :synopsis "(untrace f-name ...)" :description "Invoking |untrace| with one or more function names causes the functions\nnamed not to be traced anymore.\n\nCalling |untrace| with no argument will untrace all the functions \ncurrently traced." :similar ())


;; Source file "assembler.stk"


;; Source file "bb.stk"


;; Source file "bonus.stk"

(bit-shift :type extended :synopsis "(bit-and n1 n2 ...)\n(bit-or n1 n2 ...)\n(bit-xor n1 n2 ...)\n(bit-not n)\n(bit-shift n m)" :description "These procedures allow the manipulation of integers as bit fields.\nThe integers can be of arbitrary length. |Bit-and|, |bit-or| and\n|bit-xor| respectively compute the bitwise ,(emph \"and\"), inclusive and\nexclusive ,(emph \"or\"). |bit-not| eturns the bitwise ,(emph \"not\") of |n|.\n|bit-shift| returns the bitwise ,(emph \"shift\") of |n|. The integer |n|\nis shifted left by |m| bits; If |m| is negative, |n| is shifted right by\n|-m| bits.\n\n@lisp\n(bit-or 5 3)       => 7\n(bit-xor 5 3)      => 6\n(bit-and 5 3)      => 1 \n(bit-not 5)        => -6\n(bit-or 1 2 4 8)   => 15\n(bit-shift 5 3)    => 40\n(bit-shift 5 -1)   => 2\n@end lisp" :similar (bit-not bit-xor bit-or bit-and))

(bit-not :see bit-shift)
(bit-xor :see bit-shift)
(bit-or :see bit-shift)
(bit-and :see bit-shift)
(gensym :type extended :synopsis "(gensym)\n(gensym prefix)" :description "Creates a new symbol. The print name of the generated symbol \nconsists of a prefix (which defaults to ,(q [|G|])) followed by the decimal\nrepresentation of a number. If |prefix| is specified, it must be \neither a string or a symbol.\n@lisp\n(gensym)        => @pipeG100@pipe\n(gensym \"foo-\") => foo-101\n(gensym 'foo-)  => foo-102\n@end lisp" :similar ())

(remove! :type extended :synopsis "(remove pred list)" :description "|Remove| returns |list| without the elements that satisfy predicate |pred|: \n£\nThe list is not disordered -- elements that appear in the result list occur\nin the same order as they occur in the argument list. |Remove!| does the\nsame job than |remove| by physically modifying its |list| argument \n@lisp\n(remove even? '(0 7 8 8 43 -4)) => (7 43)\n@end lisp" :similar (remove))

(remove :see remove!)
(delete! :type extended :synopsis "(delete  x list [=])\n(delete! x list [=])" :description "|Delete| uses the comparison procedure |=|, which defaults to\n|equal?|, to find all elements of |list| that are equal to |x|, and\ndeletes them from |list|. The dynamic order in which the various\napplications of |=| are made is not specified.\n£\nThe list is not disordered -- elements that appear in the result\nlist occur in the same order as they occur in the argument list.\n£\nThe comparison procedure is used in this way: |(= x ei)|. That is,\n|x| is always the first argument, and a list element is always the\nsecond argument. The comparison procedure will be used to compare\neach element of list exactly once; the order in which it is applied\nto the various |ei| is not specified. Thus, one can reliably remove\nall the numbers greater than five from a list with\n@lisp\n(delete 5 list <) \n@end lisp\n\n|delete!| is the linear-update variant of |delete|. It is allowed, \nbut not required, to alter the cons cells in its argument |list| to \nconstruct the result.  " :similar (delete))

(delete :see delete!)
(every :type extended :synopsis "(every pred list1 list2 ...)" :description "|every| applies the predicate |pred| across the lists, returning true if\nthe predicate returns true on every application.\n£\nIf there are n list arguments |list1| ... |listn|, then |pred| must be\na procedure taking n arguments and returning a boolean result. \n£\n|every| applies pred to the first elements of the |listi| parameters. If\nthis application returns false, every immediately returns |¤f|. \nOtherwise, it iterates, applying |pred| to the second elements of the |listi|\nparameters, then the third, and so forth. The iteration stops when a\nfalse value is produced or one of the lists runs out of values. \nIn the latter case, |every| returns the true value produced by its final\napplication of pred. The application of pred to the last element of the \nlists is a tail call. \n£\nIf one of the |listi| has no elements, |every| simply returns |¤t|.\n£\nLike |any|, every's name does not end with a question mark -- this is to\nindicate that it does not return a simple boolean (|¤t| or |¤f|), but a\ngeneral value. " :similar ())

(any :type extended :synopsis "(any pred list1 list2 ...)" :description "|any| applies the predicate across the lists, returning true if the\npredicate returns true on any application. \n£\nIf there are n list arguments |list1| ... |listn|, then |pred| must be\na procedure taking n arguments. \n£\n|any| applies |pred| to the first elements of the |listi| parameters. If\nthis application returns a true value, |any| immediately returns that value.\nOtherwise, it iterates, applying |pred| to the second elements of the |listi|\nparameters, then the third, and so forth. The iteration stops when a true\nvalue is produced or one of the lists runs out of values; in the latter case, \nany returns |¤f|. The application of |pred| to the last element of the\nlists is a tail call. \n£\nLike every, |any|'s name does not end with a question mark -- this is \nto indicate that it does not return a simple boolean (|¤t| or |¤f|), but\na general value. \n\n@lisp\n(any integer? '(a 3 b 2.7))   => #t\n(any integer? '(a 3.1 b 2.7)) => #f\n(any < '(3 1 4 1 5)\n       '(2 7 1 8 2))          => #t\n@end lisp" :similar ())

(call-with-input-string :type extended :synopsis "(call-with-input-string string proc)" :description "behaves as |call-with-input-file| except that the port passed to |proc|\nis the sting port obtained from |port|.\n@lisp\n(call-with-input-string \"123 456\" \n  (lambda (x)\n     (let* ((n1 (read x))\n            (n2 (read x)))\n        (cons n1 n2))))          => (123 . 456)\n@end lisp" :similar ())

(call-with-output-string :type extended :synopsis "(call-with-output-string proc)" :description "|Proc| should be a procedure of one argument. |Call-with-output-string| \ncalls |proc| with a freshly opened output string port. The result of \nthis procedure is a string containing all the text that has been written\non the string port.\n@lisp\n(call-with-output-string\n  (lambda (x) (write 123 x) (display \"Hello\" x))) => \"123Hello\"\n@end lisp" :similar ())

(read-from-string :type extended :synopsis "(read-from-string str)" :description "Performs a read from the given |str|. If |str| is the empty string,\nan end of file object is returned.\n\n@lisp\n(read-from-string \"123 456\") => 123\n(read-from-string \"\")        => an eof object\n@end lisp" :similar ())

(eval-from-string :type extended :synopsis "(eval-from-string str)\n(eval-from-string str module)" :description "Read an expression from |str| and evaluates it with |eval|. If a |module|\nis passed, the evaluation takes place in the enviroment of this module.\nOtherwise, the evaluation takes palce in the environmebnt returned by\n|current-module|.\n@lisp\n(define x 10)\n(define-module M\n  (define x 100))\n(eval-from-string \"(+ x x)\")                   => 20\n(eval-from-string \"(+ x x)\" (find-module 'M))  => 200\n@end lisp" :similar ())

(argv :type extended :synopsis "(argv)" :description "Returns a list of the arguments given on the shell command line. The \ninterpreter options are no included in the result" :similar ())

(program-name :type extended :synopsis "(program-name)" :description "Returns the invocation name of the current program as a string." :similar ())

(make-hash-table :type extended :synopsis "(make-hash-table)\n(make-hash-table comparison)\n(make-hash-table comparison hash)" :description "|Make-hash-table| admits three different forms.  The most general form\nadmit two arguments. The first argument is a comparison function which\ndetermines how keys are compared; the second argument is a function which\ncomputes a hash code for an object and returns the hash code as a non\nnegative integer. Objets with the same hash code are stored in an A-list\nregistered in the bucket corresponding to the key.\n£ \nIf omitted, \n,(itemize\n(item [|hash| defaults to the |hash-table-hash| procedure (see\n,(ref :mark \"hash-table-hash\")).])\n(item [|comparison| defaults to the |eq?| procedure (see ,(ref :mark \"eq?\")).])\n)\nConsequently, \n@lisp\n(define h (make-hash-table))\n@end lisp\nis equivalent to\n@lisp\n(define h (make-hash-table eq? hash-table-hash))\n@end lisp\n\nAn interesting example is \n@lisp\n(define h (make-hash-table string-ci=? string-length))\n@end lisp\nwhich defines a new hash table which uses |string-ci=?| for\ncomparing keys. Here, we use the string-length as a (very simple) \nhashing function. Of course, a function which gives a key depending \nof the characters composing the string gives a better repartition\nand should probably enhance performances. For instance, the following\ncall to |make-hash-table| should return a more efficient, even if\nnot perfect, hash table:\n@lisp\n(make-hash-table \n   string-ci=? \n   (lambda (s)\n     (let ((len (string-length s)))\n       (do ((h 0)  (i 0 (+ i 1)))\n           ((= i len) h)\n         (set! h\n               (+ h (char->integer \n                      (char-downcase (string-ref s i)))))))))\n@end lisp\n\n,(bold \"Note:\") Hash tables with a comparison function equal to |eq?| or\n|string=?| are handled in an more efficient way (in fact, they don't use\nthe |hash-table-hash| function to speed up hash table retrievals)." :similar ())

(hash-table->alist :type extended :synopsis "(hash-table->alist hash)" :description "Returns an ``association list'' built from the entries in |hash|.  \nEach entry in |hash| will be represented as a pair whose |car| is the\nentry's key and whose |cdr| is its value.\n£\n,(bold \"Note:\") the order of pairs in the resulting list is unspecified.\n@lisp \n(let ((h (make-hash-table)))\n  (dotimes (i 5) \n    (hash-table-set! h i (number->string i)))\n  (hash-table->alist h))    \n       => ((3 . \"3\") (4 . \"4\") (0 . \"0\")\n           (1 . \"1\") (2 . \"2\"))\n@end lisp" :similar ())

(alist->hash-table :type extended :synopsis "(alist->hash-table alist)\n(alist->hash-table alist comparison)\n(alist->hash-table alist comparison hash)" :description "Returns hash-table built from the ``association list''\n|alist|. This function maps the |car| of every element in |alist|\nto the |cdr| of corresponding elements in |alist|. the |comparison| and\n|hash| functions are interpreted as in |make-hash-table|. If some key\noccurs multiple times in |alist|, the value in the first\nassociation will take precedence over later ones. \n" :similar ())

(hash-table-update! :type extended :synopsis "(hash-table-update! hash key update-fun thunk)\n(hash-table-update!/default hash key update-fun default)" :description "Update the value associated to |key| in table |hash| if key is already in\ntable with the value |(update-fun current-value)|. If no value is\nassociated to |key|, a new entry in the table is first inserted\nbefore updating it (this new entry being the result of calling |thunk|).\n£\nNote that the expression\n@lisp\n(hash-table-update!/default hash key update-fun default)\n@end lisp\nis equivalent to\n@lisp\n(hash-table-update! hash key update-fun (lambda () default))\n@end lisp\n\n@lisp\n(let ((h   (make-hash-table))\n      (1+  (lambda (n) (+ n 1))))\n  (hash-table-update!/default h 'test 1+ 100)\n  (hash-table-update!/default h 'test 1+)\n  (hash-table-ref h 'test))             => 102\n@end lisp" :similar (hash-table-update!/default))

(hash-table-update!/default :see hash-table-update!)
(hash-table-keys :type extended :synopsis "(hash-table-keys hash)\n(hash-table-values hash)" :description "Returns the keys or the values of |hash|. " :similar (hash-table-values))

(hash-table-values :see hash-table-keys)
(hash-table-fold :type extended :synopsis "(hash-table-fold hash func init-value)" :description "This procedure calls |func| for every association in |hash|\nwith three arguments: the key of the association key, the value\nof the association value, and an accumulated value, |val|. |Val| is\ninit-value for the first invocation of |func|, and for subsequent\ninvocations of |func|, the return value of the previous invocation of\n|func|. The value |final-value| returned by |hash-table-fold| is the\nreturn value of the last invocation of |func|. The order in which |func| is\ncalled for different associations is unspecified.\n£\nFor instance, the following expression\n@lisp\n(hash-table-fold ht (lambda (k v acc) (+ acc 1)) 0)\n@end lisp\ncomputes the number of associations present in the |ht| hash table." :similar ())

(hash-table-merge! :type extended :synopsis "(hash-table-merge! hash1 hash2)" :description "Adds all mappings in |hash2| into |hash1| and returns the resulting\nhash table. This function may modify |hash1| destructively." :similar ())

(hash-table-copy :type extended :synopsis "(hash-table-copy hash)" :description "Returns a copy of |hash|." :similar ())

(fluid-let :type extended-syntax :synopsis "(fluid-let <bindings> <body>)" :description "The |<bindings>| are evaluated in the current environment, in some\nunspecified order, the current values of the variables present in\n|<bindings>| are saved, and the new evaluated values are assigned to the \n|<bindings>| variables. Once this is done, the expressions of |<body>|\nare evaluated sequentially in the current environment; the value of the\nlast expression is the result of |fluid-let|. Upon exit, the stored\nvariables values are restored. An error is signalled if any of the \n|<bindings>| variable is unbound.\n@lisp\n(let* ((a 'out)\n       (f (lambda () a)))\n  (list (f) \n        (fluid-let ((a 'in)) (f))\n        (f))) => (out in out)\n@end lisp\n\nWhen the body of a |fluid-let| is exited by invoking a continuation,\nthe new variable values are saved, and the variables are set to their old \nvalues. Then, if the body is reentered by invoking a continuation, the old\nvalues are saved and new values are restored. The following example illustrates\nthis behavior\n\n@lisp\n(let ((cont #f)\n      (l    '())\n      (a    'out))\n  (set! l (cons a l))\n  (fluid-let ((a 'in))\n    (set! cont (call-with-current-continuation (lambda (k) k)))\n    (set! l (cons a l)))\n  (set! l (cons a l))\n\n  (if cont (cont #f) l)) =>  (out in out in out)\n@end lisp" :similar ())

(setter :type procedure :synopsis "(setter proc)" :description "Returns the setter associated to a |proc|. Setters are defined in the\n,(link-srfi 17) document. A setter proc, can be used in a generalized\nassignment, as described in |set!|.\n£\nTo associate |s| to the procedure |p|, use the following form:\n@lisp\n(set! (setter p) s)\n@end lisp\nFor instance, we can write\n@lisp\n(set! (setter car) set-car!)\n@end lisp\n\nThe following standard procedures have pre-defined setters: \n@lisp\n(set! (car x) v)              == (set-car! x v)\n(set! (cdr x) v)              == (set-cdr! x v)\n(set! (string-ref x i) v)     == (string-set! x i v)\n(set! (vector-ref x i) v)     == (vector-set! x i v)! \n(set! (slot-ref x 'name) v)   == (slot-set! x 'name v)\n(set! (struct-ref x 'name) v) == (struct-set! x 'name v) \n@end lisp\nFurhermore, ,(ref :section \"Parameter Objects\" :text \"parameters objects\")\nare their own setter:\n@lisp\n(real-precision)              => 15\n(set! (real-precision) 12)\n(real-precision)              => 12\n@end lisp" :similar ())

(time :type extended-syntax :synopsis "(time expr1 expr2 ...)" :description "Evaluates the expressions |expr1|, |expr2|, ... and returns the\nresult of the last expression. This form prints also the time spent\nfor this evaluation on the current error port." :similar ())

(dotimes :type extended-syntax :synopsis "(dotimes [var count] <expression1> <expression2> ... )\n(dotimes [var count result] <expression1> <expression2> ... )" :description "Evaluates the |count| expression, which must return an\ninteger and then evaluates the |<expression>|s once for each\ninteger from zero (inclusive) to |count| (exclusive), in order,\nwith the symbol |var| bound to the integer; if the value of\n|count| is zero or negative, then the |<expression>|s are not\nevaluated. When the loop completes, |result| is evaluated and its\nvalue is returned as the value of the |dotimes| construction. If\n|result| is omitted, |dotimes| result is ,(emph \"void\").\n@lisp\n(let ((l '()))\n  (dotimes (i 4 l)\n     (set! l (cons i l)))) => (3 2 1 0)\n@end lisp" :similar ())

(while :type extended-syntax :synopsis "(while <test> <expression1> <expression2> ...)" :description "|While| evaluates the |<expression>|s until |<test>| returns a false\nvalue. The value returned by this form is ,(emph \"void\")." :similar ())

(until :type extended-syntax :synopsis "(until <test> <expression1> <expression2> ...)" :description "|Until| evaluates the |<expression>|s until |<while>| returns a false\nvalue. The value returned by this form is ,(emph \"void\")." :similar ())

(call/ec :type extended :synopsis "(call/ec proc)" :description "|call/ec| is an short name for |call-with-escape-continuation|. |call/ec|\ncalls |proc| with one parameter, which is the current escape continuation\n(a continuation which can only be used to abort a computation and hence \ncannot be \"re-enterered\".\n\n@lisp\n(list 1\n      (call/ec (lambda (return) (list 'a (return 'b) 'c)))\n      3)        => (1 b 3)\n@end lisp\n|call/ec| is cheaper than the full call/ec. It is particularily useful\nwhence all the power of |call/cc| is not needded. " :similar ())

(port->string-list :type extended :synopsis "(port->string port)\n(port->sexp-list port)\n(port->string-list port) " :description "All these procedure take a port opened for reading. |Port->string| reads\n|port| until the it reads an end of file object and returns all the \ncharacters read as a string. |Port->sexp-list)| and |port->string-list| \ndo the same things except that they return a list of S-expressions and\na list of strings respectively. For the following example we suppose that \nfile |\"foo\"| is formed of two lines which contains respectively the number \n|100| and the string |\"bar\"|.\n@lisp\n(port->sexp-list (open-input-file \"foo\"))   => (100 \"bar\")\n(port->string-list (open-input-file \"foo\")) => (\"100\" \"\\\"bar\\\"\")\n@end lisp " :similar (port->sexp-list port->string))

(port->sexp-list :see port->string-list)
(port->string :see port->string-list)
(exec-list :type extended :synopsis "(exec str)\n(exec-list str)" :description "These procedures execute the command given in |str|. The command given \nin |str| is passed to |/bin/sh|. |Exec| returns a strings which contains \nall the characters that the command |str| has printed on it's standard\noutput, whereas |exec-list| returns a list of the lines which constitute\nthe output of |str|.\n@lisp\n(exec \"echo A; echo B\")                => \"A\\\\nB\\\\n\"\n(exec-list \"echo A; echo B\")           => (\"A\" \"B\")\n@end lisp" :similar (exec))

(exec :see exec-list)
(argc :type extended :synopsis "(argc)" :description "Returns the number of argument present on the command line" :similar ())

(apropos :type extended :synopsis "(apropos obj)\n(apropos obj module)" :description "|Apropos| returns a list of symbols whose print name contains the\ncharacters of |obj| as a substring . The given |obj| can be a string or\nsymbol. This function returns the list of matched symbols which can\nbe accessed from the given |module| (defaults to the current module if not\nprovided).\n" :similar ())

(die :type extended :synopsis "(die message)\n(die message status)" :description "|Die| prints the given |message| on the current error port and exits\nthe program with the |status| value. If |status| is omitted, it\ndefaults to 1." :similar ())

(decompose-file-name :type extended :synopsis "(decompose-file-name string)" :description "Returns an ``exploded'' list of the path name components given in\n|string|.\nThe first element in the list denotes if the given |string| is an\nabsolute path or a relative one, being \"/\" or \".\" respectively.\nEach component of this list is a string.\n@lisp\n(decompose-file-name \"/a/b/c.stk\") => (\"/\" \"a\" \"b\" \"c.stk\")\n(decompose-file-name \"a/b/c.stk\")  => (\".\" \"a\" \"b\" \"c.stk\")\n@end lisp" :similar ())

(dirname :type extended :synopsis "(dirname str)" :description "Returns a string containing all but the last component of the path\nname given in |str|.\n@lisp\n(dirname \"/a/b/c.stk\") => \"/a/b\"\n@end lisp" :similar ())

(basename :type extended :synopsis "(basename str)" :description "Returns a string containing the last component of the path name\ngiven in |str|.\n@lisp\n(basename \"/a/b/c.stk\") => \"c.stk\"\n@end lisp" :similar ())

(file-separator :type extended :synopsis "(file-separator)" :description "Retuns the operating system file separator as a character. This is typically \n#\\\\/ on Unix (or Cygwin) systems and #\\\\\\\\ on Windows." :similar ())

(make-path :type extended :synopsis "(make-path dirname name)" :description "Builds a file name from the directory |dirname| and |name|.\n" :similar ())

(port-idle-reset! :type extended :synopsis "(port-idle-register! port thunk)\n(port-idle-unregister! port thunk)\n(port-idle-reset! port)" :description "|port-idle-register!| allows to register |thunk| as an idle handler\nwhen reading on port. That means that |thunk| will be called continuously\nwhile waiting  an input on |port| (and only while using a reading\nprimitive on this port). |port-idle-unregister!| can be used to\nunregister a handler previously set by |port-idle-register!|. The\nprimitive |port-idle-reset!| unregisters all the handlers set on\n|port|.\n\nHereafter is a (not too realistic) example: a message will be displayed\nrepeatedly until a ,(emph \"sexpr\") is read on the current input port.\n\n@lisp\n(let ((idle (lambda () (display \"Nothing to read!\\\\n\"))))\n  (port-idle-register! (current-input-port) idle)\n  (let ((result (read)))\n    (port-idle-unregister! (current-input-port) idle)\n    result))\n@end lisp" :similar (port-idle-unregister! port-idle-register!))

(port-idle-unregister! :see port-idle-reset!)
(port-idle-register! :see port-idle-reset!)
(chmod :type extended :synopsis "(chmod str)\n(chmod str option1 ...)" :description "Change the access mode of the file whose path name is given in |string|. \nThe options must be composed of either an integer or one of the \nfollowing symbols |read|, |write| or |execute|. Giving no option to |chmod|\nis equivalent to pass it the integer |0|. If the operation succeeds, \n|chmod| returns |¤t|; otherwise it returns |¤f|.\n\n@lisp\n(chmod \"~/.stklos/stklosrc\" 'read 'execute)\n(chmod \"~/.stklos/stklosrc\" #o644)\n@end lisp" :similar ())

(receive :type extended-syntax :synopsis "(receive <formals> <expression> <body>)" :description "This form is defined in ,(link-srfi 8). It simplifies\nthe usage of multiple values. Specifically, |<formals>| can have any\nof three forms:\n,(itemize\n(item [(|<variable1>| ... |<variablen>|):\n,(linebreak)\nThe environment in which the\nreceive-expression is evaluated is extended by binding |<variable1>|, ...,\n|<variablen>| to fresh locations.\n£\nThe |<expression>| is evaluated, and its\nvalues are stored into those locations. (It is an error if |<expression>|\ndoes not have exactly n values.)\n])\n(item [|<variable>|:\n,(linebreak)\nThe environment in which the receive-expression is\nevaluated is extended by binding |<variable>| to a fresh location.\nThe |<expression>| is evaluated, its values are converted into a newly\nallocated list, and the list is stored in the location bound to |<variable>|.\n])\n(item [(|<variable1>| ... |<variablen>| . |<variablen + 1>|):\n,(linebreak)\nThe environment\nin which the receive-expression is evaluated is extended by binding\n|<variable1>|, ..., |<variablen + 1>| to fresh locations.\nThe |<expression>| is evaluated. Its first n values are stored into the\nlocations bound to |<variable1>| ... |<variablen>|. Any remaining values\nare converted into a newly allocated list, which is stored into the location\nbound to |<variablen + 1>|. (It is an error if |<expression>| does not have\nat least n values.)])\n)\n\nIn any case, the expressions in |<body>| are evaluated sequentially in\nthe extended environment. The results of the last expression in the body\nare the values of the receive-expression.\n@lisp\n(let ((n 123))\n  (receive (q r)\n     (values (quotient n 10) (modulo n 10))\n     (cons q r)))\n              => (12 . 3)\n@end lisp" :similar ())

(case-lambda :type extended-syntax :synopsis "(case-lambda <clause> ...)" :description "Each |<clause>| should have the form |(<formals> <body>)|, where \n|<formals>| is a formal arguments list as for |lambda|.\nEach |<body>| is a |<tail-body>|, as defined in R5RS.\n£\nA |case-lambda| expression evaluates to a procedure that\naccepts a variable number of arguments and is lexically scoped in\nthe same manner as procedures resulting from |lambda|\nexpressions. When the procedure is called with some arguments\n|v1 ... vk|, then the first |<clause>| for which the arguments agree\nwith |<formals>| is selected, where agreement is specified as for the\n|<formals>| of a |lambda| expression. The variables of |<formals>|\nare bound to fresh locations, the values |v1 ... vk| are stored in those\nlocations, the |<body>| is evaluated in the extended environment,\nand the results of |<body>| are returned as the results of the\nprocedure call.\n£   \nIt is an error for the arguments not to agree with the |<formals>|\nof any |<clause>|.\n£  \nThis form is defined in ,(link-srfi 16).\n\n@lisp\n (define plus\n   (case-lambda \n    (() 0)\n    ((x) x)\n    ((x y) (+ x y))\n    ((x y z) (+ (+ x y) z))\n    (args (apply + args))))\n\n (plus)                     => 0\n (plus 1)                   => 1\n (plus 1 2 3)               => 6\n\n ((case-lambda \n   ((a) a)\n   ((a b) (* a b)))\n  1 2 3)                    => error\n@end lisp" :similar ())

(parameterize :type extended-syntax :synopsis "(parameterize ((expr1 expr2) ...) <body>)" :description "The expressions |expr1| and |expr2| are evaluated in an unspecified order.\nThe value of the |expr1| expressions must be parameter objects.\nFor each |expr1| expression and in an unspecified order, the local\ndynamic environment is extended with a binding of the parameter object\n|expr1| to a new cell whose content is the result of the call\n|(converter val)|, where |val| is the value of |expr2| and converter\nis the conversion procedure of the parameter object. The resulting\ndynamic environment is then used for the evaluation of |<body>|\n(which refers to the R5RS grammar nonterminal of that name).\nThe result(s) of the parameterize form are the result(s) of\nthe |<body>|.\n\n@lisp\n(radix)                                              =>  2\n(parameterize ((radix 16)) (radix))                  =>  16\n(radix)                                              =>  2\n\n(define (f n) (number->string n (radix)))\n\n(f 10)                                               =>  \"1010\"\n(parameterize ((radix 8)) (f 10))                    =>  \"12\"\n(parameterize ((radix 8) (prompt (f 10))) (prompt))  =>  \"1010\"\n@end lisp" :similar ())

(require-extension :type extended-syntax :synopsis "(require-extension <clause> ...)" :description "The syntax of require-extension is as follows:\n@lisp\n(require-extension <clause> ...)\n@end lisp\nA clause has the form:\n@lisp\n (srfi <extension-argument> ...)\n@end lisp\nwhere |<extension-argument>|s may be any Scheme-values.\n£\nIf an |<extension-argument>| is a nonnegative integer, the functionality\nof the indicated SRFIs is made available in the context in\nwhich the require-extension form appears. For instance,\n@lisp \n(require-extension (srfi 1 2))\n               ; Make the SRFI 1 and 2 available\n@end lisp\nThis form is compatible with ,(link-srfi 55). However, STklos\naccepts also some symbolic names for requiring some extensions.\nFor instance,\n@lisp\n(require-extension (srfi lists and-let*))\n@end lisp\nis equivalent to the previous |require-extension|. A list of available\n symbols as  |<extension-argument>| is given in chapter\n,(ref :chapter \"SRFIs\")." :similar ())


;; Source file "boot.stk"


;; Source file "compiler.stk"

(quote :type syntax :synopsis "(quote <datum>)\n'<datum>" :description "The quoting mechanism is identical to R5RS, except that keywords \nconstants  evaluate \"to themselves\" as numerical constants, string \nconstants, character constants, and boolean constants\n@lisp\n'\"abc\"     =>  \"abc\"\n\"abc\"      =>  \"abc\"\n'145932    =>  145932\n145932     =>  145932\n'#t        =>  #t\n#t         =>  #t\n:foo       =>  :foo\n':foo      =>  :foo\n@end lisp\n,(bold \"Note:\") R5RS requires to quote constant lists and\nconstant vectors. This is not necessary with STklos." :similar ())

(and :type syntax :synopsis "(and <test1> ...)" :description "The |<test>| expressions are evaluated from left to right, and the\nvalue of the first expression that evaluates to a false value is\nreturned.  Any remaining expressions are not evaluated.  If all the\nexpressions evaluate to true values, the value of the last expression\nis returned.  If there are no expressions then |¤t| is returned.\n\n@lisp\n  (and (= 2 2) (> 2 1))           =>  #t\n  (and (= 2 2) (< 2 1))           =>  #f\n  (and 1 2 'c '(f g))             =>  (f g)\n  (and)                           =>  #t\n@end lisp" :similar ())

(or :type syntax :synopsis "(or <test1> ...)" :description "The |<test>| expressions are evaluated from left to right, and the\nvalue of the first expression that evaluates to a true value is\nreturned.  Any remaining expressions are not evaluated.  If all\nexpressions evaluate to false values, the value of the last expression\nis returned.  If there are no expressions then |¤f| is returned.\n\n@lisp\n  (or (= 2 2) (> 2 1))            =>  #t\n  (or (= 2 2) (< 2 1))            =>  #t\n  (or #f #f #f)                   =>  #f\n  (or (memq 'b '(a b c)) \n      (/ 3 0))                    =>  (b c)\n@end lisp" :similar ())

(include :type extended-syntax :synopsis "(include <file>)" :description "TODO" :similar ())


;; Source file "computils.stk"


;; Source file "expand.pp"


;; Source file "load.stk"

(load-path :type extended :synopsis "(load-path)\n(load-path value)" :description "|load-path| is a parameter object. It \nreturns the current load path. The load path is a list of strings \nwhich correspond to the directories in which a file must be searched for \nloading. Directories of the load path are ,(emph \"prepended\") (in\ntheir apparition \norder) to the file name given to |load| or |try-load| until the file \ncan be loaded.\n£\nThe initial value of the current load path can be set from the shell, by \nsetting the |STKLOS_LOAD_PATH| shell variable.\n£\nGiving a |value| to the parameter |load-path| permits to change the\ncurrent list of paths." :similar ())

(load-suffixes :type extended :synopsis "(load-suffixes)\n(load-suffixes value)" :description "|load-suffixes| is a parameter object. It\nreturns the list of possible suffixes for a Scheme file. Each suffix,\nmust be a string. Suffixes are appended (in their apparition order) \nto a file name  is appended to a file name given to |load| or |try-load| \nuntil the file can be loaded. " :similar ())

(load-verbose :type extended :synopsis "(load-verbose)\n(load-verbose value)" :description "|load-verbose| is a parameter object. It permits to display the\npath name of the files whch are loaded by |load| or |try-load| on\nthe current error port, when set to a true value. If |load-verbose|\nis set to |¤f|, no message is printed." :similar ())

(current-loading-file :type extended :synopsis "(current-loading-file)" :description "Returns the path of the file that is currently being load." :similar ())

(find-path :type extended :synopsis "(find-path str)\n(find-path str path)\n(find-path str path suffixes)" :description "In its first form, |find-path| returns the path name of the file\nthat should be loaded by the procedure  |load| given the name |str|.\nThe string returned depends of the current  load path and of the\ncurrently accepted suffixes.\n£\nThe other forms of |find-path| are more general and allow to give a path\nlist (a list of strings representing supposed directories) and a set\nof suffixes (given as a list of strings too) to try for finding a file.\nIf no file is found, |find-path| returns |¤f|.\n£\nFor instance, on a \"classical\" Unix box:\n@lisp\n(find-path \"passwd\" '(\"/bin\" \"/etc\" \"/tmp\"))\n            => \"/etc/passwd\"\n(find-path \"stdio\" '(\"/usr\" \"/usr/include\") '(\"c\" \"h\" \"stk\"))\n            => \"/usr/include/stdio.h\"\n@end lisp" :similar ())

(provided? :type extended :synopsis "(require string)\n(provide string)\n(require/provide string)\n(provided? string)" :description "|Require| loads the file whose name is |string| if it was not\npreviously ,(q (emph  \"provided\")). |Provide| permits to store |string| in\nthe list of already provided files. Providing a file permits to avoid\nsubsequent loads of this file. |Require/provide| is more or less equivalent to\na |require| followed by a |provide|. |Provided?| returns |¤t| if\n|string| was already provided; it returns |¤f| otherwise." :similar (require/provide provide require))

(require/provide :see provided?)
(provide :see provided?)
(require :see provided?)
(autoload :type extended :synopsis "(autoload file symbol ...)" :description "TODO\n" :similar ())

(syntax-autoload :type extended :synopsis "(syntax-autoload file symbol ...)" :description "TODO\n" :similar ())


;; Source file "mbe.stk"

(define-syntax :type syntax :synopsis "(define-syntax <identifier> <transformer-spec>)" :description "|<Define-syntax>|  extends the top-level syntactic environment by binding \nthe |<identifier>| to the specified transformer. \n\n,(bold \"Note:\") |<transformer-spec>| should be an instance of |syntax-rules|.\n@lisp\n(define-syntax let*\n  (syntax-rules ()\n    ((let* () body1 body2 ...)\n     (let () body1 body2 ...))\n    ((let* ((name1 val1) (name2 val2) ...)\n       body1 body2 ...)\n     (let ((name1 val1))\n       (let* (( name2 val2) ...)\n         body1 body2 ...))))\n@end lisp" :similar ())

(syntax-rules :type syntax :synopsis "(syntax-rules <literals> <syntax-rule> ...)" :description "|<literals>| is a list of identifiers, and each |<syntax-rule>| should be of\nthe form \n@lisp\n(pattern template)\n@end lisp\n\nAn instance of |<syntax-rules>| produces a new macro transformer by\nspecifying a sequence of hygienic rewrite rules. A use of a macro\nwhose name is associated with a transformer specified by\n<syntax-rules> is matched against the patterns contained in the\n<syntax-rules>, beginning with the leftmost syntax-rule. When a match is\nfound, the macro use is transcribed hygienically according to the\ntemplate.\n£\nEach pattern begins with the name for the macro. This name is not \ninvolved in the matching and is not considered a pattern variable or\nliteral identifier.\n£\n,(bold \"Note:\") For a complete description of the Scheme pattern language, \nrefer to R5RS." :similar ())


;; Source file "module.stk"

(symbol-value* :type extended :synopsis "(symbol-value* symbol module)\n(symbol-value* symbol module default)" :description "Returns the value bound to |symbol| in |module|. If |symbol| is not bound,\nan error is signaled if no |default| is provided, otherwise |symbol-value| \nreturns |default|.\n£\nNote that this function searches the value of |symbol| in |module|\n,(bold \"and\") all the modules it imports whereas |symbol-value| searches\nonly in |module|." :similar ())

(select-module :type extended-syntax :synopsis "(select-module <name>)" :description "Changes the value of the current module to the module with the given |name|. \nThe expressions evaluated after |select-module| will take place in \nmodule |name| environment.  Module |name| must have been created \npreviously by a |define-module|. The result of |select-module| is\n,(emph \"void\").\n|Select-module| is particularly useful when debugging since it\nallows to place toplevel evaluation in a particular module. The\nfollowing transcript shows an usage of |select-module|.\n,(footnote [This transcript uses the default toplevel loop \n\t       which displays the name of the current module in the evaluator\n\t       prompt.]):\n@lisp\nstklos> (define foo 1)\nstklos> (define-module bar\n          (define foo 2))\nstklos> foo\n1\nstklos> (select-module bar)\nbar> foo\n2\nbar> (select-module stklos) \nstklos> \n@end lisp" :similar ())

(define-module :type extended-syntax :synopsis "(define-module <name> <expr1> <expr2> ...)" :description "|Define-module| evaluates the expressions |<expr1>|, |<expr2>| ... which\nconstitute the body of the module |<name>| in the environment of that module.\n|Name| must be a valid symbol. If this symbol has not already been used to\ndefine a module, a new module, named |name|, is created.\nOtherwise, the expressions |<expr1>|, |<expr2>| ... are evaluated in\nthe environment of the (old) module |<name>|\n,(footnote [In fact |define-module| on a given name\n\t     defines a new module only the first time it is invoked on this name.\n\t     By this way, interactively reloading a module does not define \n\t     a new entity, and the other modules which use it are not altered.]).\nDefinitions done in a module are local to the module and do not interact with \nthe definitions in other modules. Consider the following definitions,\n@lisp\n(define-module M1\n   (define a 1))\n\n(define-module M2\n  (define a 2)\n  (define b (* 2 x)))\n@end lisp\n\nHere, two modules are defined and they both bind the symbol |a| to a \nvalue. However, since |a| has been defined in two distinct modules\nthey denote two different locations. \n£\nThe |STklos| module, which is predefined, is a special module which\ncontains all the ,(emph \"global variables\") of a R5RS program.  A symbol\ndefined in the |STklos| module, if not hidden by a local definition, is\nalways visible from inside a module. So, in the previous exemple, the\n|x| symbol refers the |x| symbol defined in the |STklos| module.\n£\nThe result of |define-module| is ,(emph \"void\")." :similar ())

(import :type extended-syntax :synopsis "(import <module1> <module2> ...)" :description "Specifies the modules which are imported by the current module.\nImporting a module makes the symbols it exports visible to the\nimporter, if not hidden by local definitions. When a symbol \nis exported by several of the imported modules, the location denoted by\nthis symbol in the importer module correspond to the one of the first module\nin the list \n@lisp\n(<module1> <module2> ...) \n@end lisp\nwhich exports it. \n£\nIf several |import| clauses appear in a module, the set of\nimported modules  is determined by appending the various list of modules \nin their apparition order. \n\n@lisp\n(define-module M1\n  (export a b)\n  (define a 'M1-a)\n  (define b 'M1-b))\n\n(define-module M2\n  (export b c)\n  (define b 'M2-b)\n  (define c 'M2-c))\n\n(define-module M3\n  (import M1 M2)\n  (display (list a b c)))  @print{} (m1-a m1-b m2-c)\n@end lisp\n\n,(bold \"Note:\") Importations are not ,(emph \"transitive\"): when\nthe module ,(emph \"C\") imports the module ,(emph \"B\") which is an importer\nof module ,(emph \"A\") the symbols of ,(emph \"A\") are not visible\nfrom ,(emph \"C\"), except  by explicitly importing the ,(emph \"A\")\nmodule from ,(emph \"C\").\n£\n,(bold \"Note:\") The module |STklos|, which contains the ,(emph \"global\nvariables\") is always implicitly imported from a module. Furthermore, \nthis module is always placed at the end of the list of imported modules." :similar ())

(export :type extended-syntax :synopsis "(export <symbol1> <symbol2> ...)" :description "Specifies the symbols which are exported (i.e. ,(emph \"visible\")) outside \nthe current module. By default, symbols defined in a module are not \nvisible outside this module, excepted if they appear in an |export|\nclause. \n£\nIf several |export| clauses appear in a module, the set of\nexported symbols is determined by ``,(emph \"unionizing\")'' symbols exported\nin all the |export| clauses.\n£\nThe result of |export| is ,(emph \"void\")." :similar ())

(in-module :type extended-syntax :synopsis "(in-module mod s)\n(in-module mod s default)" :description "This form returns the value of symbol with name |s| in the module with name\n|mod|. If this symbol is not bound,  an error is signaled if no |default| is\nprovided, otherwise |in-module| returns |default|. Note that the value of |s|\nis searched in |mod| and all the modules it imports.\n£\nThis form is in fact a shortcut. In effect, \n@lisp\n(in-module my-module foo)\n@end lisp\n£\nis equivalent to\n@lisp\n(symbol-value* 'foo (find-module 'my-module))\n@end lisp" :similar ())


;; Source file "object.stk"


;; Source file "obsolete.stk"


;; Source file "peephole.stk"


;; Source file "pragma.stk"


;; Source file "process.stk"

(run-process :type extended :synopsis "(run-process command p1 p2 ...)" :description "|run-process| creates a new process and run the executable\nspecified in |command|. The |p| correspond to the command line\narguments. The following values of |p| have a special meaning:\n,(itemize\n(item [|:input| permits to redirect the standard input file of the\nprocess. Redirection can come from a file or from a pipe. To redirect\nthe standard input from a file, the name of this file must be\nspecified after |:input|. Use the special keyword |:pipe| to\nredirect the standard input from a pipe.])\n\n(item [|:output| permits to redirect the standard output file of the\nprocess. Redirection can go to a file or to a pipe. To redirect\nthe standard output to a file, the name of this file must be\nspecified after |:output|. Use the special keyword |:pipe| to\nredirect the standard output to a pipe.])\n\n(item [|:error| permits to redirect the standard error file of the\nprocess. Redirection can go to a file or to a pipe. To redirect\nthe standard error to a file, the name of this file must be\nspecified after |error|. Use the special keyword |:pipe| to\nredirect the standard error to a pipe.])\n\n(item [|:wait| must be followed by a boolean value. This value\nspecifies if the process must be run asynchronously or not. By\ndefault, the process is run asynchronously (i.e. |:wait| is |¤f|).])\n\n(item [|:host| must be followed by a string. This string represents\nthe name of the machine on which the command must be executed. This\noption uses the external command |rsh|. The shell variable \n|PATH| must be correctly set for accessing it without specifying its\nabolute path.])\n\n(item [|:fork| must be followed by a boolean value. This value\nspecifies if a ,(emph \"fork\") system call must be done before running\nthe process. If the process is run without ,(emph \"fork\") the Scheme\nprogram is lost. This feature mimics the ``|exec|'' primitive of the\nUnix shells. By default, a fork is executed before running the process \n(i.e. |:fork| is |¤t|). This option works on Unix implementations only.])\n)\n\nThe following example launches a process which executes the\nUnix command |ls| with the arguments |-l| and |/bin|. The lines \nprinted by this command are stored in the file |/tmp/X|\n@lisp\n(run-process \"ls\" \"-l\" \"/bin\" :output \"/tmp/X\")\n@end lisp" :similar ())

(process-kill :type extended :synopsis "(process-kill proc)" :description "Kills (brutally) |process|. The result of |process-kill|\nis ,(emph\"void\"). This procedure is equivalent to\n@lisp\n(process-send-signal process 'SIGTERM)\n@end lisp" :similar ())

(process-continue :type extended :synopsis "(process-stop proc)\n(process-continue proc)" :description "|Process-stop| stops the execution of |proc| and |process-continue| resumes \nits execution. They are equivalent, respectively, to \n@lisp\n(process-send-signal process 'SIGSTOP)\n(process-send-signal process 'SIGCONT)\n@end lisp" :similar (process-stop))

(process-stop :see process-continue)

;; Source file "r5rs.stk"

(lambda :type extended-syntax :synopsis "(lambda <formals> <body>)" :description "A lambda expression evaluates to a procedure. STklos lambda expression\nhave been extended to allow a optional and keyword parameters. \n|<formals>| should have one of the following forms:\n,(itemize\n(item [\n|(<variable1> ...)|\n,(linebreak)\nThe procedure takes a fixed number of arguments; \nwhen the procedure is called, the arguments will be stored in the \nbindings of the corresponding variables.  This form is identical to\nR5RS.\n])\n\n(item [\n|<variable>|\n,(linebreak)\nThe procedure takes any number of arguments; when the \nprocedure is called, the sequence of actual arguments is converted into\na newly allocated list, and the list is stored in the binding of the\n|<variable>|. This form is identical to R5RS.\n])\n\n(item [\n|(<variable1> ... <variablen> . <variablen+1>)|\n,(linebreak)\nIf a space-delimited \nperiod precedes the last variable, then the procedure takes n or more\n arguments, where n is the number of formal arguments before the period \n(there must be at least one). The value stored in the binding of the\nlast variable will be a newly allocated list of the actual arguments left \nover after all the other actual arguments have been matched up against \nthe other formal arguments. This form is identical to R5RS.\n])\n\n(item [\n|(<variable1 ... <variablen> \\[:optional ...\\] \\[:rest ...\\] \\[:key ...\\])|\n,(linebreak)\nThis form is specific to STklos and allows to have procedure with \noptional and keyword parameters. The form |:optional| allows to specify \noptional parameters. All the parameters specified after |:optional| to the end\nof |<formals>| (or until a |:rest| or |:key|) are optional parameters. An \noptional parameter can declared as:\n,(itemize \n(item [\n|variable|: if a value is passed when the procedure is called, it will be \nstored in the binding of the corresponding variable, otherwise the value |¤f|\nwill be stored in it.\n])\n(item [\n|(variable value)|: if a value is passed when the procedure is called, it \nwill be stored in the binding of the corresponding variable, otherwise |value|\nwill be stored in it.\n])\n(item [\n|(variable value test?)|: if a value is passed when the procedure is called, it \nwill be stored in the binding of the corresponding variable, otherwise |value|\nwill be stored in it. Furthermore, |test?| will be given the value |¤t| if \na value is passed for the given variable, otherwise |test?| is set to |¤f|\n])\n)\n£\n\nHereafter are some examples using |:optional| parameters\n@lisp\n((lambda (a b :optional c d) (list a b c d)) 1 2)\n                            => (1 2 #f #f)\n((lambda (a b :optional c d) (list a b c d)) 1 2 3)\n                            => (1 2 3 #f)\n((lambda (a b :optional c (d 100)) (list a b c d)) 1 2 3)\n                            => (1 2 3 100)\n((lambda (a b :optional c (d #f d?)) (list a b c d d?)) 1 2 3)\n                            => (1 2 3 #f #f)\n@end lisp\nThe form |:rest| parameter is similar to the dot notation seen before. \nIt is used before an identifier to collects the parameters in a single\nbinding:\n@lisp\n((lambda (a :rest b) (list a b)) 1)\n                            => (1 ())\n((lambda (a :rest b) (list a b)) 1 2)\n                            => (1 (2))\n((lambda (a :rest b) (list a b)) 1 2 3)\n                            => (1 (2 3))\n@end lisp\nThe form |:key| allows to use keyword parameter passing. All the parameters \nspecified after |:key| to the end of |<formals>| are keyword parameters. A \nkeyword  parameter can be declared using the three forms given for optional \nparameters. Here are some examples illustrating how to declare and how to use \nkeyword parameters:\n@lisp\n((lambda (a :key b c) (list a b c)) 1 :c 2 :b 3)\n                            => (1 3 2)\n((lambda (a :key b c) (list a b c)) 1 :c 2)     \n                            => (1 #f 2)\n((lambda (a :key (b 100 b?) c) (list a b c b?)) 1 :c 2)\n                            => (1 100 2 #f)\n@end lisp\nAt last, here is an example showing |:optional| |:rest| and |:key| parameters\n@lisp\n(define f (lambda (a :optional b :rest c :key d e) \n             (list a b c d e)))\n\n(f 1)                       => (1 #f () #f #f)\n(f 1 2)                     => (1 2 () #f #f)\n(f 1 2 :d 3 :e 4)           => (1 2 (:d 3 :e 4) 3 4)\n(f 1 :d 3 :e 4)             => (1 #f (:d 3 :e 4) 3 4)\n@end lisp\n])\n)" :similar ())

(set! :type syntax :synopsis "(set! <variable> <expression>)\n(set! (<proc> <arg> ...) <expression>)" :description "The first form of |set!| is the R5RS one:\n£\n|<Expression>| is evaluated, and the resulting value is stored in\nthe location to which |<variable>| is bound. |<Variable>| must be bound\neither in some region enclosing the |set!| expression or at top level.\n\n@lisp\n(define x 2)\n(+ x 1)                   =>  3\n(set! x 4)                =>  unspecified\n(+ x 1)                   =>  5\n@end lisp\n\nThe second form of |set!| is defined in ,(link-srfi 17):\n£ \nThis special form |set!|\nis extended so the first operand can be a procedure application, and not\njust a variable. The procedure is typically one that extracts a component\nfrom some data structure. Informally, when the procedure is called in the\nfirst operand of |set!|, it causes the corresponding component to be\nreplaced by the second operand. For example,\n@lisp\n(set (vector-ref x i) v)\n@end lisp\nwould be equivalent to:\n@lisp\n(vector-set! x i v)\n@end lisp\n\nEach procedure that may be used as the first operand to |set!| must have\na corresponding ,(emph \"setter\") procedure. The procedure |setter| (see below)\ntakes a procedure and returns the corresponding setter procedure.\nSo, \n@lisp\n(set! (proc arg ...) value)\n@end lisp\nis equivalent to the call\n@lisp\n((setter proc) arg ... value)\n@end lisp\n\nThe result of the |set!| expression is unspecified." :similar ())

(if :type syntax :synopsis "(if <test> <consequent> <alternate>)\n(if <test> <consequent>)" :description "An |if| expression is evaluated as follows: first, |<test>| is\nevaluated.  If it yields a true value, then |<consequent>| is\nevaluated and its value(s) is(are) returned.  Otherwise |<alternate>|\nis evaluated and its value(s) is(are) returned.  If |<test>| yields a\nfalse value and no |<alternate>| is specified, then the result of the\nexpression is ,(emph \"void\").\n\n@lisp\n  (if (> 3 2) 'yes 'no)           =>  yes\n  (if (> 2 3) 'yes 'no)           =>  no\n  (if (> 3 2)\n      (- 3 2)\n      (+ 3 2))                    =>  1\n@end lisp" :similar ())

(cond :type syntax :synopsis "(cond <clause1> <clause2> ...)" :description "In a |cond|, each |<clause>| should be of the form\n\n@lisp\n(<test> <expression1> ...)\n@end lisp\n\nwhere |<test>| is any expression.  Alternatively, a |<clause>| may be\nof the form\n\n@lisp\n(<test> => <expression>)\n@end lisp\n\nThe last |<clause>| may be an \"else clause,\" which has the form\n@lisp\n(else <expression1> <expression2> ...)\n@end lisp\n\nA cond expression is evaluated by evaluating the |<test>| expressions\nof successive |<clause>|s in order until one of them evaluates to a\ntrue value When a |<test>| evaluates to a true value, then the\nremaining |<expression>|s in its |<clause>| are evaluated in order,\nand the result(s) of the last |<expression>| in the |<clause>| is(are)\nreturned as the result(s) of the entire cond expression.  If the\nselected |<clause>| contains only the |<test>| and no |<expression>|s,\nthen the value of the |<test>| is returned as the result.  If the\nselected |<clause>| uses the => alternate form, then the\n|<expression>| is evaluated.  Its value must be a procedure that\naccepts one argument; this procedure is then called on the value of\nthe |<test>| and the value(s) returned by this procedure is(are)\nreturned by the cond expression.\n£\nIf all |<test>|s evaluate to false\nvalues, and there is no else clause, then the result of the\nconditional expression is ,(emph \"void\"); if there is an else clause,\nthen its |<expression>|s are evaluated, and the value(s) of the last\none is(are) returned.\n\n@lisp\n  (cond ((> 3 2) 'greater)\n        ((< 3 2) 'less))                    =>  greater\n\n  (cond ((> 3 3) 'greater)\n        ((< 3 3) 'less)\n        (else 'equal))                      =>  equal\n\n  (cond ((assv 'b '((a 1) (b 2))) => cadr)\n        (else #f))                          =>  2\n@end lisp" :similar ())

(case :type syntax :synopsis "(case <key> <clause1> <clause2> ...)" :description "In a |case|, each |<clause>| should have the form\n\n@lisp\n((<datum1> ...) <expression1> <expression2> ...),\n@end lisp\n\nwhere each |<datum>| is an external representation of some object.  All the\n|<datum>|s must be distinct.  The last |<clause>| may be an \"else clause,\" which\nhas the form\n\n@lisp\n    (else <expression1> <expression2> ...).\n@end lisp\n\nA case expression is evaluated as follows. |<Key>| is evaluated and\nits result is compared against each |<datum>|.  If the result of\nevaluating |<key>| is equivalent (in the sense of eqv?) to a\n|<datum>|, then the expressions in the corresponding |<clause>| are\nevaluated from left to right and the result(s) of the last expression\nin the |<clause>| is(are) returned as the result(s) of the case\nexpression.  If the result of evaluating |<key>| is different from\nevery |<datum>|, then if there is an else clause its expressions are\nevaluated and the result(s) of the last is(are) the result(s) of the\ncase expression; otherwise the result of the case expression is ,(emph \"void\").\n\n@lisp\n  (case (* 2 3)\n    ((2 3 5 7) 'prime)\n    ((1 4 6 8 9) 'composite))     =>  composite\n  (case (car '(c d))\n    ((a) 'a)\n    ((b) 'b))                     =>  void\n  (case (car '(c d))\n    ((a e i o u) 'vowel)\n    ((w y) 'semivowel)\n    (else 'consonant))            =>  consonant\n@end lisp" :similar ())

(when :type extended-syntax :synopsis "(when <test> <expression1> <expression2> ...)" :description "If the |<test>| expression yields a true value, the |<expression>|s are\nevaluated from left to right and the value of the last |<expression>| is\nreturned. Otherwise, |when| returns ,(emph \"void\")." :similar ())

(unless :type extended-syntax :synopsis "(unless <test> <expression1> <expression2> ...)" :description "If the |<test>| expression yields a false value, the |<expression>|s are\nevaluated from left to right and the value of the last |<expression>| is\nreturned. Otherwise, |unless| returns ,(emph \"void\")." :similar ())

(let :type syntax :synopsis "(let <bindings> <body>)\n(let <variable> <bindings> <body>)" :description "In a |let|, |<bindings>| should have the form\n\n@lisp\n((<variable1> <init1>) ...)\n@end lisp\n\nwhere each |<init>| is an expression, and |<body>| should be a sequence of one or\nmore expressions.  It is an error for a |<variable>| to appear more than once in\nthe list of variables being bound.\n£\nThe |<init>|s are evaluated in the current environment (in some\nunspecified order), the |<variable>|s are bound to fresh locations holding the\nresults, the |<body>| is evaluated in the extended environment, and the value(s)\nof the last expression of |<body>| is(are) returned.  Each binding of a\n|<variable>| has |<body>| as its region.\n\n@lisp\n(let ((x 2) (y 3))\n  (* x y))                      =>  6\n\n(let ((x 2) (y 3))\n  (let ((x 7)\n        (z (+ x y)))\n    (* z x)))                   =>  35\n@end lisp\n\nThe second form of |let|, which is generally called a ,(emph \"named let\"),\nis a variant on the syntax of let which provides a more general\nlooping construct than |do| (@pxref{do}) and may also be used to\nexpress recursions. It has the same syntax and semantics as ordinary\nlet except that |<variable>| is bound within |<body>| to a procedure whose\nformal arguments are the bound variables and whose body is |<body>|.\nThus the execution of |<body>| may be repeated by invoking the procedure\nnamed by |<variable>|.\n\n@lisp\n(let loop ((numbers '(3 -2 1 6 -5))\n           (nonneg  '())\n           (neg     '()))\n  (cond ((null? numbers) (list nonneg neg))\n        ((>= (car numbers) 0)\n           (loop (cdr numbers)\n                 (cons (car numbers) nonneg)\n                 neg))\n        ((< (car numbers) 0)\n           (loop (cdr numbers)\n                  nonneg\n                  (cons (car numbers) neg)))))\n   =>  ((6 1 3) (-5 -2))\n@end lisp" :similar ())

(let* :type syntax :synopsis "(let* <bindings> <body>)" :description "In a |let*|, |<bindings>| should have the same form as in a |let| (however, a \n<variable> can appear more than once in the list of variables being bound).\n£\n|Let*| is similar to |let|, but the bindings are performed sequentially\nfrom left to right, and the region of a binding indicated by \n@lisp\n(<variable> <init>) \n@end lisp\nis that part of the |let*| expression to the right of the binding.  Thus\nthe second binding is done in an environment in which the first binding is\nvisible, and so on.\n\n@lisp\n(let ((x 2) (y 3))\n  (let* ((x 7)\n         (z (+ x y)))\n    (* z x)))             =>  70\n@end lisp" :similar ())

(letrec :type syntax :synopsis "(letrec <bindings> <body>)" :description "<bindings> should have the form as in |let|. \n\nThe |<variable>|s are bound to fresh locations holding undefined\nvalues, the |<init>|s are evaluated in the resulting environment (in\nsome unspecified order), each |<variable>| is assigned to the result\nof the corresponding |<init>|, the |<body>| is evaluated in the\nresulting environment, and the value(s) of the last expression in\n|<body>| is(are) returned.  Each binding of a |<variable>| has the\nentire |letrec| expression as its region, making it possible to define\nmutually recursive procedures.\n\n@lisp\n(letrec ((even? (lambda (n)\n                  (if (zero? n)\n                      #t\n                      (odd? (- n 1)))))\n         (odd?  (lambda (n)\n                  (if (zero? n)\n                      #f\n                      (even? (- n 1))))))\n  (even? 88))\n                  =>  #t\n@end lisp" :similar ())

(begin :type syntax :synopsis "(begin <expression1> <expression2> ...)" :description "The |<expression>|s are evaluated sequentially from left to right, and the\nvalue(s) of the last |<expression>| is(are) returned.  This expression type is\nused to sequence side effects such as input and output.\n\n@lisp\n  (define x 0)\n\n  (begin (set! x 5)\n         (+ x 1))                  =>  6\n\n  (begin (display \"4 plus 1 equals \")\n         (display (+ 4 1)))        @print{} 4 plus 1 equals 5\n                                   =>  void\n@end lisp" :similar ())

(do :type syntax :synopsis "(do [[<var1> <init1> <step1>] ...] [<test> <expr> ...] <command> ...)" :description "|Do| is an iteration construct.  It specifies a set of variables to be\nbound, how they are to be initialized at the start, and how they are\nto be updated on each iteration.  When a termination condition is met,\nthe loop exits after evaluating the |<expr>|s.\n£\n|Do| expressions are evaluated as follows: The |<init>| expressions\nare evaluated (in some unspecified order), the |<var>|s are bound\nto fresh locations, the results of the |<init>| expressions are stored\nin the bindings of the |<var>|s, and then the iteration phase\nbegins.\n£\nEach iteration begins by evaluating |<test>|; if the result is false\nthen the |<command>| expressions are evaluated in order for effect,\nthe |<step>| expressions are evaluated in some unspecified order, the\n|<var>|s are bound to fresh locations, the results of the |<step>|s\nare stored in the bindings of the |<var>|s, and the next iteration\nbegins.\n£\nIf |<test>| evaluates to a true value, then the |<expr>|s are\nevaluated from left to right and the value(s) of the last |<expr>|\nis(are) returned.  If no |<expr>|s are present, then the value of\nthe do expression is ,(emph \"void\").\n£\nThe region of the binding of a |<var>| consists of the entire do\nexpression except for the |<init>|s.  It is an error for a |<var>| to\nappear more than once in the list of do variables.\n£\nA |<step>| may be omitted, in which case the effect is the same as if \n@lisp\n(<var> <init> <var>) \n@end lisp \nhad been written.\n\n@lisp\n  (do ((vec (make-vector 5))\n       (i 0 (+ i 1)))\n      ((= i 5) vec)\n    (vector-set! vec i i))            =>  #(0 1 2 3 4)\n\n  (let ((x '(1 3 5 7 9)))\n    (do ((x x (cdr x))\n         (sum 0 (+ sum (car x))))\n        ((null? x) sum)))             =>  25\n@end lisp" :similar ())

(quasiquote :type syntax :synopsis "(quasiquote <template>) \n`<template>" :description "\"Backquote\" or \"quasiquote\" expressions are useful for constructing a\nlist or vector structure when most but not all of the desired structure\nis known in advance.  If no commas appear within the |<template>|,\nthe result of evaluating |`<template>| is equivalent to the result of\nevaluating |'<template>|.  If a comma appears within the \n|<template>|, however, the expression following the comma is evaluated\n(\"unquoted\") and its result is inserted into the structure instead of\nthe comma and the expression.  If a comma appears followed immediately\nby an at-sign (@), then the following expression must evaluate to a\nlist; the opening and closing parentheses of the list are then\n\"stripped away\" and the elements of the list are inserted in place of the comma\nat-sign expression sequence.  A comma at-sign should only appear within\na list or vector |<template>|.\n\n@lisp\n`(list \\,(+ 1 2) 4)  =>  (list 3 4)\n(let ((name 'a)) `(list ,name ',name))\n                    =>  (list a (quote a))\n`(a \\,(+ 1 2) ,@(map abs '(4 -5 6)) b)\n                    =>  (a 3 4 5 6 b)\n`((foo \\,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))\n                    =>  ((foo 7) . cons)\n`#(10 5 \\,(sqrt 4) ,@(map sqrt '(16 9)) 8)\n                    =>  #(10 5 2 4 3 8)\n@end lisp\n\nQuasiquote forms may be nested.  Substitutions are made only for unquoted\ncomponents appearing at the same nesting level as the outermost backquote.  \nThe nesting level increases by one inside each successive quasiquotation, \nand decreases by one inside each unquotation.\n\n@lisp\n`(a `(b \\,(+ 1 2) \\,(foo \\,(+ 1 3) d) e) f)\n          =>  (a `(b \\,(+ 1 2) \\,(foo 4 d) e) f)\n(let ((name1 'x)\n      (name2 'y))\n  `(a `(b ,,name1 ,',name2 d) e))\n          =>  (a `(b ,x ,'y d) e)\n@end lisp\n\nThe two notations |`<template>| and |(quasiquote <template>)| are identical\nin all respects.  |,<expression>| is identical to |(unquote <expression>)|, and\n|,@<expression>| is identical to |(unquote-splicing <expression>)|.\n\n" :similar ())

(define-macro :type extended-syntax :synopsis "(define-macro (<name> <formals>) <body>)\n(define-macro <name> (lambda <formals> <body>))" :description "|define-macro| can be used to define low-level macro\n(i.e. ,(emph \"non hygienic\") macros). This form is similar to the\n|defmacro| form of Common Lisp.\n@lisp\n(define-macro (incr x) `(set! ,x (+ ,x 1)))\n(let ((a 1)) (incr a) a)   => 2\n\n(define-macro (when test . body)\n  `(if ,test ,@(if (null? (cdr body)) body `((begin ,@body)))))\n(macro-expand '(when a b)) => (if a b)\n(macro-expand '(when a b c d)) \n                           => (if a (begin b c d))\n\n(define-macro (my-and . exprs)\n  (cond\n   ((null? exprs)        #t)\n   ((= (length exprs) 1) (car exprs))\n   (else                 `(if \\,(car exprs) \n\t\t\t      (my-and ,@(cdr exprs)) \n\t\t\t      #f))))\n(macro-expand '(my-and a b c))\n                          => (if a (my-and b c) #f)\n@end lisp" :similar ())

(macro-expand :type extended :synopsis "(macro-expand form)" :description "Returns the macro expansion of |form| if it is a macro call,\notherwise |form| is returned unchanged.\n\n@lisp\n(define-macro (incr x) `(set! ,x (+ ,x 1)))\n(macro-expand '(incr foo)) => (set! foo (+ foo 1))\n(macro-expand '(car bar))  => (car bar)\n@end lisp" :similar ())

(eval :type procedure :synopsis "(eval expression environment)\n(eval expression) " :description "Current form of STklos |eval| is not conform to R5RS. \n£\n,(TODO \"MUST BE CORRECTED FOR A NEXT RELEASE\")" :similar ())

(cddddr :type procedure :synopsis "(caar pair)\n(cadr pair)\n...\n(cdddar pair)\n(cddddr pair)" :description "These procedures are compositions of |car| and |cdr|, where for example\n|caddr| could be defined by\n@lisp\n   (define caddr (lambda (x) (car (cdr (cdr x)))))\n@end lisp\nArbitrary compositions, up to four deep, are provided.\nThere are twenty-eight of these procedures in all." :similar (cadddr cdaddr caaddr cddadr cadadr cdaadr caaadr cdddar caddar cdadar caadar cddaar cadaar cdaaar caaaar cdddr caddr cdadr caadr cddar cadar cdaar caaar cddr cadr cdar caar))

(cadddr :see cddddr)
(cdaddr :see cddddr)
(caaddr :see cddddr)
(cddadr :see cddddr)
(cadadr :see cddddr)
(cdaadr :see cddddr)
(caaadr :see cddddr)
(cdddar :see cddddr)
(caddar :see cddddr)
(cdadar :see cddddr)
(caadar :see cddddr)
(cddaar :see cddddr)
(cadaar :see cddddr)
(cdaaar :see cddddr)
(caaaar :see cddddr)
(cdddr :see cddddr)
(caddr :see cddddr)
(cdadr :see cddddr)
(caadr :see cddddr)
(cddar :see cddddr)
(cadar :see cddddr)
(cdaar :see cddddr)
(caaar :see cddddr)
(cddr :see cddddr)
(cadr :see cddddr)
(cdar :see cddddr)
(caar :see cddddr)
(call/cc :type procedure :synopsis "(call-with-current-continuation proc)\n(call/cc proc)" :description " |Proc| must be a procedure of one argument. The procedure\n|call-with-current-continuation| packages up the current continuation\n(see the rationale below) as an ``escape procedure'' and passes it as\nan argument to |proc|. The escape procedure is a Scheme procedure that, if\nit is later called, will abandon whatever continuation is in effect at\nthat later time and will instead use the continuation that was in effect\nwhen the escape procedure was created. Calling the escape procedure may cause\nthe invocation of before and after thunks installed using |dynamic-wind|.\n£\nThe escape procedure accepts the same number of arguments as\nthe continuation to the original call to\n|call-with-current-continuation|. Except for continuations created\nby the |call-with-values| procedure, all continuations take exactly\none value.\n£\nThe escape procedure that is passed to proc has unlimited extent\njust like any other procedure in Scheme. It may be stored in variables\nor data structures and may be called as many times as desired.\n£\nThe following examples show only the most common ways in which\n|call-with-current-continuation| is used. If all real uses were as simple\nas these examples, there would be no need for a procedure with the power\nof |call-with-current-continuation|.\n\n@lisp\n(call-with-current-continuation\n  (lambda (exit)\n    (for-each (lambda (x)\n                (if (negative? x)\n                    (exit x)))\n              '(54 0 37 -3 245 19))\n    #t))                                =>  -3\n\n(define list-length\n  (lambda (obj)\n    (call-with-current-continuation\n      (lambda (return)\n        (letrec ((r\n                  (lambda (obj)\n                    (cond ((null? obj) 0)\n                          ((pair? obj)\n                           (+ (r (cdr obj)) 1))\n                          (else (return #f))))))\n          (r obj))))))\n\n(list-length '(1 2 3 4))                =>  4\n(list-length '(a b . c))                =>  #f\n@end lisp\n\n,(bold \"Rationale:\") A common use of |call-with-current-continuation|\nis for structured, non-local exits from loops or procedure bodies,\nbut in fact |call-with-current-continuation| is extremely useful\nfor implementing a wide variety of advanced control structures.\n£\nWhenever a Scheme expression is evaluated there is a continuation\nwanting the result of the expression. The continuation represents\nan entire (default) future for the computation. If the expression\nis evaluated at top level, for example, then the continuation\nmight take the result, print it on the screen, prompt for the\nnext input, evaluate it, and so on forever. Most of the time the\ncontinuation includes actions specified by user code, as in a\ncontinuation that will take the result, multiply it by the value\nstored in a local variable, add seven, and give the answer to the\ntop level continuation to be printed. Normally these ubiquitous\ncontinuations are hidden behind the scenes and programmers do not\nthink much about them. On rare occasions, however, a programmer\nmay need to deal with continuations explicitly.\n|Call-with-current-continuation| allows Scheme\nprogrammers to do that by creating a procedure that acts just\nlike the current continuation.\n£\n,(bold \"Note:\") |call/cc| is just another name for \n|call-with-current-continuation|. " :similar (call-with-current-continuation))

(call-with-current-continuation :see call/cc)
(dynamic-wind :type procedure :synopsis "(dynamic-wind before thunk after)" :description "Current version of |dynamic-wind| mimics the R5RS one. In particular, it \ndoes not yet interact with |call-with-current-continuation| as required by \nR5RS.\n£\nCalls |thunk| without arguments, returning the result(s) of this call.  \n|Before| and |after| are called, also without arguments, as required by\nthe following rules (note that in the absence of calls to continuations \ncaptured using |call-with-current-continuation| the three arguments are\ncalled once each, in order).  |Before| is called whenever execution enters\nthe dynamic extent of the call to |thunk| and |after| is called whenever \nit exits that dynamic extent.  The dynamic extent of a procedure call is\nthe period between when the call is initiated and when it returns. \nIn Scheme, because of |call-with-current-continuation|, the dynamic \nextent of a call may not be a single, connected time period. It is\ndefined as follows:\n,(itemize\n  (item [The dynamic extent is entered when execution of the body of\nthe called procedure begins.])\n\n  (item [The dynamic extent is also entered when execution is not\nwithin the dynamic extent and a continuation is invoked that was\ncaptured (using |call-with-current-continuation|) during the dynamic extent.])\n\n  (item [It is exited when the called procedure returns.])\n\n  (item [It is also exited when execution is within the dynamic\nextent and a continuation is invoked that was captured while not within\nthe dynamic extent.]))\n£\nIf a second call to |dynamic-wind| occurs within the dynamic extent\nof the call to thunk and then a continuation is invoked in such a\nway that the afters from these two invocations of |dynamic-wind|\nare both to be called, then the after associated with the\nsecond (inner) call to |dynamic-wind| is called first.\n\nIf a second call to |dynamic-wind| occurs within the dynamic extent\nof the call to |thunk| and then a continuation is invoked in such a\nway that the befores from these two invocations of |dynamic-wind|\nare both to be called, then the before associated with the\nfirst (outer) call to |dynamic-wind| is called first.\n\nIf invoking a continuation requires calling the |before| from one\ncall to |dynamic-wind| and the |after| from another, then the |after|\nis called first.\n\nThe effect of using a captured continuation to enter or exit the\ndynamic extent of a call to |before| or |after| is undefined.\n@lisp\n(let ((path '())\n      (c #f))\n  (let ((add (lambda (s)\n               (set! path (cons s path)))))\n    (dynamic-wind\n      (lambda () (add 'connect))\n      (lambda ()\n        (add (call-with-current-continuation\n               (lambda (c0)\n                 (set! c c0)\n                 'talk1))))\n      (lambda () (add 'disconnect)))\n    (if (< (length path) 4)\n        (c 'talk2)\n        (reverse path))))\n                  =>  (connect talk1 disconnect\n                       connect talk2 disconnect)\n@end lisp" :similar ())

(with-output-to-file :type procedure :synopsis "(with-input-from-file string thunk)\n(with-output-to-file string thunk)" :description "|String| should be a string naming a file, and |proc| should be a \nprocedure of no arguments. For |with-input-from-file|, the file should \nalready exist. The file is opened for input or output, an input or output\nport connected to it is made the default value returned by \n|current-input-port| or |current-output-port| (and is used by |(read)|, \n|(write obj)|, and so forth), and the thunk is called with no arguments. \nWhen the thunk returns, the port is closed and the previous default is\nrestored. |With-input-from-file| and |with-output-to-file| return(s) \nthe value(s) yielded by thunk. \n£\nThe following example uses a pipe port opened for reading. It permits to \nread all the lines produced by an external ,(emph \"ls\") command (i.e. the \noutput of the ,(emph \"ls\") command is ,(emph \"redirected\") to the Scheme pipe \nport).\n@lisp \n(with-input-from-file \"@pipe ls -ls\" \n  (lambda ()\n    (do ((l (read-line) (read-line)))\n        ((eof-object? l))\n      (display l)\n      (newline))))\n@end lisp\n\nHereafter is another example of Unix command redirection. This time,\nit is the standard input of the Unix command which is redirected.\n@lisp\n(with-output-to-file \"@pipe mail root\"\n  (lambda ()\n    (display \"A simple mail from Scheme\")\n    (newline)))\n@end lisp" :similar (with-input-from-file))

(with-input-from-file :see with-output-to-file)
(with-error-to-file :type extended :synopsis "(with-error-to-file string thunk)" :description "This procedure is similar to with-output-to-file, excepted that it uses the \ncurrent error port instead of the output port." :similar ())

(with-input-from-string :type extended :synopsis "(with-input-from-string string thunk)" :description "A string port is opened for input from |string|. |Current-input-port|\nis set to the port and |thunk| is called. When |thunk| returns,\nthe previous default input port is restored. |With-input-from-string|\nreturns the value(s) computed by |thunk|.\n@lisp\n(with-input-from-string \"123 456\" \n  (lambda () (read)))                       =>  123\n@end lisp" :similar ())

(with-output-to-string :type extended :synopsis "(with-output-to-string thunk)" :description "A string port is opened for output. |Current-output-port|\nis set to it and |thunk| is called. When |thunk| returns,\nthe previous default output port is restored. |With-output-to-string|\nreturns the string containing the text written on the string port.\n@lisp\n(with-output-to-string \n   (lambda () (write 123) (write \"Hello\"))) => \"123\\\\\"Hello\\\\\"\"\n@end lisp " :similar ())

(with-error-to-port :type extended :synopsis "(with-input-from-port port thunk)\n(with-output-to-port port thunk)\n(with-error-to-port port thunk)" :description "|Port| should be a port, and |proc| should be a \nprocedure of no arguments. These procedures do a job similar to the \n|with-...-file| counterparts  excepted that they use an open port instead \nof string specifying a file name" :similar (with-output-to-port with-input-from-port))

(with-output-to-port :see with-error-to-port)
(with-input-from-port :see with-error-to-port)
(call-with-output-file :type procedure :synopsis "(call-with-input-file string proc)\n(call-with-output-file string proc)" :description "|String| should be a string naming a file, and |proc| should be a procedure \nthat accepts one argument. For |call-with-input-file|, the file should \nalready exist. These procedures call |proc| with one argument: the port \nobtained by opening the named file for input or output. If the file cannot\nbe opened, an error is signaled. If |proc| returns, then the port is closed\nautomatically and the value(s) yielded by the proc is(are) returned. \nIf proc does not return, then the port will not be closed automatically.\n£\n,(bold \"Rationale:\") Because Scheme's escape procedures have unlimited extent, \nit is possible to escape from the current continuation but later to escape \nback in. If implementations were permitted to close the port on any escape\nfrom the current continuation, then it would be impossible to write portable\ncode using both |call-with-current-continuation| and |call-with-input-file|\nor |call-with-output-file|." :similar (call-with-input-file))

(call-with-input-file :see call-with-output-file)
(rationalize :type procedure :synopsis "(rationalize x y)" :description "Rationalize returns the simplest rational number differing from |x|\nby no more than |y|. A rational number |r1| is simpler than another\nrational number |r2| if |r1| = |p1/q1| and |r2| = |p2/q2| (in lowest\nterms) and abs(p1) <= abs(p2) and abs(q1) <= abs(q2). Thus |3/5| is \nsimpler than |4/7|. Although not all rationals are comparable in \nthis ordering  (consider |2/7| and |3/5|) any interval contains a\nrational number that\nis simpler than every other rational number in that interval (the\nsimpler |2/5| lies between |2/7| and |3/5|). Note that |0| = |0/1| is the\nsimplest rational of all.\n@lisp\n(rationalize\n   (inexact->exact .3) 1/10)  => 1/3    ; exact\n(rationalize .3 1/10)         => #i1/3  ; inexact\n@end lisp" :similar ())

(delay :type procedure :synopsis "(delay <expression>)" :description "The |delay| construct is used together with the procedure |force|\nto implement ,(emph \"lazy evaluation\") or ,(emph \"call by need\"). |(delay\n<expression>)| returns an object called a ,(emph \"promise\") which at some\npoint in the future may be asked (by the |force| procedure) to\nevaluate |<expression>|, and deliver the resulting value.\nThe effect of |<expression>| returning multiple values is unpredictable.\n\nSee the description of |force| (@pxref{force}) for a more complete\ndescription of |delay|." :similar ())


;; Source file "regexp.stk"

(regexp-replace-all :type extended :synopsis "(regexp-replace pattern string substitution)\n(regexp-replace-all pattern string substitution)" :description "|Regexp-replace| matches the regular expression |pattern| against\n|string|. If there is a match, the portion of |string| which matches\n|pattern| is replaced by the |substitution| string. If there is no\nmatch, |regexp-replace| returns |string| unmodified. Note that the\ngiven |pattern| could be here either a string or a regular expression.\n£\nIf |pattern| contains |\\\\n| where ,(bold \"n\") is a digit between 1 and 9, \nthen it is replaced in the substitution with the portion of string that\nmatched the ,(bold \"n\")-th parenthesized subexpression of |pattern|. If\n,(bold \"n\") is equal to 0, then it is replaced in |substitution|\nwith the portion of |string| that matched |pattern|.\n£\n|Regexp-replace| replaces the first occurrence of |pattern| in |string|. \nTo replace ,(bold \"all\") the occurrences of |pattern|, use |regexp-replace-all|.\n\n@lisp\n(regexp-replace \"a*b\" \"aaabbcccc\" \"X\")\n                   => \"Xbcccc\"\n(regexp-replace (string->regexp \"a*b\") \"aaabbcccc\" \"X\")\n                   => \"Xbcccc\"\n(regexp-replace \"(a*)b\" \"aaabbcccc\" \"X\\\\1Y\")\n                   => \"XaaaYbcccc\"\n(regexp-replace \"f(.*)r\" \"foobar\" \"\\\\1 \\\\1\")\n                   => \"ooba ooba\"\n(regexp-replace \"f(.*)r\" \"foobar\" \"\\\\0 \\\\0\")\n                   => \"foobar foobar\"\n\n(regexp-replace \"a*b\" \"aaabbcccc\" \"X\")\n                   => \"Xbcccc\"\n(regexp-replace-all \"a*b\" \"aaabbcccc\" \"X\")\n                   => \"XXcccc\"\n@end lisp" :similar (regexp-replace))

(regexp-replace :see regexp-replace-all)

;; Source file "repl.stk"

(repl :type extended :synopsis "(repl)\n(repl :in inport :out outport :err errport)" :description "This procedure launches a new Read-Eval-Print-Loop. Calls to |repl| can be\nembedded. The ports used for input/output as well as the error port can\nbe passed when |repl| is called. If not passed, they default to\n|current-input-port|, |current-output-port| and |current-error-port|." :similar ())


;; Source file "runtime.stk"


;; Source file "srfi-0.stk"


;; Source file "struct.stk"

(define-struct :type extended-syntax :synopsis "(define-struct <name> <slot> ...)" :description "Defines a structure type whose name is |<name>|. Once a structure type is\ndefined, the following symbols are bound:\n,(itemize\n(item [|<name>| denotes the structure type.])\n\n(item [|make-<name>| is a procedure which takes 0 to |n| parameters (if there\nare |n| slots defined). Each parameter is assigned to the corresponding\nfield (in the definition order).])\n\n(item [|<name>?| is a predicate which returns |¤t| when applied to an\ninstance of the |<name>| structure type and |¤f| otherwise.])\n\n(item [|<name>-<slot>| (one for each defined |<slot>|) to read the\ncontent of an instance of the |<name>| structure type. Writting the\ncontent of a slot can be done using a generalized |set!|.])\n)\n\n@lisp\n(define-struct point x y)\n(define p (make-point 1 2))\n(point? p)    => #t\n(point? 100)  => #f\n(point-x p)   => 1\n(point-y p)   => 2\n(set! (point-x p) 10)\n(point-x p)   => 10\n@end lisp\n" :similar ())

